<!DOCTYPE html>
<html lang="zh_CN" class="desktop-view not-mobile-device  anon">
 <head> 
  <meta charset="utf-8" /> 
  <title>很全的Python的面试题 - 面试 - 算法组</title> 
  <meta name="description" content="Python语言特性

1 Python的函数参数传递

看两个例子: 

 a = 1
def fun(a):
    a = 2
fun(a)
print a  # 1

 a = []
def fun(a):
    a.append(1)
fun(a)
print a  # [1]

所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。 

这里记住的是类型是属于对象的，而不是变量。而对象有两种&amp;hellip;" /> 
  <meta name="author" content="" /> 
  <meta name="generator" content="Discourse 1.6.0.beta1 - https://github.com/discourse/discourse version cc25716e475e6eed70532c8526d9e612899d61d8" /> 
  <link rel="icon" type="image/png" href="http://s1.suanfazu.com/favicon.ico" /> 
  <link rel="apple-touch-icon" type="image/png" href="/images/default-apple-touch-icon.png" /> 
  <meta name="theme-color" content="#ffffff" /> 
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes" /> 
  <link rel="canonical" href="http://suanfazu.com/t/python/13524" /> 
  <style>
  @font-face {
    font-family: 'FontAwesome';
    src: url('//cdn.suanfazu.com/assets/fontawesome-webfont-e2f6015310d7f63fa1537ab9822f1446.eot?http://suanfazu.com&amp;2&v=4.5.0');
    src: url('//cdn.suanfazu.com/assets/fontawesome-webfont-e2f6015310d7f63fa1537ab9822f1446.eot?http://suanfazu.com&amp;2&v=4.5.0#iefix') format('embedded-opentype'),
         url('//cdn.suanfazu.com/assets/fontawesome-webfont-6d0ddb44b6016bd7adf993e5b9d47ae6.woff2?http://suanfazu.com&amp;2&v=4.5.0') format('woff2'),
         url('//cdn.suanfazu.com/assets/fontawesome-webfont-90e687312466f7a4993c85399c116f2f.woff?http://suanfazu.com&amp;2&v=4.5.0') format('woff'),
         url('//cdn.suanfazu.com/assets/fontawesome-webfont-f436f853ea7573a6b623eea9bc9d66ec.ttf?http://suanfazu.com&amp;2&v=4.5.0') format('truetype');
    font-weight: normal;
    font-style: normal;
  }
</style> 
  <link href="//cdn.suanfazu.com/stylesheets/desktop_3cd538a579f35992edf155ad9b22c8867cb58252.css?__ws=suanfazu.com" media="all" rel="stylesheet" /> 
  <link class="custom-css" rel="stylesheet" href="//cdn.suanfazu.com/site_customizations/7e202ef2-56d7-47d5-98d8-a9c8d15e57dd.css?target=desktop&amp;v=f1b43fef7075ecbadc1dae23dd159bfb&amp;__ws=suanfazu.com" type="text/css" media="all" /> 
  <meta name="fragment" content="!" /> 
  <script>
      window.EmberENV = window.EmberENV || {};
      window.EmberENV['FORCE_JQUERY'] = true;
    </script> 
  <script src="//cdn.suanfazu.com/assets/preload_store-d16a3675434b5a0043157cfc2b850471.js"></script> 
  <script src="//cdn.suanfazu.com/assets/locales/zh_CN-d60d5bfbfe48e142f16fb1ed5d4cdc7e.js"></script> 
  <script src="//cdn.suanfazu.com/assets/ember_jquery-37c15254b70c40ceb7888cb7248c79d6.js"></script> 
  <script src="//cdn.suanfazu.com/assets/vendor-17831e059f10b3b31503434a43f32398.js"></script> 
  <script src="//cdn.suanfazu.com/assets/application-8bf39ee2538a975d4339495316dc34a1.js"></script> 
  <style>.cooked {line-height:1.6em;font-size:1.1em;} .adsense_topic_bottom{text-align:left}
.d-header .title{margin-top:10px;}
@media screen and (max-width : 650px) {
.nav-pills>li {margin-right:0px}
.nav-pills>li>a{padding:5px 6px }
}
@media screen and (max-width : 400px) {
.nav-pills>li {margin-right:0px}
.nav-pills>li>a{padding:5px 5px }
.ol.category-breadcrumb{margin-right:2px;}
}
</style> 
  <link rel="manifest" href="/manifest.json" /> 
  <link rel="alternate" type="application/rss+xml" title="'很全的Python的面试题' 的 RSS 内容聚合" href="http://suanfazu.com/t/python/13524.rss" /> 
  <meta property="og:site_name" content="算法组" /> 
  <meta name="twitter:card" content="summary" /> 
  <meta property="og:url" content="http://suanfazu.com/t/python/13524/1" /> 
  <meta name="twitter:url" content="http://suanfazu.com/t/python/13524/1" /> 
  <meta property="og:title" content="很全的Python的面试题" /> 
  <meta name="twitter:title" content="很全的Python的面试题" /> 
  <meta property="og:description" content="Python语言特性  1 Python的函数参数传递  看两个例子:    a = 1 def fun(a):     a = 2 fun(a) print a  # 1   a = [] def fun(a):     a.append(1) fun(a) print a  # [1]  所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。   这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。(这就是这个问题的重点)   当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.   如果还不明白的话,这里有更好的解释:..." /> 
  <meta name="twitter:description" content="Python语言特性  1 Python的函数参数传递  看两个例子:    a = 1 def fun(a):     a = 2 fun(a) print a  # 1   a = [] def fun(a):     a.append(1) fun(a) print a  # [1]  所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。   这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。(这就是这个问题的重点)   当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.   如果还不明白的话,这里有更好的解释:..." /> 
  <meta name="twitter:label1" value="阅读时间" /> 
  <meta name="twitter:data1" value="6 mins 91" /> 
  <meta name="twitter:label2" value="赞" /> 
  <meta name="twitter:data2" value="2 78" /> 
 </head> 
 <body> 
  <noscript data-path="/t/python/13524/1"> 
   <header class="d-header"> 
    <div class="wrap"> 
     <div class="contents"> 
      <div class="row"> 
       <div class="title span13"> 
        <a href="/"> <h2 id="site-text-logo">算法组</h2> </a> 
       </div> 
       <div class="panel clearfix"> 
        <a href="/login" class="btn btn-primary btn-small login-button"><i class="fa fa-user"></i> 登录</a> 
       </div> 
      </div> 
     </div> 
    </div> 
   </header> 
   <div id="main-outlet" class="wrap"> 
    <!-- preload-content: --> 
    <h1> <a href="/t/python/13524">很全的Python的面试题</a> </h1> 
    <div id="breadcrumbs"> 
     <div id="breadcrumb-0" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb-1"> 
      <a href="/c/mian-shi" itemprop="url"> <span itemprop="title">面试</span> </a> 
     </div> 
     <div id="breadcrumb-1" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"> 
      <a href="http://suanfazu.com/tags/python" itemprop="url"> <span itemprop="title">python</span> </a> 
     </div> 
    </div> 
    <div class="tags">
      标签: python 
    </div> 
    <hr /> 
    <div itemscope="" itemtype="http://schema.org/Article"> 
     <div class="creator"> 
      <span> <a href="/users/pythoner"><b itemprop="author">pythoner</b></a> <time datetime="2016-05-22T03:18:04Z" itemprop="datePublished"> 2016-05-22 03:18:04 UTC </time> </span> 
      <span itemprop="position">#1</span> 
     </div> 
     <div class="post" itemprop="articleBody"> 
      <h1>Python语言特性</h1> 
      <h2>1 Python的函数参数传递</h2> 
      <p>看两个例子:</p> 
      <p></p>
      <pre><code class="lang-python">a = 1
def fun(a):
    a = 2
fun(a)
print a  # 1</code></pre> 
      <p></p>
      <pre><code class="lang-python">a = []
def fun(a):
    a.append(1)
fun(a)
print a  # [1]</code></pre> 
      <p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。</p> 
      <p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。(这就是这个问题的重点)</p> 
      <p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p> 
      <p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" rel="nofollow">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p> 
      <h2>2 Python中的元类(metaclass)</h2> 
      <p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</p> 
      <h2>3 <span class="mention">@staticmethod</span>和<span class="mention">@classmethod</span> </h2> 
      <p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p> 
      <p></p>
      <pre><code class="lang-python">def foo(x):
    print &quot;executing foo(%s)&quot;%(x)

class A(object):
    def foo(self,x):
        print &quot;executing foo(%s,%s)&quot;%(self,x)

    @classmethod
    def class_foo(cls,x):
        print &quot;executing class_foo(%s,%s)&quot;%(cls,x)

    @staticmethod
    def static_foo(x):
        print &quot;executing static_foo(%s)&quot;%x

a=A()</code></pre> 
      <p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p> 
      <p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p> 
      <p>|\|实例方法|类方法|静态方法|<br />|:--|:--|:--|:--|<br />|a = A()|a.foo(x)|a.class_foo(x)|a.static_foo(x)|<br />|A|不可用|A.class_foo(x)|A.static_foo(x)|</p> 
      <p>更多关于这个问题:http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</p> 
      <h2>4 类变量和实例变量</h2> 
      <p></p>
      <pre><code class="lang-python">class Person:
    name=&quot;aaa&quot;

p1=Person()
p2=Person()
p1.name=&quot;bbb&quot;
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa</code></pre> 
      <p>类变量就是供类使用的变量,实例变量就是供实例使用的.</p> 
      <p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p> 
      <p>可以看看下面的例子:</p> 
      <p></p>
      <pre><code class="lang-python">class Person:
    name=[]

p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]</code></pre> 
      <p>参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</p> 
      <h2>5 Python自省</h2> 
      <p>这个也是python彪悍的特性.</p> 
      <p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p> 
      <h2>6 字典推导式</h2> 
      <p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p> 
      <p></p>
      <pre><code class="lang-python">d = {key: value for (key, value) in iterable}</code></pre> 
      <h2>7 Python中单下划线和双下划线</h2> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt; class MyClass():
...     def __init__(self):
...             self.__superprivate = &quot;Hello&quot;
...             self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute '__superprivate'
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}</code></pre> 
      <p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</p> 
      <p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.</p> 
      <p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名.</p> 
      <p>详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</p> 
      <p>或者: <a href="http://www.zhihu.com/question/19754941" rel="nofollow">http://www.zhihu.com/question/19754941</a></p> 
      <h2>8 字符串格式化:%和.format</h2> 
      <p>.format在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p> 
      <p></p>
      <pre><code class="lang-auto">&quot;hi there %s&quot; % name</code></pre> 
      <p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p> 
      <p></p>
      <pre><code class="lang-auto">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</code></pre> 
      <p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.</p> 
      <p>你为什么不用它?</p> 
      <ul> 
       <li>不知道它(在读这个之前)</li> 
       <li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4" rel="nofollow">issue <span class="hashtag">#4</span></a>))</li> 
      </ul> 
      <aside class="onebox stackexchange"> 
       <header class="source"> 
        <a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" rel="nofollow"> stackoverflow.com </a> 
       </header> 
       <article class="onebox-body"> 
        <a href="http://stackoverflow.com/users/231463/northisup" target="_blank" rel="nofollow"> <img alt="NorthIsUp" src="https://www.gravatar.com/avatar/887048987be67f10649a9dfacced6606?s=128&amp;d=identicon&amp;r=PG" class="thumbnail" width="" height="" /> </a> 
        <h4> <a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="nofollow">Python string formatting: % vs. .format</a> </h4> 
        <div class="date">
          asked by 
         <a href="http://stackoverflow.com/users/231463/northisup" target="_blank" rel="nofollow"> NorthIsUp </a> on 
         <a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="nofollow">06:46PM - 22 Feb 11</a> 
        </div> 
        <div> 
         <strong>python, performance, logging, string-formatting</strong> 
        </div> 
       </article> 
       <div style="clear: both"> 
       </div> 
       <div style="clear: both"></div> 
      </aside> 
      <h2>9 迭代器和生成器</h2> 
      <p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" rel="nofollow">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p> 
      <p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" rel="nofollow">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p> 
      <h2>10 <code>*args</code> and <code>**kwargs</code> </h2> 
      <p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p> 
      <p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt; def print_everything(*args):
        for count, thing in enumerate(args):
...         print '{0}. {1}'.format(count, thing)
...
&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage</code></pre> 
      <p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt; def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print '{0} = {1}'.format(name, value)
...
&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit</code></pre> 
      <p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p> 
      <p></p>
      <pre><code class="lang-auto">def table_things(titlestring, **kwargs)</code></pre> 
      <p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p> 
      <p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt; def print_three_things(a, b, c):
...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)
...
&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']
&gt;&gt;&gt; print_three_things(*mylist)

a = aardvark, b = baboon, c = cat</code></pre> 
      <p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p> 
      <aside class="onebox stackexchange"> 
       <header class="source"> 
        <a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" rel="nofollow"> stackoverflow.com </a> 
       </header> 
       <article class="onebox-body"> 
        <a href="http://stackoverflow.com/users/337247/macpython" target="_blank" rel="nofollow"> <img alt="MacPython" src="https://www.gravatar.com/avatar/a9376981e3b5d2d0b5b4509704674e99?s=128&amp;d=identicon&amp;r=PG" class="thumbnail" width="" height="" /> </a> 
        <h4> <a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="nofollow">*args and **kwargs?</a> </h4> 
        <div class="date">
          asked by 
         <a href="http://stackoverflow.com/users/337247/macpython" target="_blank" rel="nofollow"> MacPython </a> on 
         <a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="nofollow">08:28AM - 03 Aug 10</a> 
        </div> 
        <div> 
         <strong>python, args, kwargs</strong> 
        </div> 
       </article> 
       <div style="clear: both"> 
       </div> 
       <div style="clear: both"></div> 
      </aside> 
      <h2>11 面向切面编程AOP和装饰器</h2> 
      <p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了...</p> 
      <p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p> 
      <p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" rel="nofollow">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p> 
      <p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" rel="nofollow">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p> 
      <h2>12 鸭子类型</h2> 
      <p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p> 
      <p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p> 
      <p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</p> 
      <p>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</p> 
      <p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p> 
      <h2>13 Python中重载</h2> 
      <p>引自知乎:http://www.zhihu.com/question/20053359</p> 
      <p>函数重载主要是为了解决两个问题。</p> 
      <ol> 
       <li>可变参数类型。</li> 
       <li>可变参数个数。</li> 
      </ol> 
      <p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p> 
      <p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p> 
      <p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p> 
      <p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p> 
      <h2>14 新式类和旧式类</h2> 
      <p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p> 
      <p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python" rel="nofollow">stackoverflow</a></p> 
      <p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" rel="nofollow">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p> 
      <p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),里讲的也很多.</p> 
      <h2>15 <code>__new__</code>和<code>__init__</code>的区别</h2> 
      <p>这个<code>__new__</code>确实很少见到,先做了解吧.</p> 
      <ol> 
       <li> <code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li> 
       <li> <code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li> 
       <li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li> 
       <li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li> 
      </ol> 
      <p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init" rel="nofollow">stackoverflow</a></p> 
      <p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p> 
      <h2>16 单例模式</h2> 
      <p>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</p> 
      <h3>1 使用<code>__new__</code>方法</h3> 
      <p></p>
      <pre><code class="lang-python">class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1</code></pre> 
      <h3>2 共享属性</h3> 
      <p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p> 
      <p></p>
      <pre><code class="lang-python">class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1</code></pre> 
      <h3>3 装饰器版本</h3> 
      <p></p>
      <pre><code class="lang-python">def singleton(cls, *args, **kw):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...</code></pre> 
      <h3>4 import方法</h3> 
      <p>作为python的模块是天然的单例模式</p> 
      <p></p>
      <pre><code class="lang-python"># mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()

# to use
from mysingleton import my_singleton

my_singleton.foo()</code></pre> 
      <h2>17 Python中的作用域</h2> 
      <p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p> 
      <p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p> 
      <p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p> 
      <h2>18 GIL线程全局锁</h2> 
      <p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.</p> 
      <p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem" rel="nofollow">Python 最难的问题</a></p> 
      <p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p> 
      <h2>19 协程</h2> 
      <p>知乎被问到了,呵呵哒,跪了</p> 
      <p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p> 
      <p>Python里最常见的yield就是协程的思想!可以查看第九个问题.</p> 
      <h2>20 闭包</h2> 
      <p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p> 
      <p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p> 
      <ol> 
       <li>必须有一个内嵌函数</li> 
       <li>内嵌函数必须引用外部函数中的变量</li> 
       <li>外部函数的返回值必须是内嵌函数</li> 
      </ol> 
      <p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p> 
      <p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.</p> 
      <p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p> 
      <h2>21 lambda函数</h2> 
      <p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p> 
      <p>推荐: <a href="http://www.zhihu.com/question/20125256" rel="nofollow">知乎</a></p> 
      <h2>22 Python函数式编程</h2> 
      <p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p> 
      <p>推荐: <a href="http://coolshell.cn/articles/10822.html" rel="nofollow">酷壳</a></p> 
      <p>python中函数式编程支持:</p> 
      <p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt;a = [1,2,3,4,5,6,7]
&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)
&gt;&gt;&gt;print b
&gt;&gt;&gt;[6,7]</code></pre> 
      <p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])
&gt;&gt;&gt; list(a)
[2, 4, 6]</code></pre> 
      <p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p> 
      <p></p>
      <pre><code class="lang-python">&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))
6</code></pre> 
      <h2>23 Python里的拷贝</h2> 
      <p>引用和copy(),deepcopy()的区别</p> 
      <p></p>
      <pre><code class="lang-python">import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象

print 'a = ', a
print 'b = ', b
print 'c = ', c
print 'd = ', d

输出结果：
a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
c =  [1, 2, 3, 4, ['a', 'b', 'c']]
d =  [1, 2, 3, 4, ['a', 'b']]</code></pre> 
      <h2>24 Python垃圾回收机制</h2> 
      <p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p> 
      <h3>1 引用计数</h3> 
      <p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p> 
      <p>优点:</p> 
      <ol> 
       <li>简单</li> 
       <li>实时性</li> 
      </ol> 
      <p>缺点:</p> 
      <ol> 
       <li>维护引用计数消耗资源</li> 
       <li>循环引用</li> 
      </ol> 
      <h3>2 标记-清除机制</h3> 
      <p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p> 
      <h3>3 分代技术</h3> 
      <p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p> 
      <p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p> 
      <p>举例：<br />当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p> 
      <h2>25 Python的List</h2> 
      <p>推荐: <a href="http://www.jianshu.com/p/J4U6rR" rel="nofollow">http://www.jianshu.com/p/J4U6rR</a></p> 
      <h2>26 Python的is</h2> 
      <p>is是对比地址,==是对比值</p> 
      <h2>27 read,readline和readlines</h2> 
      <ul> 
       <li>read 读取整个文件</li> 
       <li>readline 读取下一行,使用生成器方法</li> 
       <li>readlines 读取整个文件到一个迭代器以供我们遍历</li> 
      </ul> 
      <h2>28 Python2和3的区别</h2> 
      <p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" rel="nofollow">Python 2.7.x 与 Python 3.x 的主要差异</a></p> 
      <h1>操作系统</h1> 
      <h2>1 select,poll和epoll</h2> 
      <p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.</p> 
      <p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.</p> 
      <p><a href="http://www.cnblogs.com/Anker/p/3265058.html" rel="nofollow">selec,poll和epoll区别总结</a></p> 
      <p>基本上select有3个缺点:</p> 
      <ol> 
       <li>连接数受限</li> 
       <li>查找配对速度慢</li> 
       <li>数据由内核拷贝到用户态</li> 
      </ol> 
      <p>poll改善了第一个缺点</p> 
      <p>epoll改了三个缺点.</p> 
      <p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" rel="nofollow">http://www.cnblogs.com/my_life/articles/3968782.html</a></p> 
      <h2>2 调度算法</h2> 
      <ol> 
       <li>先来先服务(FCFS, First Come First Serve)</li> 
       <li>短作业优先(SJF, Shortest Job First)</li> 
       <li>最高优先权调度(Priority Scheduling)</li> 
       <li>时间片轮转(RR, Round Robin)</li> 
       <li>多级反馈队列调度(multilevel feedback queue scheduling)</li> 
      </ol> 
      <p>实时调度算法:</p> 
      <ol> 
       <li>最早截至时间优先 EDF</li> 
       <li>最低松弛度优先 LLF</li> 
      </ol> 
      <h2>3 死锁</h2> 
      <p>原因:</p> 
      <ol> 
       <li>竞争资源</li> 
       <li>程序推进顺序不当</li> 
      </ol> 
      <p>必要条件:</p> 
      <ol> 
       <li>互斥条件</li> 
       <li>请求和保持条件</li> 
       <li>不剥夺条件</li> 
       <li>环路等待条件</li> 
      </ol> 
      <p>处理死锁基本方法:</p> 
      <ol> 
       <li>预防死锁(摒弃除1以外的条件)</li> 
       <li>避免死锁(银行家算法)</li> 
       <li>检测死锁(资源分配图)</li> 
       <li>解除死锁
        <ol> 
         <li>剥夺资源</li> 
         <li>撤销进程</li> 
        </ol> </li> 
      </ol> 
      <h2>4 程序编译与链接</h2> 
      <p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" rel="nofollow">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p> 
      <p>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</p> 
      <p>以c语言为例:</p> 
      <h3>1 预处理</h3> 
      <p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</p> 
      <ol> 
       <li>将所有的“#define”删除，并展开所用的宏定义</li> 
       <li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li> 
       <li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li> 
       <li>删除所有注释</li> 
       <li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li> 
       <li>保留所有的#pragma编译器指令。</li> 
      </ol> 
      <h3>2 编译</h3> 
      <p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。</p> 
      <h3>3 汇编</h3> 
      <p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)</p> 
      <h3>4 链接</h3> 
      <p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br />链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p> 
      <h2>5 静态链接和动态链接</h2> 
      <p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br />静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p> 
      <p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</p> 
      <h2>6 虚拟内存技术</h2> 
      <p>虚拟存储器是值具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.</p> 
      <h2>7 分页和分段</h2> 
      <p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p> 
      <p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p> 
      <h3>分页与分段的主要区别</h3> 
      <ol> 
       <li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li> 
       <li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li> 
       <li>分页的作业地址空间是一维的.分段的地址空间是二维的.</li> 
      </ol> 
      <h2>8 页面置换算法</h2> 
      <ol> 
       <li>最佳置换算法OPT:不可能实现</li> 
       <li>先进先出FIFO</li> 
       <li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li> 
       <li>clock算法</li> 
      </ol> 
      <h2>9 边沿触发和水平触发</h2> 
      <p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</p> 
      <h1>数据库</h1> 
      <h2>1 事务</h2> 
      <p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p> 
      <h2>2 数据库索引</h2> 
      <p>推荐: <a href="http://tech.meituan.com/mysql-index.html" rel="nofollow">http://tech.meituan.com/mysql-index.html</a></p> 
      <p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" rel="nofollow">MySQL索引背后的数据结构及算法原理</a></p> 
      <p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p> 
      <h2>3 Redis原理</h2> 
      <h2>4 乐观锁和悲观锁</h2> 
      <p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p> 
      <p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p> 
      <h2>5 MVCC</h2> 
      <h2>6 MyISAM和InnoDB</h2> 
      <p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p> 
      <p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p> 
      <h1>网络</h1> 
      <h2>1 三次握手</h2> 
      <ol> 
       <li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。</li> 
       <li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li> 
       <li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li> 
      </ol> 
      <h2>2 四次挥手</h2> 
      <h2>3 ARP协议</h2> 
      <p>地址解析协议(Address Resolution Protocol): 根据IP地址获取物理地址的一个TCP/IP协议</p> 
      <h2>4 urllib和urllib2的区别</h2> 
      <p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p> 
      <ol> 
       <li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li> 
       <li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li> 
      </ol> 
      <h2>5 Post和Get</h2> 
      <p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" rel="nofollow">GET和POST有什么区别？及为什么网上的多数答案都是错的</a></p> 
      <p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" rel="nofollow">RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1</a><br />post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" rel="nofollow">RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1</a></p> 
      <h2>6 Cookie和Session</h2> 
      <p>||Cookie|Session|<br />|:--|:--|:--|<br />|储存位置|客户端|服务器端|<br />|目的|跟踪会话，也可以保存用户偏好设置或者保存用户名密码等|跟踪会话|<br />|安全性|不安全|安全|</p> 
      <p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p> 
      <h2>7 apache和nginx的区别</h2> 
      <p>nginx 相对 apache 的优点：<br />* 轻量级，同样起web 服务，比apache 占用更少的内存及资源<br />* 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能<br />* 配置简洁<br />* 高度模块化的设计，编写模块相对简单<br />* 社区活跃</p> 
      <p>apache 相对nginx 的优点：<br />* rewrite ，比nginx 的rewrite 强大<br />* 模块超多，基本想到的都可以找到<br />* 少bug ，nginx 的bug 相对较多<br />* 超稳定</p> 
      <h2>8 网站用户密码保存</h2> 
      <ol> 
       <li>明文保存</li> 
       <li>明文hash后保存,如md5</li> 
       <li>MD5+Salt方式,这个salt可以随机</li> 
       <li>知乎使用了Bcrypy(好像)加密</li> 
      </ol> 
      <h2>9 HTTP和HTTPS</h2> 
      <p>|状态码|定义|<br />|:--|:--|<br />|1xx 报告|接收到请求，继续进程|<br />|2xx 成功|步骤成功接收，被理解，并被接受|<br />|3xx 重定向|为了完成请求,必须采取进一步措施|<br />|4xx 客户端出错|请求包括错的顺序或不能完成|<br />|5xx 服务器出错|服务器无法完成显然有效的请求|</p> 
      <p>403: Forbidden<br />404: Not Found</p> 
      <p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p> 
      <h2>10 XSRF和XSS</h2> 
      <ul> 
       <li>CSRF(Cross-site request forgery)跨站请求伪造</li> 
       <li>XSS(Cross Site Scripting)跨站脚本攻击</li> 
      </ul> 
      <p>CSRF重点在请求,XSS重点在脚本</p> 
      <h2>11 幂等 Idempotence</h2> 
      <p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的**副作用**。(注意是副作用)</p> 
      <p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p> 
      <p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p> 
      <p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p> 
      <p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p> 
      <h2>12 RESTful架构(SOAP,RPC)</h2> 
      <p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" rel="nofollow">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p> 
      <h2>13 SOAP</h2> 
      <p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p> 
      <h2>14 RPC</h2> 
      <p>RPC（Remote Procedure Call Protocol）――远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p> 
      <p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.</p> 
      <p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p> 
      <h2>15 CGI和WSGI</h2> 
      <p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br />CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p> 
      <p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p> 
      <p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" rel="nofollow">PEP-3333</a></p> 
      <h2>16 中间人攻击</h2> 
      <p>在GFW里屡见不鲜的,呵呵.</p> 
      <p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p> 
      <h2>17 c10k问题</h2> 
      <p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br />推荐: <a href="http://www.kegel.com/c10k.html" rel="nofollow">http://www.kegel.com/c10k.html</a></p> 
      <h2>18 socket</h2> 
      <p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" rel="nofollow">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p> 
      <p>Socket=Ip address+ TCP/UDP + port</p> 
      <h2>19 浏览器缓存</h2> 
      <p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" rel="nofollow">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p> 
      <p>304 Not Modified</p> 
      <h2>20 HTTP1.0和HTTP1.1</h2> 
      <p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" rel="nofollow">http://blog.csdn.net/elifefly/article/details/3964766</a></p> 
      <ol> 
       <li>请求头Host字段,一个服务器多个网站</li> 
       <li>长链接</li> 
       <li>文件断点续传</li> 
       <li>身份认证,状态管理,Cache缓存</li> 
      </ol> 
      <h2>21 Ajax</h2> 
      <p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p> 
      <h1>*NIX</h1> 
      <h2>unix进程间通信方式(IPC)</h2> 
      <ol> 
       <li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li> 
       <li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li> 
       <li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li> 
       <li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li> 
       <li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li> 
       <li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li> 
       <li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li> 
       <li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li> 
      </ol> 
      <h1>数据结构</h1> 
      <h2>1 红黑树</h2> 
      <p>红黑树与AVL的比较：</p> 
      <p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p> 
      <p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；</p> 
      <p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p> 
      <h1>编程题</h1> 
      <h2>1 台阶问题/斐波纳挈</h2> 
      <p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p> 
      <p></p>
      <pre><code class="lang-python">fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2)</code></pre> 
      <p>第二种记忆方法</p> 
      <p></p>
      <pre><code class="lang-python">def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap


@memo
def fib(i):
    if i &lt; 2:
        return 1
    return fib(i-1) + fib(i-2)</code></pre> 
      <p>第三种方法</p> 
      <p></p>
      <pre><code class="lang-python">def fib(n):
    a, b = 0, 1
    for _ in xrange(n):
        a, b = b, a + b
    return b</code></pre> 
      <h2>2 变态台阶问题</h2> 
      <p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p> 
      <p></p>
      <pre><code class="lang-python">fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1)</code></pre> 
      <h2>3 矩形覆盖</h2> 
      <p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p> 
      <blockquote>
       <p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p>
      </blockquote> 
      <p></p>
      <pre><code class="lang-python">f = lambda n: 1 if n &lt; 2 else f(n - 1) + f(n - 2)</code></pre> 
      <h2>4 杨氏矩阵查找</h2> 
      <p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p> 
      <h2>5 去除列表中的重复元素</h2> 
      <p>用集合</p> 
      <p></p>
      <pre><code class="lang-python">list(set(l))</code></pre> 
      <p>用字典</p> 
      <p></p>
      <pre><code class="lang-python">l1 = ['b','c','d','b','c','a','a']
l2 = {}.fromkeys(l1).keys()
print l2</code></pre> 
      <p>用字典并保持顺序</p> 
      <p></p>
      <pre><code class="lang-python">l1 = ['b','c','d','b','c','a','a']
l2 = list(set(l1))
l2.sort(key=l1.index)
print l2</code></pre> 
      <p>列表推导式</p> 
      <p></p>
      <pre><code class="lang-python">l1 = ['b','c','d','b','c','a','a']
l2 = []
[l2.append(i) for i in l1 if not i in l2]</code></pre> 
      <p>面试官提到的,先排序然后删除.</p> 
      <h2>6 链表成对调换</h2> 
      <p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p> 
      <p></p>
      <pre><code class="lang-python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    # @param a ListNode
    # @return a ListNode
    def swapPairs(self, head):
        if head != None and head.next != None:
            next = head.next
            head.next = self.swapPairs(next.next)
            next.next = head
            return next
        return head</code></pre> 
      <h2>7 创建字典的方法</h2> 
      <h3>1 直接创建</h3> 
      <p></p>
      <pre><code class="lang-python">dict = {'name':'earth', 'port':'80'}</code></pre> 
      <h3>2 工厂方法</h3> 
      <p></p>
      <pre><code class="lang-python">items=[('name','earth'),('port','80')]
dict2=dict(items)
dict1=dict((['name','earth'],['port','80']))</code></pre> 
      <h3>3 fromkeys()方法</h3> 
      <p></p>
      <pre><code class="lang-python">dict1={}.fromkeys(('x','y'),-1)
dict={'x':-1,'y':-1}
dict2={}.fromkeys(('x','y'))
dict2={'x':None, 'y':None}</code></pre> 
      <h2>8 合并两个有序列表</h2> 
      <p>知乎远程面试要求编程</p> 
      <p>尾递归</p> 
      <p></p>
      <pre><code class="lang-python">def _recursion_merge_sort2(l1, l2, tmp):
    if len(l1) == 0 or len(l2) == 0:
        tmp.extend(l1)
        tmp.extend(l2)
        return tmp
    else:
        if l1[0] &lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
        return _recursion_merge_sort2(l1, l2, tmp)

def recursion_merge_sort2(l1, l2):
    return _recursion_merge_sort2(l1, l2, [])</code></pre> 
      <p>循环算法</p> 
      <p></p>
      <pre><code class="lang-auto">def loop_merge_sort(l1, l2):
    tmp = []
    while len(l1) &gt; 0 and len(l2) &gt; 0:
        if l1[0] &lt; l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    tmp.extend(l1)
    tmp.extend(l2)
    return tmp</code></pre> 
      <h2>9 交叉链表求交点</h2> 
      <p>去哪儿的面试,没做出来.</p> 
      <p></p>
      <pre><code class="lang-python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
def node(l1, l2):
    length1, lenth2 = 0, 0
    # 求两个链表长度
    while l1.next:
        l1 = l1.next
        length1 += 1
    while l2.next:
        l2 = l2.next
        length2 += 1
    # 长的链表先走
    if length1 &gt; lenth2:
        for _ in range(length1 - length2):
            l1 = l1.next
    else:
        for _ in range(length2 - length1):
            l2 = l2.next
    while l1 and l2:
        if l1.next == l2.next:
            return l1.next
        else:
            l1 = l1.next
            l2 = l2.next</code></pre> 
      <h2>10 二分查找</h2> 
      <p></p>
      <pre><code class="lang-python">def binarySearch(l, t):
    low, high = 0, len(l) - 1
    while low &lt; high:
        print low, high
        mid = (low + high) / 2
        if l[mid] &gt; t:
            high = mid
        elif l[mid] &lt; t:
            low = mid + 1
        else:
            return mid
    return low if l[low] == t else False

if __name__ == '__main__':
    l = [1, 4, 12, 45, 66, 99, 120, 444]
    print binarySearch(l, 12)
    print binarySearch(l, 1)
    print binarySearch(l, 13)
    print binarySearch(l, 444)</code></pre> 
      <h2>11 快排</h2> 
      <p></p>
      <pre><code class="lang-python">def qsort(seq):
    if seq==[]:
        return []
    else:
        pivot=seq[0]
        lesser=qsort([x for x in seq[1:] if x&lt;pivot])
        greater=qsort([x for x in seq[1:] if x&gt;=pivot])
        return lesser+[pivot]+greater

if __name__=='__main__':
    seq=[5,6,78,9,0,-1,2,3,-65,12]
    print(qsort(seq))</code></pre> 
      <h2>12 找零问题</h2> 
      <p></p>
      <pre><code class="lang-python">def  coinChange(values, money, coinsUsed):
    #values    T[1:n]数组
    #valuesCounts   钱币对应的种类数
    #money  找出来的总钱数
    #coinsUsed   对应于目前钱币总数i所使用的硬币数目
    for cents in range(1, money+1):
        minCoins = cents     #从第一个开始到money的所有情况初始
        for value in values:
            if value &lt;= cents:
                temp = coinsUsed[cents - value] + 1
                if temp &lt; minCoins:
                    minCoins = temp
        coinsUsed[cents] = minCoins
        print('面值为：{0} 的最小硬币数目为：{1} '.format(cents, coinsUsed[cents]) )

if __name__ == '__main__':
    values = [ 25, 21, 10, 5, 1]
    money = 63
    coinsUsed = {i:0 for i in range(money+1)}
    coinChange(values, money, coinsUsed)</code></pre> 
      <h2>13 广度遍历和深度遍历二叉树</h2> 
      <p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p> 
      <p></p>
      <pre><code class="lang-python">## 14 二叉树节点
class Node(object):
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right

tree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))

## 15 层次遍历
def lookup(root):
    stack = [root]
    while stack:
        current = stack.pop(0)
        print current.data
        if current.left:
            stack.append(current.left)
        if current.right:
            stack.append(current.right)
## 16 深度遍历
def deep(root):
    if not root:
        return
    print root.data
    deep(root.left)
    deep(root.right)

if __name__ == '__main__':
    lookup(tree)
    deep(tree)</code></pre> 
      <h2>17 前中后序遍历</h2> 
      <p>深度遍历改变顺序就OK了</p> 
      <h2>18 求最大树深</h2> 
      <p></p>
      <pre><code class="lang-python">def maxDepth(root):
        if not root:
            return 0
        return max(maxDepth(root.left), maxDepth(root.right)) + 1</code></pre> 
      <h2>19 求两棵树是否相同</h2> 
      <p></p>
      <pre><code class="lang-python">def isSameTree(p, q):
    if p == None and q == None:
        return True
    elif p and q :
        return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)
    else :
        return False</code></pre> 
      <h2>20 前序中序求后序</h2> 
      <p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502" rel="nofollow">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p> 
      <p></p>
      <pre><code class="lang-python">def rebuild(pre, center):
    if not pre:
        return
    cur = Node(pre[0])
    index = center.index(pre[0])
    cur.left = rebuild(pre[1:index + 1], center[:index])
    cur.right = rebuild(pre[index + 1:], center[index + 1:])
    return cur

def deep(root):
    if not root:
        return
    deep(root.left)
    deep(root.right)
    print root.data</code></pre> 
      <h2>21 单链表逆置</h2> 
      <p></p>
      <pre><code class="lang-python">class Node(object):
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

link = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))

def rev(link):
    pre = link
    cur = link.next
    pre.next = None
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    return pre

root = rev(link)
while root:
    print root.data
    root = root.next</code></pre> 
      <p>原文：https://raw.githubusercontent.com/taizilongxu/interview_python/master/Readme.md</p> 
     </div> 
     <meta itemprop="interactionCount" content="UserLikes:2" /> 
     <meta itemprop="interactionCount" content="UserComments:0" /> 
     <hr /> 
    </div> 
    <!-- :preload-content --> 
    <footer> 
     <nav itemscope="" itemtype="http://schema.org/SiteNavigationElement"> 
      <a href="/">主页</a> 
      <a href="/categories">分类</a> 
      <a href="/guidelines">FAQ/指引</a> 
      <a href="/tos">服务条款</a> 
      <a href="/privacy">隐私政策</a> 
     </nav> 
    </footer> 
   </div> 
   <footer id="noscript-footer"> 
    <p>采用 <a href="http://www.discourse.org">Discourse</a>，启用 JavaScript 以获得最佳效果</p> 
   </footer> 
  </noscript> 
  <section id="main"> 
  </section> 
  <div id="offscreen-content"> 
  </div> 
  <form id="hidden-login-form" method="post" action="/login" style="display: none;"> 
   <input name="username" type="text" id="signin_username" /> 
   <input name="password" type="password" id="signin_password" /> 
   <input name="redirect" type="hidden" /> 
   <input type="submit" id="signin-button" value="登录" /> 
  </form> 
  <script>
        PreloadStore.store("site",{"default_archetype":"regular","notification_types":{"mentioned":1,"replied":2,"quoted":3,"edited":4,"liked":5,"private_message":6,"invited_to_private_message":7,"invitee_accepted":8,"posted":9,"moved_post":10,"linked":11,"granted_badge":12,"invited_to_topic":13,"custom":14,"group_mentioned":15,"group_message_summary":16},"post_types":{"regular":1,"moderator_action":2,"small_action":3,"whisper":4},"groups":[{"id":1,"name":"admins"},{"id":0,"name":"everyone"},{"id":2,"name":"moderators"},{"id":3,"name":"staff"},{"id":10,"name":"trust_level_0"},{"id":11,"name":"trust_level_1"},{"id":12,"name":"trust_level_2"},{"id":13,"name":"trust_level_3"},{"id":14,"name":"trust_level_4"},{"id":41,"name":"WeUseCaffe"}],"filters":["latest","unread","new","read","posted","bookmarks"],"periods":["all","yearly","quarterly","monthly","weekly","daily"],"top_menu_items":["latest","unread","new","read","posted","bookmarks","category","categories","top"],"anonymous_top_menu_items":["latest","top","categories","category","categories","top"],"uncategorized_category_id":1,"is_readonly":false,"disabled_plugins":[],"user_field_max_length":2048,"suppressed_from_homepage_category_ids":[18,24,26],"post_action_types":[{"name_key":"bookmark","name":"书签","description":"给本帖加书签","long_form":"已给本帖加上书签","is_flag":false,"icon":null,"id":1,"is_custom_flag":false},{"name_key":"like","name":"赞","description":"赞本帖","long_form":"赞本帖内容","is_flag":false,"icon":"heart","id":2,"is_custom_flag":false},{"name_key":"off_topic","name":"题外话","description":"此帖与该主题标题和第一帖而言所讨论的主题无关，可能需要被移动。","long_form":"标记为题外话","is_flag":true,"icon":null,"id":3,"is_custom_flag":false},{"name_key":"inappropriate","name":"不当内容","description":"此帖内容包含对他人的攻击、侮辱、仇视语言或违反了<a href=\"/guidelines\">我们的社群准则<\/a>。","long_form":"标记为不当内容","is_flag":true,"icon":null,"id":4,"is_custom_flag":false},{"name_key":"vote","name":"投票","description":"给本帖投票","long_form":"已给本帖投票","is_flag":false,"icon":null,"id":5,"is_custom_flag":false},{"name_key":"spam","name":"垃圾","description":"此帖为广告。它不包含任何对当前讨论有帮助的内容，只有促销信息。","long_form":"标记为垃圾","is_flag":true,"icon":null,"id":8,"is_custom_flag":false},{"name_key":"notify_user","name":"给@{{username}}发送一条消息","description":"我想与此人私下交流他们的帖子。","long_form":"以发送消息给用户","is_flag":true,"icon":null,"id":6,"is_custom_flag":true},{"name_key":"notify_moderators","name":"其他事项","description":"这个帖子需要版主的注意，原因没有列在上方。","long_form":"标记为需版主注意","is_flag":true,"icon":null,"id":7,"is_custom_flag":true}],"topic_flag_types":[{"name_key":"inappropriate","name":"不当内容","description":"此主题内容包含对他人的攻击、侮辱、仇视语言或违反了<a href=\"/guidelines\">我们的社群准则<\/a>。","long_form":"标记为不当内容","is_flag":true,"icon":null,"id":4,"is_custom_flag":false},{"name_key":"spam","name":"垃圾","description":"这个主题是广告。它对本站点没有联系和帮助，仅仅是推销信息。","long_form":"标记为垃圾","is_flag":true,"icon":null,"id":8,"is_custom_flag":false},{"name_key":"notify_moderators","name":"其他内容","description":"此帖需要版主依据<a href=\"/guidelines\">社群准则<\/a>、<a href=\"/tos\">服务条款（TOS）<\/a>或其它未列出的原因来给予关注。","long_form":"标记为需版主注意","is_flag":true,"icon":null,"id":7,"is_custom_flag":true}],"can_create_tag":null,"can_tag_topics":null,"tags_filter_regexp":"[<\\\\/\\>\\#\\?\\&\\s]","categories":[{"id":1,"name":"其他","color":"AB9364","text_color":"FFFFFF","slug":"qi-ta","topic_count":1,"post_count":1,"position":0,"description":"不需要分类或者不适合放在现在的任何分类中的主题。","description_text":"","topic_url":"/t//","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":6,"name":"算法","color":"12A89D","text_color":"FFFFFF","slug":"suan-fa","topic_count":24,"post_count":45,"position":1,"description":"关于算法的讨论区。","description_text":"关于算法的讨论区。","topic_url":"/t/guan-yu-fen-lei-suan-fa/12","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":5,"name":"机器学习","color":"3AB54A","text_color":"FFFFFF","slug":"ji-qi-xue-xi","topic_count":113,"post_count":182,"position":2,"description":"机器学习讨论区。","description_text":"机器学习讨论区。","topic_url":"/t/guan-yu-fen-lei-ji-qi-xue-xi/11","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":true},{"id":8,"name":"工程开发","color":"F1592A","text_color":"FFFFFF","slug":"gong-cheng-kai-fa","topic_count":40,"post_count":73,"position":3,"description":"开发、代码、编程、工程实现相关讨论","description_text":"开发、代码、编程、工程实现相关讨论","topic_url":"/t/guan-yu-fen-lei-gong-cheng-he-dai-ma/16","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":12,"name":"面试","color":"25AAE2","text_color":"FFFFFF","slug":"mian-shi","topic_count":14,"post_count":34,"position":4,"description":"面试题，面试经验","description_text":"面试题，面试经验","topic_url":"/t/guan-yu-fen-lei-mian-shi/96","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":13,"name":"工作招聘","color":"9EB83B","text_color":"FFFFFF","slug":"gong-zuo-zhao-pin","topic_count":9,"post_count":10,"position":5,"description":"招聘职位信息，工作相关讨论","description_text":"招聘职位信息，工作相关讨论","topic_url":"/t/guan-yu-fen-lei-gong-zuo-zhao-pin/234","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":9,"name":"创业","color":"F7941D","text_color":"FFFFFF","slug":"chuang-ye","topic_count":3,"post_count":3,"position":6,"description":null,"description_text":null,"topic_url":"/t/guan-yu-fen-lei-chuang-ye/21","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":17,"name":"领域应用","color":"B3B5B4","text_color":"FFFFFF","slug":"application","topic_count":1,"post_count":1,"position":7,"description":null,"description_text":null,"topic_url":"/t/guan-yu-fen-lei-ling-yu-ying-yong/462","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":true},{"id":10,"name":"程序化交易","color":"ED207B","text_color":"FFFFFF","slug":"cheng-xu-hua-jiao-yi","topic_count":4,"post_count":5,"position":8,"description":"程序化交易，自动化交易，量化投资，交易策略和算法讨论。","description_text":"程序化交易，自动化交易，量化投资，交易策略和算法讨论。","topic_url":"/t/guan-yu-fen-lei-cheng-xu-hua-jiao-yi/27","logo_url":"","background_url":"","read_restricted":false,"permission":null,"parent_category_id":17,"notification_level":1,"topic_template":null,"has_children":false},{"id":7,"name":"Deep Learning","color":"0E76BD","text_color":"FFFFFF","slug":"deep-learning","topic_count":38,"post_count":76,"position":11,"description":"深度学习（Deep Learning）。","description_text":"深度学习（Deep Learning）。","topic_url":"/t/guan-yu-fen-lei-deep-learning/13","logo_url":null,"background_url":null,"read_restricted":false,"permission":null,"parent_category_id":5,"notification_level":1,"topic_template":null,"has_children":false},{"id":11,"name":"幽默","color":"3366aa","text_color":"FFFFFF","slug":"joke","topic_count":10,"post_count":20,"position":12,"description":"幽默笑话。程序员的笑点。","description_text":"幽默笑话。程序员的笑点。","topic_url":"/t/guan-yu-fen-lei-you-mo-xiao-hua/30","logo_url":"","background_url":"","read_restricted":false,"permission":null,"parent_category_id":15,"notification_level":1,"topic_template":null,"has_children":false},{"id":16,"name":"有图","color":"DD2C4C","text_color":"FFFFFF","slug":"mm","topic_count":1,"post_count":4,"position":13,"description":"有图有真相，“多看美女能长寿”。","description_text":"有图有真相，“多看美女能长寿”。","topic_url":"/t/guan-yu-fen-lei-mei-ren-mei-jing/456","logo_url":"","background_url":"","read_restricted":false,"permission":null,"parent_category_id":15,"notification_level":1,"topic_template":null,"has_children":false},{"id":3,"name":"社区建设","color":"808281","text_color":"FFFFFF","slug":"she-qu-jian-she","topic_count":6,"post_count":10,"position":14,"description":"关于本算法组社区建设的反馈、建议和讨论。","description_text":"关于本算法组社区建设的反馈、建议和讨论。","topic_url":"/t/about-the-meta-category/2","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":14,"name":"博客","color":"008B45","text_color":"FFFFFF","slug":"blog","topic_count":2,"post_count":2,"position":15,"description":"你的个人博客文章。如果你想发布/记录个人的博客文章，可以放到此分类。此分类的类容，不会显示到首页上。","description_text":"你的个人博客文章。如果你想发布/记录个人的博客文章，可以放到此分类。此分类的类容，不会显示到首页上。","topic_url":"/t/guan-yu-fen-lei-bo-ke/451","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":15,"name":"有趣","color":"1E90FF","text_color":"FFFFFF","slug":"fun","topic_count":0,"post_count":1,"position":16,"description":"我们总有些无聊着的时候：程序在编译，文件在上传，车还没来，…，不要无聊着，来这里看看段子图片…","description_text":"我们总有些无聊着的时候：程序在编译，文件在上传，车还没来，…，不要无聊着，来这里看看段子图片…","topic_url":"/t/guan-yu-fen-lei-bu-xu-wu-liao/454","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":true},{"id":18,"name":"精选","color":"231F20","text_color":"FFFFFF","slug":"z","topic_count":12139,"post_count":35631,"position":17,"description":"精选文章，来自本站或者外站。","description_text":"精选文章，来自本站或者外站。","topic_url":"/t/topic/734","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":"","has_children":false},{"id":22,"name":"Caffe","color":"C30000","text_color":"FFFFFF","slug":"caffe","topic_count":15,"post_count":55,"position":18,"description":"Caffe 机器学习中文社区","description_text":"Caffe 机器学习中文社区","topic_url":"/t/caffe/12323","logo_url":null,"background_url":null,"read_restricted":false,"permission":null,"parent_category_id":5,"notification_level":1,"topic_template":null,"has_children":false},{"id":23,"name":"MXNet","color":"2980B9","text_color":"FFFFFF","slug":"mxnet","topic_count":7,"post_count":9,"position":19,"description":null,"description_text":null,"topic_url":"/t/mxnet/12324","logo_url":null,"background_url":null,"read_restricted":false,"permission":null,"parent_category_id":5,"notification_level":1,"topic_template":null,"has_children":false},{"id":24,"name":"头条","color":"BF1E2E","text_color":"FFFFFF","slug":"toutiao","topic_count":14,"post_count":15,"position":20,"description":"你必须关注的文章：技术、业界、创业等等","description_text":"你必须关注的文章：技术、业界、创业等等","topic_url":"/t/topic/12808","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":"","has_children":false},{"id":25,"name":"TensorFlow","color":"92278F","text_color":"FFFFFF","slug":"tensorflow","topic_count":7,"post_count":8,"position":21,"description":"关于TensorFlow的讨论和分享等一切。","description_text":"关于TensorFlow的讨论和分享等一切。","topic_url":"/t/tensorflow/13214","logo_url":null,"background_url":null,"read_restricted":false,"permission":null,"parent_category_id":5,"notification_level":1,"topic_template":null,"has_children":false},{"id":26,"name":"教程","color":"652D90","text_color":"FFFFFF","slug":"tutorial","topic_count":12,"post_count":12,"position":22,"description":"快速学习教程，在线入门到高级教程","description_text":"快速学习教程，在线入门到高级教程","topic_url":"/t/topic/13398","logo_url":"","background_url":"","read_restricted":false,"permission":null,"notification_level":1,"topic_template":"","has_children":true},{"id":27,"name":"算法竞赛","color":"8C6238","text_color":"FFFFFF","slug":"contests","topic_count":4,"post_count":14,"position":23,"description":null,"description_text":null,"topic_url":"/t/topic/13456","logo_url":null,"background_url":null,"read_restricted":false,"permission":null,"notification_level":1,"topic_template":null,"has_children":false},{"id":28,"name":"教程系列","color":"99cccc","text_color":"FFFFFF","slug":"tutorial-list","topic_count":4,"post_count":4,"position":24,"description":"在这个分类里存放教程目录，便于查询","description_text":"在这个分类里存放教程目录，便于查询","topic_url":"/t/topic/13469","logo_url":"","background_url":"","read_restricted":false,"permission":null,"parent_category_id":26,"notification_level":1,"topic_template":"","has_children":false}],"trust_levels":[{"id":0,"name":"新用户"},{"id":1,"name":"初级用户"},{"id":2,"name":"成员"},{"id":3,"name":"活跃用户"},{"id":4,"name":"资深"}],"archetypes":[{"id":"regular","name":"常规主题","options":[]},{"id":"banner","name":"横幅主题","options":[]}],"user_fields":[]});
        PreloadStore.store("siteSettings",{"title":"算法组","contact_email":"suanfazu@suanfazu.com","contact_url":"","logo_url":"","logo_small_url":"","mobile_logo_url":"","favicon_url":"http://s1.suanfazu.com/favicon.ico","allow_user_locale":false,"suggested_topics":10,"track_external_right_clicks":false,"ga_universal_tracking_code":"","ga_universal_domain_name":"auto","ga_tracking_code":"","ga_domain_name":"","top_menu":"latest|new|unread|top|categories|category/头条","post_menu":"like-count|like|share|flag|edit|bookmark|delete|admin|reply","post_menu_hidden_items":"bookmark|edit|delete|admin","share_links":"weibo|wechat|renren|twitter|facebook|google+|email","category_colors":"BF1E2E|F1592A|F7941D|9EB83B|3AB54A|12A89D|25AAE2|0E76BD|652D90|92278F|ED207B|8C6238|231F20|808281|B3B5B4|283890","category_style":"bullet","enable_mobile_theme":true,"relative_date_duration":30,"category_featured_topics":3,"fixed_category_positions":true,"fixed_category_positions_on_create":false,"show_subcategory_list":false,"enable_badges":true,"enable_whispers":false,"invite_only":false,"login_required":false,"must_approve_users":false,"enable_local_logins":true,"allow_new_registrations":true,"enable_signup_cta":true,"enable_google_oauth2_logins":true,"enable_yahoo_logins":false,"enable_twitter_logins":false,"enable_instagram_logins":false,"enable_facebook_logins":false,"enable_github_logins":true,"enable_sso":false,"sso_overrides_avatar":false,"min_username_length":3,"max_username_length":20,"min_password_length":6,"min_admin_password_length":15,"logout_redirect":"","full_name_required":false,"enable_names":true,"invites_per_page":40,"delete_user_max_post_age":60,"delete_all_posts_max":15,"show_email_on_profile":false,"enable_user_directory":true,"allow_anonymous_posting":false,"anonymous_posting_min_trust_level":1,"hide_user_profiles_from_public":false,"min_post_length":7,"min_first_post_length":10,"min_private_message_post_length":5,"max_post_length":232000,"min_topic_title_length":4,"max_topic_title_length":255,"min_private_message_title_length":2,"allow_uncategorized_topics":false,"min_title_similar_length":10,"min_body_similar_length":15,"enable_private_messages":true,"edit_history_visible_to_public":false,"delete_removed_posts_after":24,"traditional_markdown_linebreaks":false,"allow_html_tables":false,"suppress_reply_directly_below":true,"suppress_reply_directly_above":true,"max_reply_history":1,"newuser_max_images":1,"newuser_max_attachments":0,"display_name_on_posts":false,"show_time_gap_days":7,"short_progress_text_threshold":10000,"default_code_lang":"auto","autohighlight_all_code":false,"highlighted_languages":"apache|bash|cs|cpp|css|coffeescript|diff|xml|http|ini|json|java|javascript|makefile|markdown|nginx|objectivec|ruby|perl|php|python|sql|handlebars","censored_words":"","enable_emoji":true,"emoji_set":"emoji_one","email_time_window_mins":10,"disable_digest_emails":false,"email_in":false,"disable_emails":false,"max_image_size_kb":10240,"max_attachment_size_kb":10240,"authorized_extensions":"jpg|jpeg|png|gif|pdf|zip|pptx|txt","max_image_width":690,"max_image_height":5000,"prevent_anons_from_downloading_files":true,"enable_s3_uploads":false,"allow_profile_backgrounds":true,"allow_uploaded_avatars":true,"allow_animated_avatars":false,"default_avatars":"","external_system_avatars_enabled":true,"external_system_avatars_url":"/letter_avatar_proxy/v2/letter/{first_letter}/{color}/{size}.png","tl1_requires_read_posts":2,"tl3_links_no_follow":false,"use_admin_ip_whitelist":false,"alert_admins_if_errors_per_minute":0,"alert_admins_if_errors_per_hour":0,"enable_long_polling":true,"long_polling_base_url":"/","background_polling_interval":60000,"polling_interval":3000,"anon_polling_interval":15000,"flush_timings_secs":20,"verbose_localization":false,"max_new_topics":500,"tos_url":"","privacy_policy_url":"","faq_url":"","maximum_backups":5,"version_checks":true,"suppress_uncategorized_badge":true,"min_search_term_length":1,"topic_views_heat_low":1000,"topic_views_heat_medium":2000,"topic_views_heat_high":5000,"topic_post_like_heat_low":0.5,"topic_post_like_heat_medium":1.0,"topic_post_like_heat_high":2.0,"history_hours_low":12,"history_hours_medium":24,"history_hours_high":48,"cold_age_days_low":14,"cold_age_days_medium":90,"cold_age_days_high":180,"global_notice":"","show_create_topics_notice":true,"automatically_unpin_topics":true,"read_time_word_count":500,"disable_mailing_list_mode":false,"default_topics_automatic_unpin":true,"poll_enabled":true,"poll_maximum_options":100,"tagging_enabled":true,"max_tags_per_topic":5,"max_tag_length":20,"min_trust_level_to_tag_topics":0,"max_tag_search_results":5,"show_filter_by_tag":false,"tags_sort_alphabetically":false,"staff_tags":"","suppress_overlapping_tags_in_list":false,"details_enabled":true,"enable_mathjax_plugin":true,"mathjax_url":"//cdn.bootcss.com/mathjax/2.6.1/MathJax.js","mathjax_config":"TeX-AMS-MML_HTMLorMML","available_locales":"ar|bs_BA|cs|da|de|en|es|fa_IR|fi|fr|gl|he|id|it|ja|ko|nb_NO|nl|pl_PL|pt|pt_BR|ro|ru|sk|sq|sv|te|tr_TR|uk|vi|zh_CN|zh_TW","tag_style":"simple"});
        PreloadStore.store("customHTML",{"top":"\n","footer":"\n"});
        PreloadStore.store("banner",{});
        PreloadStore.store("customEmoji",[]);
        PreloadStore.store("translationOverrides",{});
        PreloadStore.store("topic_13524",{"post_stream":{"posts":[{"id":36585,"name":"pythoner","username":"pythoner","avatar_template":"/letter_avatar_proxy/v2/letter/p/b2d939/{size}.png","created_at":"2016-05-22T03:18:04.951Z","cooked":"<h1>Python语言特性<\/h1>\n\n<h2>1 Python的函数参数传递<\/h2>\n\n<p>看两个例子:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">a = 1\ndef fun(a):\n    a = 2\nfun(a)\nprint a  # 1<\/code><\/pre>\n\n<p><\/p><pre><code class=\"lang-python\">a = []\ndef fun(a):\n    a.append(1)\nfun(a)\nprint a  # [1]<\/code><\/pre>\n\n<p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。<\/p>\n\n<p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。(这就是这个问题的重点)<\/p>\n\n<p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.<\/p>\n\n<p>如果还不明白的话,这里有更好的解释: <a href=\"http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference\" rel=\"nofollow\">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference<\/a><\/p>\n\n<h2>2 Python中的元类(metaclass)<\/h2>\n\n<p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python<\/p>\n\n<h2>3 <span class=\"mention\">@staticmethod<\/span>和<span class=\"mention\">@classmethod<\/span>\n<\/h2>\n\n<p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">def foo(x):\n    print \"executing foo(%s)\"%(x)\n\nclass A(object):\n    def foo(self,x):\n        print \"executing foo(%s,%s)\"%(self,x)\n\n    @classmethod\n    def class_foo(cls,x):\n        print \"executing class_foo(%s,%s)\"%(cls,x)\n\n    @staticmethod\n    def static_foo(x):\n        print \"executing static_foo(%s)\"%x\n\na=A()<\/code><\/pre>\n\n<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)<\/code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)<\/code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)<\/code>(其实是<code>foo(a, x)<\/code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)<\/code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.<\/p>\n\n<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)<\/code>或者<code>A.static_foo(x)<\/code>来调用.<\/p>\n\n<p>|\\|实例方法|类方法|静态方法|<br>|:--|:--|:--|:--|<br>|a = A()|a.foo(x)|a.class_foo(x)|a.static_foo(x)|<br>|A|不可用|A.class_foo(x)|A.static_foo(x)|<\/p>\n\n<p>更多关于这个问题:http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python<\/p>\n\n<h2>4 类变量和实例变量<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">class Person:\n    name=\"aaa\"\n\np1=Person()\np2=Person()\np1.name=\"bbb\"\nprint p1.name  # bbb\nprint p2.name  # aaa\nprint Person.name  # aaa<\/code><\/pre>\n\n<p>类变量就是供类使用的变量,实例变量就是供实例使用的.<\/p>\n\n<p>这里<code>p1.name=\"bbb\"<\/code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name<\/code>一开始是指向的类变量<code>name=\"aaa\"<\/code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.<\/p>\n\n<p>可以看看下面的例子:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">class Person:\n    name=[]\n\np1=Person()\np2=Person()\np1.name.append(1)\nprint p1.name  # [1]\nprint p2.name  # [1]\nprint Person.name  # [1]<\/code><\/pre>\n\n<p>参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block<\/p>\n\n<h2>5 Python自省<\/h2>\n\n<p>这个也是python彪悍的特性.<\/p>\n\n<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().<\/p>\n\n<h2>6 字典推导式<\/h2>\n\n<p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">d = {key: value for (key, value) in iterable}<\/code><\/pre>\n\n<h2>7 Python中单下划线和双下划线<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt; class MyClass():\n...     def __init__(self):\n...             self.__superprivate = \"Hello\"\n...             self._semiprivate = \", world!\"\n...\n&gt;&gt;&gt; mc = MyClass()\n&gt;&gt;&gt; print mc.__superprivate\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: myClass instance has no attribute '__superprivate'\n&gt;&gt;&gt; print mc._semiprivate\n, world!\n&gt;&gt;&gt; print mc.__dict__\n{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}<\/code><\/pre>\n\n<p><code>__foo__<\/code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.<\/p>\n\n<p><code>_foo<\/code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.<\/p>\n\n<p><code>__foo<\/code>:这个有真正的意义:解析器用<code>_classname__foo<\/code>来代替这个名字,以区别和其他类相同的命名.<\/p>\n\n<p>详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python<\/p>\n\n<p>或者: <a href=\"http://www.zhihu.com/question/19754941\" rel=\"nofollow\">http://www.zhihu.com/question/19754941<\/a><\/p>\n\n<h2>8 字符串格式化:%和.format<\/h2>\n\n<p>.format在许多方面看起来更便利.对于<code>%<\/code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:<\/p>\n\n<p><\/p><pre><code class=\"lang-auto\">\"hi there %s\" % name<\/code><\/pre>\n\n<p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:<\/p>\n\n<p><\/p><pre><code class=\"lang-auto\">\"hi there %s\" % (name,)   # 提供一个单元素的数组而不是一个参数<\/code><\/pre>\n\n<p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.<\/p>\n\n<p>你为什么不用它?<\/p>\n\n<ul>\n<li>不知道它(在读这个之前)<\/li>\n<li>为了和Python2.5兼容(譬如logging库建议使用<code>%<\/code>(<a href=\"https://github.com/taizilongxu/interview_python/issues/4\" rel=\"nofollow\">issue <span class=\"hashtag\">#4<\/span><\/a>))<\/li>\n<\/ul>\n\n<aside class=\"onebox stackexchange\">\n  <header class=\"source\">\n    <a href=\"http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format\" rel=\"nofollow\">\n      \n      stackoverflow.com\n    <\/a>\n  <\/header>\n  <article class=\"onebox-body\">\n      <a href=\"http://stackoverflow.com/users/231463/northisup\" target=\"_blank\" rel=\"nofollow\">\n    <img alt=\"NorthIsUp\" src=\"https://www.gravatar.com/avatar/887048987be67f10649a9dfacced6606?s=128&amp;d=identicon&amp;r=PG\" class=\"thumbnail\" width=\"\" height=\"\">\n  <\/a>\n<h4>\n  <a href=\"http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format\" target=\"_blank\" rel=\"nofollow\">Python string formatting: % vs. .format<\/a>\n<\/h4>\n\n<div class=\"date\">\n  asked by <a href=\"http://stackoverflow.com/users/231463/northisup\" target=\"_blank\" rel=\"nofollow\">\n    NorthIsUp\n  <\/a>\n  on <a href=\"http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format\" target=\"_blank\" rel=\"nofollow\">06:46PM - 22 Feb 11<\/a>\n<\/div>\n\n<div>\n  <strong>python, performance, logging, string-formatting<\/strong>\n<\/div>\n\n  <\/article>\n  <div style=\"clear: both\">\n    \n    \n  <\/div>\n  <div style=\"clear: both\"><\/div>\n<\/aside>\n\n\n<h2>9 迭代器和生成器<\/h2>\n\n<p>这个是stackoverflow里python排名第一的问题,值得一看: <a href=\"http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python\" rel=\"nofollow\">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python<\/a><\/p>\n\n<p>这是中文版: <a href=\"http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html\" rel=\"nofollow\">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html<\/a><\/p>\n\n<h2>10 <code>*args<\/code> and <code>**kwargs<\/code>\n<\/h2>\n\n<p>用<code>*args<\/code>和<code>**kwargs<\/code>只是为了方便并没有强制使用它们.<\/p>\n\n<p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args<\/code>.例如,它可以传递任意数量的参数:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt; def print_everything(*args):\n        for count, thing in enumerate(args):\n...         print '{0}. {1}'.format(count, thing)\n...\n&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')\n0. apple\n1. banana\n2. cabbage<\/code><\/pre>\n\n<p>相似的,<code>**kwargs<\/code>允许你使用没有事先定义的参数名:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt; def table_things(**kwargs):\n...     for name, value in kwargs.items():\n...         print '{0} = {1}'.format(name, value)\n...\n&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')\ncabbage = vegetable\napple = fruit<\/code><\/pre>\n\n<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args<\/code>和<code>**kwargs<\/code>.命名参数在列表的最前端.例如:<\/p>\n\n<p><\/p><pre><code class=\"lang-auto\">def table_things(titlestring, **kwargs)<\/code><\/pre>\n\n<p><code>*args<\/code>和<code>**kwargs<\/code>可以同时在函数的定义中,但是<code>*args<\/code>必须在<code>**kwargs<\/code>前面.<\/p>\n\n<p>当调用函数时你也可以用<code>*<\/code>和<code>**<\/code>语法.例如:<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt; def print_three_things(a, b, c):\n...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)\n...\n&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']\n&gt;&gt;&gt; print_three_things(*mylist)\n\na = aardvark, b = baboon, c = cat<\/code><\/pre>\n\n<p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.<\/p>\n\n<aside class=\"onebox stackexchange\">\n  <header class=\"source\">\n    <a href=\"http://stackoverflow.com/questions/3394835/args-and-kwargs\" rel=\"nofollow\">\n      \n      stackoverflow.com\n    <\/a>\n  <\/header>\n  <article class=\"onebox-body\">\n      <a href=\"http://stackoverflow.com/users/337247/macpython\" target=\"_blank\" rel=\"nofollow\">\n    <img alt=\"MacPython\" src=\"https://www.gravatar.com/avatar/a9376981e3b5d2d0b5b4509704674e99?s=128&amp;d=identicon&amp;r=PG\" class=\"thumbnail\" width=\"\" height=\"\">\n  <\/a>\n<h4>\n  <a href=\"http://stackoverflow.com/questions/3394835/args-and-kwargs\" target=\"_blank\" rel=\"nofollow\">*args and **kwargs?<\/a>\n<\/h4>\n\n<div class=\"date\">\n  asked by <a href=\"http://stackoverflow.com/users/337247/macpython\" target=\"_blank\" rel=\"nofollow\">\n    MacPython\n  <\/a>\n  on <a href=\"http://stackoverflow.com/questions/3394835/args-and-kwargs\" target=\"_blank\" rel=\"nofollow\">08:28AM - 03 Aug 10<\/a>\n<\/div>\n\n<div>\n  <strong>python, args, kwargs<\/strong>\n<\/div>\n\n  <\/article>\n  <div style=\"clear: both\">\n    \n    \n  <\/div>\n  <div style=\"clear: both\"><\/div>\n<\/aside>\n\n\n<h2>11 面向切面编程AOP和装饰器<\/h2>\n\n<p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了...<\/p>\n\n<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。<\/strong><\/p>\n\n<p>这个问题比较大,推荐: <a href=\"http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python\" rel=\"nofollow\">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python<\/a><\/p>\n\n<p>中文: <a href=\"http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html\" rel=\"nofollow\">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html<\/a><\/p>\n\n<h2>12 鸭子类型<\/h2>\n\n<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”<\/p>\n\n<p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。<\/p>\n\n<p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。<\/p>\n\n<p>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.<\/p>\n\n<p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。<\/p>\n\n<h2>13 Python中重载<\/h2>\n\n<p>引自知乎:http://www.zhihu.com/question/20053359<\/p>\n\n<p>函数重载主要是为了解决两个问题。<\/p>\n\n<ol>\n<li>可变参数类型。<\/li>\n<li>可变参数个数。<\/li>\n<\/ol>\n\n<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。<\/p>\n\n<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。<\/p>\n\n<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。<\/p>\n\n<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。<\/p>\n\n<h2>14 新式类和旧式类<\/h2>\n\n<p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.<\/p>\n\n<p><a href=\"http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python\" rel=\"nofollow\">stackoverflow<\/a><\/p>\n\n<p>这篇文章很好的介绍了新式类的特性: <a href=\"http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html\" rel=\"nofollow\">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html<\/a><\/p>\n\n<p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),里讲的也很多.<\/p>\n\n<h2>15 <code>__new__<\/code>和<code>__init__<\/code>的区别<\/h2>\n\n<p>这个<code>__new__<\/code>确实很少见到,先做了解吧.<\/p>\n\n<ol>\n<li>\n<code>__new__<\/code>是一个静态方法,而<code>__init__<\/code>是一个实例方法.<\/li>\n<li>\n<code>__new__<\/code>方法会返回一个创建的实例,而<code>__init__<\/code>什么都不返回.<\/li>\n<li>只有在<code>__new__<\/code>返回一个cls的实例时后面的<code>__init__<\/code>才能被调用.<\/li>\n<li>当创建一个新实例时调用<code>__new__<\/code>,初始化一个实例时用<code>__init__<\/code>.<\/li>\n<\/ol>\n\n<p><a href=\"http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init\" rel=\"nofollow\">stackoverflow<\/a><\/p>\n\n<p>ps: <code>__metaclass__<\/code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__<\/code>,<code>__new__<\/code>和<code>__init__<\/code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.<\/p>\n\n<h2>16 单例模式<\/h2>\n\n<p>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.<\/p>\n\n<h3>1 使用<code>__new__<\/code>方法<\/h3>\n\n<p><\/p><pre><code class=\"lang-python\">class Singleton(object):\n    def __new__(cls, *args, **kw):\n        if not hasattr(cls, '_instance'):\n            orig = super(Singleton, cls)\n            cls._instance = orig.__new__(cls, *args, **kw)\n        return cls._instance\n\nclass MyClass(Singleton):\n    a = 1<\/code><\/pre>\n\n<h3>2 共享属性<\/h3>\n\n<p>创建实例时把所有实例的<code>__dict__<\/code>指向同一个字典,这样它们具有相同的属性和方法.<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">class Borg(object):\n    _state = {}\n    def __new__(cls, *args, **kw):\n        ob = super(Borg, cls).__new__(cls, *args, **kw)\n        ob.__dict__ = cls._state\n        return ob\n\nclass MyClass2(Borg):\n    a = 1<\/code><\/pre>\n\n<h3>3 装饰器版本<\/h3>\n\n<p><\/p><pre><code class=\"lang-python\">def singleton(cls, *args, **kw):\n    instances = {}\n    def getinstance():\n        if cls not in instances:\n            instances[cls] = cls(*args, **kw)\n        return instances[cls]\n    return getinstance\n\n@singleton\nclass MyClass:\n  ...<\/code><\/pre>\n\n<h3>4 import方法<\/h3>\n\n<p>作为python的模块是天然的单例模式<\/p>\n\n<p><\/p><pre><code class=\"lang-python\"># mysingleton.py\nclass My_Singleton(object):\n    def foo(self):\n        pass\n\nmy_singleton = My_Singleton()\n\n# to use\nfrom mysingleton import my_singleton\n\nmy_singleton.foo()<\/code><\/pre>\n\n<h2>17 Python中的作用域<\/h2>\n\n<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。<\/p>\n\n<p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：<\/p>\n\n<p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）<\/p>\n\n<h2>18 GIL线程全局锁<\/h2>\n\n<p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.<\/p>\n\n<p>见<a href=\"http://www.oschina.net/translate/pythons-hardest-problem\" rel=\"nofollow\">Python 最难的问题<\/a><\/p>\n\n<p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).<\/p>\n\n<h2>19 协程<\/h2>\n\n<p>知乎被问到了,呵呵哒,跪了<\/p>\n\n<p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.<\/p>\n\n<p>Python里最常见的yield就是协程的思想!可以查看第九个问题.<\/p>\n\n<h2>20 闭包<\/h2>\n\n<p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。<\/p>\n\n<p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:<\/p>\n\n<ol>\n<li>必须有一个内嵌函数<\/li>\n<li>内嵌函数必须引用外部函数中的变量<\/li>\n<li>外部函数的返回值必须是内嵌函数<\/li>\n<\/ol>\n\n<p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.<\/p>\n\n<p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.<\/p>\n\n<p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.<\/p>\n\n<h2>21 lambda函数<\/h2>\n\n<p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.<\/p>\n\n<p>推荐: <a href=\"http://www.zhihu.com/question/20125256\" rel=\"nofollow\">知乎<\/a><\/p>\n\n<h2>22 Python函数式编程<\/h2>\n\n<p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.<\/p>\n\n<p>推荐: <a href=\"http://coolshell.cn/articles/10822.html\" rel=\"nofollow\">酷壳<\/a><\/p>\n\n<p>python中函数式编程支持:<\/p>\n\n<p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func<\/code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq<\/code>返回值为true的元素的序列。<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt;a = [1,2,3,4,5,6,7]\n&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)\n&gt;&gt;&gt;print b\n&gt;&gt;&gt;[6,7]<\/code><\/pre>\n\n<p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])\n&gt;&gt;&gt; list(a)\n[2, 4, 6]<\/code><\/pre>\n\n<p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))\n6<\/code><\/pre>\n\n<h2>23 Python里的拷贝<\/h2>\n\n<p>引用和copy(),deepcopy()的区别<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">import copy\na = [1, 2, 3, 4, ['a', 'b']]  #原始对象\n\nb = a  #赋值，传对象的引用\nc = copy.copy(a)  #对象拷贝，浅拷贝\nd = copy.deepcopy(a)  #对象拷贝，深拷贝\n\na.append(5)  #修改对象a\na[4].append('c')  #修改对象a中的['a', 'b']数组对象\n\nprint 'a = ', a\nprint 'b = ', b\nprint 'c = ', c\nprint 'd = ', d\n\n输出结果：\na =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\nb =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\nc =  [1, 2, 3, 4, ['a', 'b', 'c']]\nd =  [1, 2, 3, 4, ['a', 'b']]<\/code><\/pre>\n\n<h2>24 Python垃圾回收机制<\/h2>\n\n<p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。<\/p>\n\n<h3>1 引用计数<\/h3>\n\n<p>PyObject是每个对象必有的内容，其中<code>ob_refcnt<\/code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt<\/code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt<\/code>就会减少.引用计数为0时，该对象生命就结束了。<\/p>\n\n<p>优点:<\/p>\n\n<ol>\n<li>简单<\/li>\n<li>实时性<\/li>\n<\/ol>\n\n<p>缺点:<\/p>\n\n<ol>\n<li>维护引用计数消耗资源<\/li>\n<li>循环引用<\/li>\n<\/ol>\n\n<h3>2 标记-清除机制<\/h3>\n\n<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。<\/p>\n\n<h3>3 分代技术<\/h3>\n\n<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。<\/p>\n\n<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。<\/p>\n\n<p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。<\/p>\n\n<h2>25 Python的List<\/h2>\n\n<p>推荐: <a href=\"http://www.jianshu.com/p/J4U6rR\" rel=\"nofollow\">http://www.jianshu.com/p/J4U6rR<\/a><\/p>\n\n<h2>26 Python的is<\/h2>\n\n<p>is是对比地址,==是对比值<\/p>\n\n<h2>27 read,readline和readlines<\/h2>\n\n<ul>\n<li>read        读取整个文件<\/li>\n<li>readline    读取下一行,使用生成器方法<\/li>\n<li>readlines   读取整个文件到一个迭代器以供我们遍历<\/li>\n<\/ul>\n\n<h2>28 Python2和3的区别<\/h2>\n\n<p>推荐：<a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/\" rel=\"nofollow\">Python 2.7.x 与 Python 3.x 的主要差异<\/a><\/p>\n\n<h1>操作系统<\/h1>\n\n<h2>1 select,poll和epoll<\/h2>\n\n<p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.<\/p>\n\n<p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.<\/p>\n\n<p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\" rel=\"nofollow\">selec,poll和epoll区别总结<\/a><\/p>\n\n<p>基本上select有3个缺点:<\/p>\n\n<ol>\n<li>连接数受限<\/li>\n<li>查找配对速度慢<\/li>\n<li>数据由内核拷贝到用户态<\/li>\n<\/ol>\n\n<p>poll改善了第一个缺点<\/p>\n\n<p>epoll改了三个缺点.<\/p>\n\n<p>关于epoll的: <a href=\"http://www.cnblogs.com/my_life/articles/3968782.html\" rel=\"nofollow\">http://www.cnblogs.com/my_life/articles/3968782.html<\/a><\/p>\n\n<h2>2 调度算法<\/h2>\n\n<ol>\n<li>先来先服务(FCFS, First Come First Serve)<\/li>\n<li>短作业优先(SJF, Shortest Job First)<\/li>\n<li>最高优先权调度(Priority Scheduling)<\/li>\n<li>时间片轮转(RR, Round Robin)<\/li>\n<li>多级反馈队列调度(multilevel feedback queue scheduling)<\/li>\n<\/ol>\n\n<p>实时调度算法:<\/p>\n\n<ol>\n<li>最早截至时间优先 EDF<\/li>\n<li>最低松弛度优先 LLF<\/li>\n<\/ol>\n\n<h2>3 死锁<\/h2>\n\n<p>原因:<\/p>\n\n<ol>\n<li>竞争资源<\/li>\n<li>程序推进顺序不当<\/li>\n<\/ol>\n\n<p>必要条件:<\/p>\n\n<ol>\n<li>互斥条件<\/li>\n<li>请求和保持条件<\/li>\n<li>不剥夺条件<\/li>\n<li>环路等待条件<\/li>\n<\/ol>\n\n<p>处理死锁基本方法:<\/p>\n\n<ol>\n<li>预防死锁(摒弃除1以外的条件)<\/li>\n<li>避免死锁(银行家算法)<\/li>\n<li>检测死锁(资源分配图)<\/li>\n<li>解除死锁<ol>\n<li>剥夺资源<\/li>\n<li>撤销进程<\/li>\n<\/ol>\n<\/li>\n<\/ol>\n\n<h2>4 程序编译与链接<\/h2>\n\n<p>推荐: <a href=\"http://www.ruanyifeng.com/blog/2014/11/compiler.html\" rel=\"nofollow\">http://www.ruanyifeng.com/blog/2014/11/compiler.html<\/a><\/p>\n\n<p>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)<\/p>\n\n<p>以c语言为例:<\/p>\n\n<h3>1 预处理<\/h3>\n\n<p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：<\/p>\n\n<ol>\n<li>将所有的“#define”删除，并展开所用的宏定义<\/li>\n<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”<\/li>\n<li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的<\/li>\n<li>删除所有注释<\/li>\n<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号<\/li>\n<li>保留所有的#pragma编译器指令。<\/li>\n<\/ol>\n\n<h3>2 编译<\/h3>\n\n<p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。<\/p>\n\n<h3>3 汇编<\/h3>\n\n<p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)<\/p>\n\n<h3>4 链接<\/h3>\n\n<p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。<\/p>\n\n<h2>5 静态链接和动态链接<\/h2>\n\n<p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库<\/p>\n\n<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序<\/p>\n\n<h2>6 虚拟内存技术<\/h2>\n\n<p>虚拟存储器是值具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.<\/p>\n\n<h2>7 分页和分段<\/h2>\n\n<p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。<\/p>\n\n<p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。<\/p>\n\n<h3>分页与分段的主要区别<\/h3>\n\n<ol>\n<li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.<\/li>\n<li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.<\/li>\n<li>分页的作业地址空间是一维的.分段的地址空间是二维的.<\/li>\n<\/ol>\n\n<h2>8 页面置换算法<\/h2>\n\n<ol>\n<li>最佳置换算法OPT:不可能实现<\/li>\n<li>先进先出FIFO<\/li>\n<li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.<\/li>\n<li>clock算法<\/li>\n<\/ol>\n\n<h2>9 边沿触发和水平触发<\/h2>\n\n<p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件<\/p>\n\n<h1>数据库<\/h1>\n\n<h2>1 事务<\/h2>\n\n<p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<\/p>\n\n<h2>2 数据库索引<\/h2>\n\n<p>推荐: <a href=\"http://tech.meituan.com/mysql-index.html\" rel=\"nofollow\">http://tech.meituan.com/mysql-index.html<\/a><\/p>\n\n<p><a href=\"http://blog.codinglabs.org/articles/theory-of-mysql-index.html\" rel=\"nofollow\">MySQL索引背后的数据结构及算法原理<\/a><\/p>\n\n<p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理<\/p>\n\n<h2>3 Redis原理<\/h2>\n\n<h2>4 乐观锁和悲观锁<\/h2>\n\n<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<\/p>\n\n<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<\/p>\n\n<h2>5 MVCC<\/h2>\n\n<h2>6 MyISAM和InnoDB<\/h2>\n\n<p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。<\/p>\n\n<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。<\/p>\n\n<h1>网络<\/h1>\n\n<h2>1 三次握手<\/h2>\n\n<ol>\n<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。<\/li>\n<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。<\/li>\n<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。<\/li>\n<\/ol>\n\n<h2>2 四次挥手<\/h2>\n\n<h2>3 ARP协议<\/h2>\n\n<p>地址解析协议(Address Resolution Protocol): 根据IP地址获取物理地址的一个TCP/IP协议<\/p>\n\n<h2>4 urllib和urllib2的区别<\/h2>\n\n<p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.<\/p>\n\n<ol>\n<li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。<\/li>\n<li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。<\/li>\n<\/ol>\n\n<h2>5 Post和Get<\/h2>\n\n<p><a href=\"http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html\" rel=\"nofollow\">GET和POST有什么区别？及为什么网上的多数答案都是错的<\/a><\/p>\n\n<p>get: <a href=\"http://tools.ietf.org/html/rfc2616#section-9.3\" rel=\"nofollow\">RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1<\/a><br>post: <a href=\"http://tools.ietf.org/html/rfc2616#section-9.5\" rel=\"nofollow\">RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1<\/a><\/p>\n\n<h2>6 Cookie和Session<\/h2>\n\n<p>||Cookie|Session|<br>|:--|:--|:--|<br>|储存位置|客户端|服务器端|<br>|目的|跟踪会话，也可以保存用户偏好设置或者保存用户名密码等|跟踪会话|<br>|安全性|不安全|安全|<\/p>\n\n<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。<\/p>\n\n<h2>7 apache和nginx的区别<\/h2>\n\n<p>nginx 相对 apache 的优点：<br>* 轻量级，同样起web 服务，比apache 占用更少的内存及资源<br>* 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能<br>* 配置简洁<br>* 高度模块化的设计，编写模块相对简单<br>* 社区活跃<\/p>\n\n<p>apache 相对nginx 的优点：<br>* rewrite ，比nginx 的rewrite 强大<br>* 模块超多，基本想到的都可以找到<br>* 少bug ，nginx 的bug 相对较多<br>* 超稳定<\/p>\n\n<h2>8 网站用户密码保存<\/h2>\n\n<ol>\n<li>明文保存<\/li>\n<li>明文hash后保存,如md5<\/li>\n<li>MD5+Salt方式,这个salt可以随机<\/li>\n<li>知乎使用了Bcrypy(好像)加密<\/li>\n<\/ol>\n\n<h2>9 HTTP和HTTPS<\/h2>\n\n<p>|状态码|定义|<br>|:--|:--|<br>|1xx 报告|接收到请求，继续进程|<br>|2xx 成功|步骤成功接收，被理解，并被接受|<br>|3xx 重定向|为了完成请求,必须采取进一步措施|<br>|4xx 客户端出错|请求包括错的顺序或不能完成|<br>|5xx 服务器出错|服务器无法完成显然有效的请求|<\/p>\n\n<p>403: Forbidden<br>404: Not Found<\/p>\n\n<p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA<\/p>\n\n<h2>10 XSRF和XSS<\/h2>\n\n<ul>\n<li>CSRF(Cross-site request forgery)跨站请求伪造<\/li>\n<li>XSS(Cross Site Scripting)跨站脚本攻击<\/li>\n<\/ul>\n\n<p>CSRF重点在请求,XSS重点在脚本<\/p>\n\n<h2>11 幂等 Idempotence<\/h2>\n\n<p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的**副作用**。(注意是副作用)<\/p>\n\n<p><code>GET http://www.bank.com/account/123456<\/code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news<\/code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。<\/p>\n\n<p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231<\/code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。<\/p>\n\n<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles<\/code>的语义是在<code>http://www.forum.com/articles<\/code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。<\/p>\n\n<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231<\/code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。<\/p>\n\n<h2>12 RESTful架构(SOAP,RPC)<\/h2>\n\n<p>推荐: <a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" rel=\"nofollow\">http://www.ruanyifeng.com/blog/2011/09/restful.html<\/a><\/p>\n\n<h2>13 SOAP<\/h2>\n\n<p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。<\/p>\n\n<h2>14 RPC<\/h2>\n\n<p>RPC（Remote Procedure Call Protocol）――远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<\/p>\n\n<p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.<\/p>\n\n<p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful<\/p>\n\n<h2>15 CGI和WSGI<\/h2>\n\n<p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。<\/p>\n\n<p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。<\/p>\n\n<p>官方说明：<a href=\"https://www.python.org/dev/peps/pep-3333/\" rel=\"nofollow\">PEP-3333<\/a><\/p>\n\n<h2>16 中间人攻击<\/h2>\n\n<p>在GFW里屡见不鲜的,呵呵.<\/p>\n\n<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。<\/p>\n\n<h2>17 c10k问题<\/h2>\n\n<p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐: <a href=\"http://www.kegel.com/c10k.html\" rel=\"nofollow\">http://www.kegel.com/c10k.html<\/a><\/p>\n\n<h2>18 socket<\/h2>\n\n<p>推荐: <a href=\"http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml\" rel=\"nofollow\">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml<\/a><\/p>\n\n<p>Socket=Ip address+ TCP/UDP + port<\/p>\n\n<h2>19 浏览器缓存<\/h2>\n\n<p>推荐: <a href=\"http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html\" rel=\"nofollow\">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html<\/a><\/p>\n\n<p>304 Not Modified<\/p>\n\n<h2>20 HTTP1.0和HTTP1.1<\/h2>\n\n<p>推荐: <a href=\"http://blog.csdn.net/elifefly/article/details/3964766\" rel=\"nofollow\">http://blog.csdn.net/elifefly/article/details/3964766<\/a><\/p>\n\n<ol>\n<li>请求头Host字段,一个服务器多个网站<\/li>\n<li>长链接<\/li>\n<li>文件断点续传<\/li>\n<li>身份认证,状态管理,Cache缓存<\/li>\n<\/ol>\n\n<h2>21 Ajax<\/h2>\n\n<p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。<\/p>\n\n<h1>*NIX<\/h1>\n\n<h2>unix进程间通信方式(IPC)<\/h2>\n\n<ol>\n<li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。<\/li>\n<li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。<\/li>\n<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。<\/li>\n<li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺<\/li>\n<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。<\/li>\n<li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。<\/li>\n<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。<\/li>\n<li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。<\/li>\n<\/ol>\n\n<h1>数据结构<\/h1>\n\n<h2>1 红黑树<\/h2>\n\n<p>红黑树与AVL的比较：<\/p>\n\n<p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；<\/p>\n\n<p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；<\/p>\n\n<p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。<\/p>\n\n<h1>编程题<\/h1>\n\n<h2>1 台阶问题/斐波纳挈<\/h2>\n\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2)<\/code><\/pre>\n\n<p>第二种记忆方法<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">def memo(func):\n    cache = {}\n    def wrap(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrap\n\n\n@memo\ndef fib(i):\n    if i &lt; 2:\n        return 1\n    return fib(i-1) + fib(i-2)<\/code><\/pre>\n\n<p>第三种方法<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">def fib(n):\n    a, b = 0, 1\n    for _ in xrange(n):\n        a, b = b, a + b\n    return b<\/code><\/pre>\n\n<h2>2 变态台阶问题<\/h2>\n\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1)<\/code><\/pre>\n\n<h2>3 矩形覆盖<\/h2>\n\n<p>我们可以用<code>2*1<\/code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1<\/code>的小矩形无重叠地覆盖一个<code>2*n<\/code>的大矩形，总共有多少种方法？<\/p>\n\n<blockquote><p>第<code>2*n<\/code>个矩形的覆盖方法等于第<code>2*(n-1)<\/code>加上第<code>2*(n-2)<\/code>的方法。<\/p><\/blockquote>\n\n<p><\/p><pre><code class=\"lang-python\">f = lambda n: 1 if n &lt; 2 else f(n - 1) + f(n - 2)<\/code><\/pre>\n\n<h2>4 杨氏矩阵查找<\/h2>\n\n<p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<\/p>\n\n<h2>5 去除列表中的重复元素<\/h2>\n\n<p>用集合<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">list(set(l))<\/code><\/pre>\n\n<p>用字典<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">l1 = ['b','c','d','b','c','a','a']\nl2 = {}.fromkeys(l1).keys()\nprint l2<\/code><\/pre>\n\n<p>用字典并保持顺序<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">l1 = ['b','c','d','b','c','a','a']\nl2 = list(set(l1))\nl2.sort(key=l1.index)\nprint l2<\/code><\/pre>\n\n<p>列表推导式<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">l1 = ['b','c','d','b','c','a','a']\nl2 = []\n[l2.append(i) for i in l1 if not i in l2]<\/code><\/pre>\n\n<p>面试官提到的,先排序然后删除.<\/p>\n\n<h2>6 链表成对调换<\/h2>\n\n<p><code>1-&gt;2-&gt;3-&gt;4<\/code>转换成<code>2-&gt;1-&gt;4-&gt;3<\/code>.<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    # @param a ListNode\n    # @return a ListNode\n    def swapPairs(self, head):\n        if head != None and head.next != None:\n            next = head.next\n            head.next = self.swapPairs(next.next)\n            next.next = head\n            return next\n        return head<\/code><\/pre>\n\n<h2>7 创建字典的方法<\/h2>\n\n<h3>1 直接创建<\/h3>\n\n<p><\/p><pre><code class=\"lang-python\">dict = {'name':'earth', 'port':'80'}<\/code><\/pre>\n\n<h3>2 工厂方法<\/h3>\n\n<p><\/p><pre><code class=\"lang-python\">items=[('name','earth'),('port','80')]\ndict2=dict(items)\ndict1=dict((['name','earth'],['port','80']))<\/code><\/pre>\n\n<h3>3 fromkeys()方法<\/h3>\n\n<p><\/p><pre><code class=\"lang-python\">dict1={}.fromkeys(('x','y'),-1)\ndict={'x':-1,'y':-1}\ndict2={}.fromkeys(('x','y'))\ndict2={'x':None, 'y':None}<\/code><\/pre>\n\n<h2>8 合并两个有序列表<\/h2>\n\n<p>知乎远程面试要求编程<\/p>\n\n<p>尾递归<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">def _recursion_merge_sort2(l1, l2, tmp):\n    if len(l1) == 0 or len(l2) == 0:\n        tmp.extend(l1)\n        tmp.extend(l2)\n        return tmp\n    else:\n        if l1[0] &lt; l2[0]:\n            tmp.append(l1[0])\n            del l1[0]\n        else:\n            tmp.append(l2[0])\n            del l2[0]\n        return _recursion_merge_sort2(l1, l2, tmp)\n\ndef recursion_merge_sort2(l1, l2):\n    return _recursion_merge_sort2(l1, l2, [])<\/code><\/pre>\n\n<p>循环算法<\/p>\n\n<p><\/p><pre><code class=\"lang-auto\">def loop_merge_sort(l1, l2):\n    tmp = []\n    while len(l1) &gt; 0 and len(l2) &gt; 0:\n        if l1[0] &lt; l2[0]:\n            tmp.append(l1[0])\n            del l1[0]\n        else:\n            tmp.append(l2[0])\n            del l2[0]\n    tmp.extend(l1)\n    tmp.extend(l2)\n    return tmp<\/code><\/pre>\n\n<h2>9 交叉链表求交点<\/h2>\n\n<p>去哪儿的面试,没做出来.<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\ndef node(l1, l2):\n    length1, lenth2 = 0, 0\n    # 求两个链表长度\n    while l1.next:\n        l1 = l1.next\n        length1 += 1\n    while l2.next:\n        l2 = l2.next\n        length2 += 1\n    # 长的链表先走\n    if length1 &gt; lenth2:\n        for _ in range(length1 - length2):\n            l1 = l1.next\n    else:\n        for _ in range(length2 - length1):\n            l2 = l2.next\n    while l1 and l2:\n        if l1.next == l2.next:\n            return l1.next\n        else:\n            l1 = l1.next\n            l2 = l2.next<\/code><\/pre>\n\n<h2>10 二分查找<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">def binarySearch(l, t):\n    low, high = 0, len(l) - 1\n    while low &lt; high:\n        print low, high\n        mid = (low + high) / 2\n        if l[mid] &gt; t:\n            high = mid\n        elif l[mid] &lt; t:\n            low = mid + 1\n        else:\n            return mid\n    return low if l[low] == t else False\n\nif __name__ == '__main__':\n    l = [1, 4, 12, 45, 66, 99, 120, 444]\n    print binarySearch(l, 12)\n    print binarySearch(l, 1)\n    print binarySearch(l, 13)\n    print binarySearch(l, 444)<\/code><\/pre>\n\n<h2>11 快排<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">def qsort(seq):\n    if seq==[]:\n        return []\n    else:\n        pivot=seq[0]\n        lesser=qsort([x for x in seq[1:] if x&lt;pivot])\n        greater=qsort([x for x in seq[1:] if x&gt;=pivot])\n        return lesser+[pivot]+greater\n\nif __name__=='__main__':\n    seq=[5,6,78,9,0,-1,2,3,-65,12]\n    print(qsort(seq))<\/code><\/pre>\n\n<h2>12 找零问题<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">def  coinChange(values, money, coinsUsed):\n    #values    T[1:n]数组\n    #valuesCounts   钱币对应的种类数\n    #money  找出来的总钱数\n    #coinsUsed   对应于目前钱币总数i所使用的硬币数目\n    for cents in range(1, money+1):\n        minCoins = cents     #从第一个开始到money的所有情况初始\n        for value in values:\n            if value &lt;= cents:\n                temp = coinsUsed[cents - value] + 1\n                if temp &lt; minCoins:\n                    minCoins = temp\n        coinsUsed[cents] = minCoins\n        print('面值为：{0} 的最小硬币数目为：{1} '.format(cents, coinsUsed[cents]) )\n\nif __name__ == '__main__':\n    values = [ 25, 21, 10, 5, 1]\n    money = 63\n    coinsUsed = {i:0 for i in range(money+1)}\n    coinChange(values, money, coinsUsed)<\/code><\/pre>\n\n<h2>13 广度遍历和深度遍历二叉树<\/h2>\n\n<p>给定一个数组，构建二叉树，并且按层次打印这个二叉树<\/p>\n\n<p><\/p><pre><code class=\"lang-python\">## 14 二叉树节点\nclass Node(object):\n    def __init__(self, data, left=None, right=None):\n        self.data = data\n        self.left = left\n        self.right = right\n\ntree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))\n\n## 15 层次遍历\ndef lookup(root):\n    stack = [root]\n    while stack:\n        current = stack.pop(0)\n        print current.data\n        if current.left:\n            stack.append(current.left)\n        if current.right:\n            stack.append(current.right)\n## 16 深度遍历\ndef deep(root):\n    if not root:\n        return\n    print root.data\n    deep(root.left)\n    deep(root.right)\n\nif __name__ == '__main__':\n    lookup(tree)\n    deep(tree)<\/code><\/pre>\n\n<h2>17 前中后序遍历<\/h2>\n\n<p>深度遍历改变顺序就OK了<\/p>\n\n<h2>18 求最大树深<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">def maxDepth(root):\n        if not root:\n            return 0\n        return max(maxDepth(root.left), maxDepth(root.right)) + 1<\/code><\/pre>\n\n<h2>19 求两棵树是否相同<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">def isSameTree(p, q):\n    if p == None and q == None:\n        return True\n    elif p and q :\n        return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)\n    else :\n        return False<\/code><\/pre>\n\n<h2>20 前序中序求后序<\/h2>\n\n<p>推荐: <a href=\"http://blog.csdn.net/hinyunsin/article/details/6315502\" rel=\"nofollow\">http://blog.csdn.net/hinyunsin/article/details/6315502<\/a><\/p>\n\n<p><\/p><pre><code class=\"lang-python\">def rebuild(pre, center):\n    if not pre:\n        return\n    cur = Node(pre[0])\n    index = center.index(pre[0])\n    cur.left = rebuild(pre[1:index + 1], center[:index])\n    cur.right = rebuild(pre[index + 1:], center[index + 1:])\n    return cur\n\ndef deep(root):\n    if not root:\n        return\n    deep(root.left)\n    deep(root.right)\n    print root.data<\/code><\/pre>\n\n<h2>21 单链表逆置<\/h2>\n\n<p><\/p><pre><code class=\"lang-python\">class Node(object):\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n\nlink = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))\n\ndef rev(link):\n    pre = link\n    cur = link.next\n    pre.next = None\n    while cur:\n        tmp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = tmp\n    return pre\n\nroot = rev(link)\nwhile root:\n    print root.data\n    root = root.next<\/code><\/pre>\n\n<p>原文：https://raw.githubusercontent.com/taizilongxu/interview_python/master/Readme.md<\/p>","post_number":1,"post_type":1,"updated_at":"2016-05-22T03:19:25.751Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"avg_time":74,"incoming_link_count":399,"reads":95,"score":2054.5,"yours":false,"topic_id":13524,"topic_slug":"python","display_username":"pythoner","primary_group_name":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html","internal":false,"reflection":false,"title":"Python中关键字yield有什么作用? | Stackoverflow about Python","clicks":31},{"url":"http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference","internal":false,"reflection":false,"title":"python - How do I pass a variable by reference? - Stack Overflow","clicks":28},{"url":"http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html","internal":false,"reflection":false,"title":"Python中如何在一个函数中加入多个装饰器? | Stackoverflow about Python","clicks":13},{"url":"http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python","internal":false,"reflection":false,"title":"iterator - What does the yield keyword do in Python? - Stack Overflow","clicks":12},{"url":"http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html","internal":false,"reflection":false,"title":"python中基于descriptor的一些概念（上） - btchenguang - 博客园","clicks":9},{"url":"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/","internal":false,"reflection":false,"title":"Python 2.7.x 与 Python 3.x 的主要差异 | ShinChan's Blog","clicks":8},{"url":"http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format","internal":false,"reflection":false,"title":"performance - Python string formatting: % vs. .format - Stack Overflow","clicks":8},{"url":"http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html","internal":false,"reflection":false,"title":"GET和POST有什么区别？及为什么网上的多数答案都是错的。 - 南柯之石 - 博客园","clicks":8},{"url":"http://www.oschina.net/translate/pythons-hardest-problem","internal":false,"reflection":false,"clicks":7},{"url":"http://www.jianshu.com/p/J4U6rR","internal":false,"reflection":false,"title":"Python中list的实现 - 简书","clicks":6},{"url":"http://www.zhihu.com/question/19754941","internal":false,"reflection":false,"title":"Python 的类的下划线命名有什么不同？ - Python - 知乎","clicks":6},{"url":"http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python","internal":false,"reflection":false,"title":"How can I make a chain of function decorators in Python? - Stack Overflow","clicks":6},{"url":"http://www.zhihu.com/question/20125256","internal":false,"reflection":false,"title":"Lambda 表达式有何用处？如何使用？ - Python - 知乎","clicks":6},{"url":"http://coolshell.cn/articles/10822.html","internal":false,"reflection":false,"title":"函数式编程 | 酷 壳 - CoolShell.cn","clicks":5},{"url":"http://www.cnblogs.com/Anker/p/3265058.html","internal":false,"reflection":false,"title":"select、poll、epoll之间的区别总结[整理] - Anker's Blog - 博客园","clicks":5},{"url":"http://www.cnblogs.com/my_life/articles/3968782.html","internal":false,"reflection":false,"title":"epoll 水平触发 边沿触发 - bw_0927 - 博客园","clicks":3},{"url":"http://tech.meituan.com/mysql-index.html","internal":false,"reflection":false,"clicks":3},{"url":"http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python","internal":false,"reflection":false,"title":"class - What is the difference between old style and new style classes in Python? - Stack Overflow","clicks":3},{"url":"http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html","internal":false,"reflection":false,"title":"浏览器缓存机制 - 吴秦 - 博客园","clicks":3},{"url":"http://blog.csdn.net/hinyunsin/article/details/6315502","internal":false,"reflection":false,"title":"根据二叉树的前序和中序求后序 - 大道至简，持之以恒\r - 博客频道 - CSDN.NET","clicks":3},{"url":"http://blog.codinglabs.org/articles/theory-of-mysql-index.html","internal":false,"reflection":false,"title":"CodingLabs - MySQL索引背后的数据结构及算法原理","clicks":2},{"url":"http://tools.ietf.org/html/rfc2616#section-9.3","internal":false,"reflection":false,"title":"RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1","clicks":1},{"url":"http://www.ruanyifeng.com/blog/2011/09/restful.html","internal":false,"reflection":false,"title":"理解RESTful架构 - 阮一峰的网络日志","clicks":1},{"url":"http://stackoverflow.com/questions/3394835/args-and-kwargs","internal":false,"reflection":false,"title":"python - *args and **kwargs? - Stack Overflow","clicks":1},{"url":"http://www.kegel.com/c10k.html","internal":false,"reflection":false,"title":"The C10K problem","clicks":1},{"url":"http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml","internal":false,"reflection":false,"title":"揭开Socket编程的面纱","clicks":1},{"url":"http://stackoverflow.com/users/231463/northisup","internal":false,"reflection":false,"title":"User NorthIsUp - Stack Overflow","clicks":1},{"url":"http://tools.ietf.org/html/rfc2616#section-9.5","internal":false,"reflection":false,"title":"RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1","clicks":0},{"url":"http://blog.csdn.net/elifefly/article/details/3964766","internal":false,"reflection":false,"title":"HTTP 1.1与HTTP 1.0的比较 - 李蓝箫\r - 博客频道 - CSDN.NET","clicks":0},{"url":"https://github.com/taizilongxu/interview_python/issues/4","internal":false,"reflection":false,"title":"关于字符串格式化 ・ Issue #4 ・ taizilongxu/interview_python ・ GitHub","clicks":0},{"url":"http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init","internal":false,"reflection":false,"title":"design patterns - Python's use of __new__ and __init__? - Stack Overflow","clicks":0},{"url":"https://www.python.org/dev/peps/pep-3333/","internal":false,"reflection":false,"title":"PEP 3333 -- Python Web Server Gateway Interface v1.0.1 | Python.org","clicks":0},{"url":"http://stackoverflow.com/users/337247/macpython","internal":false,"reflection":false,"title":"User MacPython - Stack Overflow","clicks":0},{"url":"http://www.ruanyifeng.com/blog/2014/11/compiler.html","internal":false,"reflection":false,"title":"编译器的工作过程 - 阮一峰的网络日志","clicks":0}],"read":true,"user_title":null,"actions_summary":[{"id":2,"count":2}],"moderator":false,"admin":false,"staff":false,"user_id":1583,"hidden":false,"hidden_reason_id":null,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":false,"wiki":false}],"stream":[36585]},"id":13524,"title":"很全的Python的面试题","fancy_title":"很全的Python的面试题","posts_count":1,"created_at":"2016-05-22T03:18:03.972Z","views":2162,"reply_count":0,"participant_count":1,"like_count":2,"last_posted_at":"2016-05-22T03:18:04.951Z","visible":true,"closed":false,"archived":false,"has_summary":false,"archetype":"regular","slug":"python","category_id":12,"word_count":3389,"deleted_at":null,"user_id":1583,"draft":null,"draft_key":"topic_13524","draft_sequence":null,"unpinned":null,"pinned_globally":false,"pinned":false,"pinned_at":null,"pinned_until":null,"details":{"auto_close_at":null,"auto_close_hours":null,"auto_close_based_on_last_post":false,"created_by":{"id":1583,"username":"pythoner","avatar_template":"/letter_avatar_proxy/v2/letter/p/b2d939/{size}.png"},"last_poster":{"id":1583,"username":"pythoner","avatar_template":"/letter_avatar_proxy/v2/letter/p/b2d939/{size}.png"},"participants":[{"id":1583,"username":"pythoner","avatar_template":"/letter_avatar_proxy/v2/letter/p/b2d939/{size}.png","post_count":1}],"suggested_topics":[{"id":107,"title":"ip转城市-微软","fancy_title":"ip转城市-微软","slug":"ipzhuan-cheng-shi-wei-ruan","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2014-12-18T03:18:48.599Z","last_posted_at":"2014-12-21T16:37:56.025Z","bumped":true,"bumped_at":"2014-12-21T16:37:56.025Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":0,"views":1383,"category_id":12},{"id":100,"title":"求二叉树的宽度-百度","fancy_title":"求二叉树的宽度-百度","slug":"qiu-er-cha-shu-de-kuan-du-bai-du","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2014-12-18T03:06:41.061Z","last_posted_at":"2014-12-18T03:06:41.294Z","bumped":true,"bumped_at":"2014-12-18T03:06:41.294Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":0,"views":1025,"category_id":12},{"id":99,"title":"用两个栈实现一个队列-百度","fancy_title":"用两个栈实现一个队列-百度","slug":"yong-liang-ge-zhan-shi-xian-ge-dui-lie-bai-du","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2014-12-18T03:04:34.377Z","last_posted_at":"2014-12-21T16:48:54.849Z","bumped":true,"bumped_at":"2014-12-21T16:48:54.849Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":1,"views":1119,"category_id":12},{"id":97,"title":"求二叉树的最大距离-百度","fancy_title":"求二叉树的最大距离-百度","slug":"qiu-er-cha-shu-de-zui-da-ju-chi-bai-du","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2014-12-18T03:03:11.501Z","last_posted_at":"2014-12-18T03:03:11.627Z","bumped":true,"bumped_at":"2014-12-18T03:03:11.627Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":0,"views":934,"category_id":12},{"id":108,"title":"求先递增后递减数组的最大值-美团","fancy_title":"求先递增后递减数组的最大值-美团","slug":"qiu-xian-di-zeng-hou-di-jian-shu-zu-de-zui-da-zhi-mei-tuan","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2014-12-18T03:21:34.814Z","last_posted_at":"2014-12-21T16:40:44.808Z","bumped":true,"bumped_at":"2014-12-21T16:40:44.808Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":1,"views":1631,"category_id":12},{"id":124,"title":"重叠矩阵求面积","fancy_title":"重叠矩阵求面积","slug":"topic","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2014-12-18T15:26:21.616Z","last_posted_at":"2015-07-21T13:19:00.461Z","bumped":true,"bumped_at":"2015-07-21T13:19:00.461Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":0,"views":1869,"category_id":12},{"id":297,"title":"互联网公司机器学习职位面试考察点","fancy_title":"互联网公司机器学习职位面试考察点","slug":"hu-lian-wang-gong-si-ji-qi-xue-xi-zhi-wei-mian-shi-kao-cha-dian","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":"/uploads/default/205/3a9ba0671a47c382.png","created_at":"2015-01-05T05:23:21.639Z","last_posted_at":"2015-01-05T05:23:21.783Z","bumped":true,"bumped_at":"2015-01-05T05:23:21.783Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":1,"views":1465,"category_id":12},{"id":101,"title":"二叉树两个叶子节点间的路径-百度","fancy_title":"二叉树两个叶子节点间的路径-百度","slug":"topic","posts_count":10,"reply_count":6,"highest_post_number":11,"image_url":null,"created_at":"2014-12-18T03:08:43.748Z","last_posted_at":"2016-05-03T09:47:45.683Z","bumped":true,"bumped_at":"2016-05-03T09:47:45.683Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":1,"views":4909,"category_id":12},{"id":14129,"title":"分享一套机器学习的题目和非常详细的解析过程","fancy_title":"分享一套机器学习的题目和非常详细的解析过程","slug":"topic","posts_count":5,"reply_count":3,"highest_post_number":5,"image_url":null,"created_at":"2016-09-08T07:02:53.752Z","last_posted_at":"2016-09-20T06:56:32.630Z","bumped":true,"bumped_at":"2016-09-20T06:56:32.630Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":3,"views":2121,"category_id":12},{"id":2418,"title":"Unable to set up Pybrain LSTM module for Reber Grammar","fancy_title":"Unable to set up Pybrain LSTM module for Reber Grammar","slug":"unable-to-set-up-pybrain-lstm-module-for-reber-grammar","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2015-05-16T20:00:10.881Z","last_posted_at":"2015-05-16T20:00:10.938Z","bumped":true,"bumped_at":"2015-05-16T20:00:10.938Z","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"archetype":"regular","like_count":0,"views":199,"category_id":18}],"links":[{"url":"http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html","title":"Python中关键字yield有什么作用? | Stackoverflow about Python","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":31,"user_id":1583,"domain":"taizilongxu.gitbooks.io"},{"url":"http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference","title":"python - How do I pass a variable by reference? - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":28,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html","title":"Python中如何在一个函数中加入多个装饰器? | Stackoverflow about Python","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":13,"user_id":1583,"domain":"taizilongxu.gitbooks.io"},{"url":"http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python","title":"iterator - What does the yield keyword do in Python? - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":12,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html","title":"python中基于descriptor的一些概念（上） - btchenguang - 博客园","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":9,"user_id":1583,"domain":"www.cnblogs.com"},{"url":"http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format","title":"performance - Python string formatting: % vs. .format - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":8,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html","title":"GET和POST有什么区别？及为什么网上的多数答案都是错的。 - 南柯之石 - 博客园","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":8,"user_id":1583,"domain":"www.cnblogs.com"},{"url":"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/","title":"Python 2.7.x 与 Python 3.x 的主要差异 | ShinChan's Blog","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":8,"user_id":1583,"domain":"chenqx.github.io"},{"url":"http://www.oschina.net/translate/pythons-hardest-problem","title":null,"fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":7,"user_id":1583,"domain":"www.oschina.net"},{"url":"http://www.zhihu.com/question/19754941","title":"Python 的类的下划线命名有什么不同？ - Python - 知乎","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":6,"user_id":1583,"domain":"www.zhihu.com"},{"url":"http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python","title":"How can I make a chain of function decorators in Python? - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":6,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://www.jianshu.com/p/J4U6rR","title":"Python中list的实现 - 简书","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":6,"user_id":1583,"domain":"www.jianshu.com"},{"url":"http://www.zhihu.com/question/20125256","title":"Lambda 表达式有何用处？如何使用？ - Python - 知乎","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":6,"user_id":1583,"domain":"www.zhihu.com"},{"url":"http://www.cnblogs.com/Anker/p/3265058.html","title":"select、poll、epoll之间的区别总结[整理] - Anker's Blog - 博客园","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":5,"user_id":1583,"domain":"www.cnblogs.com"},{"url":"http://coolshell.cn/articles/10822.html","title":"函数式编程 | 酷 壳 - CoolShell.cn","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":5,"user_id":1583,"domain":"coolshell.cn"},{"url":"http://blog.csdn.net/hinyunsin/article/details/6315502","title":"根据二叉树的前序和中序求后序 - 大道至简，持之以恒\r - 博客频道 - CSDN.NET","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":3,"user_id":1583,"domain":"blog.csdn.net"},{"url":"http://tech.meituan.com/mysql-index.html","title":null,"fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":3,"user_id":1583,"domain":"tech.meituan.com"},{"url":"http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html","title":"浏览器缓存机制 - 吴秦 - 博客园","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":3,"user_id":1583,"domain":"www.cnblogs.com"},{"url":"http://www.cnblogs.com/my_life/articles/3968782.html","title":"epoll 水平触发 边沿触发 - bw_0927 - 博客园","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":3,"user_id":1583,"domain":"www.cnblogs.com"},{"url":"http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python","title":"class - What is the difference between old style and new style classes in Python? - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":3,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://blog.codinglabs.org/articles/theory-of-mysql-index.html","title":"CodingLabs - MySQL索引背后的数据结构及算法原理","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":2,"user_id":1583,"domain":"blog.codinglabs.org"},{"url":"http://stackoverflow.com/questions/3394835/args-and-kwargs","title":"python - *args and **kwargs? - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://stackoverflow.com/users/231463/northisup","title":"User NorthIsUp - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml","title":"揭开Socket编程的面纱","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1583,"domain":"www.360doc.com"},{"url":"http://www.kegel.com/c10k.html","title":"The C10K problem","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1583,"domain":"www.kegel.com"},{"url":"http://tools.ietf.org/html/rfc2616#section-9.3","title":"RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1583,"domain":"tools.ietf.org"},{"url":"http://www.ruanyifeng.com/blog/2011/09/restful.html","title":"理解RESTful架构 - 阮一峰的网络日志","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1583,"domain":"www.ruanyifeng.com"},{"url":"http://www.ruanyifeng.com/blog/2014/11/compiler.html","title":"编译器的工作过程 - 阮一峰的网络日志","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"www.ruanyifeng.com"},{"url":"http://blog.csdn.net/elifefly/article/details/3964766","title":"HTTP 1.1与HTTP 1.0的比较 - 李蓝箫\r - 博客频道 - CSDN.NET","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"blog.csdn.net"},{"url":"http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init","title":"design patterns - Python's use of __new__ and __init__? - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"stackoverflow.com"},{"url":"http://stackoverflow.com/users/337247/macpython","title":"User MacPython - Stack Overflow","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"stackoverflow.com"},{"url":"https://github.com/taizilongxu/interview_python/issues/4","title":"关于字符串格式化 ・ Issue #4 ・ taizilongxu/interview_python ・ GitHub","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"github.com"},{"url":"http://tools.ietf.org/html/rfc2616#section-9.5","title":"RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"tools.ietf.org"},{"url":"https://www.python.org/dev/peps/pep-3333/","title":"PEP 3333 -- Python Web Server Gateway Interface v1.0.1 | Python.org","fancy_title":null,"internal":false,"attachment":false,"reflection":false,"clicks":0,"user_id":1583,"domain":"www.python.org"}],"notification_level":1,"can_flag_topic":false},"highest_post_number":1,"deleted_by":null,"actions_summary":[{"id":4,"count":0,"hidden":false,"can_act":false},{"id":7,"count":0,"hidden":false,"can_act":false},{"id":8,"count":0,"hidden":false,"can_act":false}],"chunk_size":20,"bookmarked":null,"tags":["python"]});
      </script> 
  <script>
  window.assetPath = (function(){
    var map = {"defer/html-sanitizer-bundle":"//cdn.suanfazu.com/assets/defer/html-sanitizer-bundle-d248c5e7fffd65438fab42fafa3d1d56.js"};
    return function(asset) { return map[asset]; };
  })();
</script> 
  <script>
  Ember.RSVP.configure('onerror', function(e) {
    // Ignore TransitionAborted exceptions that bubble up
    if (e && e.message === "TransitionAborted") { return; }

    window.onerror(e && e.message, null,null,null,e);
  });


</script> 
  <script>
  Discourse.CDN = '//cdn.suanfazu.com';
  Discourse.BaseUrl = 'suanfazu.com'.replace(/:[\d]*$/,"");
  Discourse.BaseUri = '';
  Discourse.Environment = 'production';
  Discourse.SiteSettings = PreloadStore.get('siteSettings');
  Discourse.LetterAvatarVersion = '5_b81b9db9c25c85a3cb45c5969b40553e';
  I18n.defaultLocale = 'zh_CN';
  PreloadStore.get("customEmoji").forEach(function(emoji) {
    Discourse.Dialect.registerEmoji(emoji.name, emoji.url);
  });
  Discourse.start();
  Discourse.set('assetVersion','a26913625110801f581a18c324969d26');
  Discourse.Session.currentProp("disableCustomCSS", false);
  Discourse.HighlightJSPath = "/highlight-js/suanfazu.com/133b1767dbeecf92cad6dfc38d42cde22195db05.js";
</script> 
  <script src="//cdn.suanfazu.com/assets/browser-update-1b088c371e098d02d2b87570660d5d68.js"></script> 
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?9b0738ab1116d7971e6048c2c63c1da4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script> 
  <script>
function sfz_wait(required_selector, excluded_selector, check_interval, callback) {
    var func = function(){sfz_wait(required_selector, excluded_selector, check_interval, callback)};

    var s=$(required_selector);
    if (!s || s.length <= 0) {
        callback(false);
        setTimeout(func, check_interval);
        return;
    }

    s=$(excluded_selector);
    if (s && s.length > 0) {
        setTimeout(func, check_interval * 2);
        return;
    }
    
    callback(true);
    setTimeout(func, check_interval * 2);
}

function _parse_toc(dom) {
    var contents = $('#main-outlet div.post > ul:first', $('<html>').html($('noscript', dom).text()));
    if (contents && contents.length > 0) return contents;
    var s = $('script:contains("PreloadStore.store"):first', dom).text();
    s = JSON.parse(s.substring(s.indexOf(',') + 1, s.lastIndexOf(')'))).post_stream.posts[0].cooked;
    contents = $('ul:first', $('<html>').html(s));
    if (contents && contents.length > 0) return contents;
    return null;
}

var TOCTAG='::::';
function handle_toc(enabled) {
    $('#toc-left-container').remove();
    if (!enabled) return;
    var toc = $('#post_1 a:contains("' + TOCTAG + '")');
    var toc_url = toc.attr('href');
    if (!toc_url || (toc_url.indexOf('://') != -1 && toc_url.indexOf('http://suanfazu.com/') != 0)) {return;};
    var json_url = null;
    try {
        json_url = toc_url.split('/t/')[1].split('/')[1];
        json_url = 'http://suanfazu.com/t/' + json_url + '.json'
    } catch (e) {console.log(e);};
    $.getJSON({
        url: json_url,
        cache: true,
        context: document.body,
        success: function(data, textStatus, request) {
            try {
                var contents = $('body > ul:first', $('<html>').html(data.post_stream.posts[0].cooked));
                if (!contents) {return;}
                contents.attr('class', 'toc toc-body');
                toc.after(contents);

                if (screen.width >= 1360) {
                    var contents = $('body > ul:first', $('<html>').html(data.post_stream.posts[0].cooked));
                    contents.attr('class', 'toc toc-left');
                    var title = toc.clone().children().remove().end().text().replace(TOCTAG, '').trim();
                    title = title.replace('<', '&lt;').replace('>', '&gt;');
                    $('body').append('<div id="toc-left-container"><div class="toc-title"><a href="' + toc_url + '">' + title + '</a></div></div>');
                    $('#toc-left-container').append(contents);
                    if ($('#toc-left-container').height() >= screen.height - 100) {
                        $('#toc-left-container').css({top:70});
                    } else {
                        $(window).scroll(function () {
                            var currenttop = $(window).scrollTop();
                            if(currenttop>180){
                                $('#toc-left-container').css({position:'fixed', top:29, zIndex:100000});
                            }
                            if($('#toc-left-container').css('position')=='fixed'){
                                if(currenttop<180) {
                                    $('#toc-left-container').css({position:'absolute', top:200});
                                }
                            }
                        });
                    }
                }

                var curr = $('.toc a[href*="' + window.location.href.replace('http://suanfazu.com', '') + '"]');
                curr.attr('class', 'toc-curr-a');
                curr.parent().attr('class', 'toc-curr');
                toc.after('<div class="toc-page"><div id="toc-prev"></div><div id="toc-next"></div></div>');
                var items = $('.toc-body a');
                for (var i = 0; i < items.length; i++) {
                    if ($(items[i]).attr('class') == 'toc-curr-a') {
                        if (i > 0) {
                            $('#toc-prev').append('<span>上一篇：</span><a href="' + $(items[i-1]).attr('href') + '">' + $(items[i-1]).text() + '</a>');
                        }
                        if (i + 1 < items.length) {
                            $('#toc-next').append('<span>下一篇：</span><a href="' + $(items[i+1]).attr('href') + '">' + $(items[i+1]).text() + '</a>');
                        }
                        break;
                    }
                }
                // $.merge($('.toc-page a'), $('.toc a')).click(function(){
                //     window.location.href = $(this).attr('href');
                // });
            } catch (e) {console.log(e);};
        }
    });
}
//handle_toc();
//if (window.location.href.indexOf('suanfazu.com/t/') != -1) 
{sfz_wait('#post_1', '.toc-body', 500, handle_toc);}
</script>   
 </body>
</html>