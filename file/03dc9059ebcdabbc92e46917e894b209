<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head id="Head">
  <title>
	狼爱上狸 - BlogJava
</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta id="metaKeywords" name="keywords" content="java,j2ee,博客,blog,java blog,blogjava" />
  <link type="text/css" rel="stylesheet" href="/css/common.css" />
  <link id="MainCss" type="text/css" rel="stylesheet" href="http://www.blogjava.net/Skins/marvin2/style.css" />
  <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://www.blogjava.net/waterjava/rss.aspx" />
 </head> 
 <body> 
  <form name="Form1" method="post" action="default.html?page=8" id="Form1"> 
   <input type="hidden" name="__VIEWSTATE" id="
__VIEWSTATE" value="" /> 
   <div id="top"> 
    <h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.blogjava.net/waterjava/">狼爱上狸</a></h1> 
    <p id="tagline">我胡汉三又回来了</p> 
   </div> 
   <div id="leftmenu" style="display:none"> 
    <h3>导航</h3> 
    <ul> 
     <li> <a id="MyLinks1_HomeLink" href="http://www.blogjava.net/">BlogJava</a> </li>
     <li><a id="MyLinks1_MyHomeLink" href="http://www.blogjava.net/waterjava/">首页</a></li> 
     <li><a id="MyLinks1_NewPostLink" href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?opt=1">新随笔</a></li> 
     <li> <a id="MyLinks1_ContactLink" accesskey="9" href="http://www.blogjava.net/waterjava/contact.aspx?id=1">联系</a> </li>
     <li> <a id="MyLinks1_Syndication" href="http://www.blogjava.net/waterjava/rss">聚合</a><a id="MyLinks1_XMLLink" href="http://www.blogjava.net/waterjava/rss"><img src="http://www.blogjava.net/images/xml.gif" border="0" /></a> </li>
     <li> <a id="MyLinks1_Admin" href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx">管理</a></li> 
    </ul> 
    <table id="Calendar1_entryCal" class="Cal" cellspacing="0" cellpadding="0" title="日历" border="0"> 
     <tbody>
      <tr>
       <td colspan="7" bgcolor="Silver">
        <table class="CalTitle" cellspacing="0" border="0" width="100%"> 
         <tbody>
          <tr>
           <td class="CalNextPrev" width="15%"><a href="javascript:__doPostBack('Calendar1$entryCal','V6241')" style="color:Black" title="转到上一个月">&lt;</a></td>
           <td align="center" width="70%">2017年3月</td>
           <td class="CalNextPrev" align="right" width="15%"><a href="javascript:__doPostBack('Calendar1$entryCal','V6300')" style="color:Black" title="转到下一个月">&gt;</a></td>
          </tr> 
         </tbody>
        </table></td>
      </tr>
      <tr>
       <th class="CalDayHeader" align="center" abbr="日" scope="col">日</th>
       <th class="CalDayHeader" align="center" abbr="一" scope="col">一</th>
       <th class="CalDayHeader" align="center" abbr="二" scope="col">二</th>
       <th class="CalDayHeader" align="center" abbr="三" scope="col">三</th>
       <th class="CalDayHeader" align="center" abbr="四" scope="col">四</th>
       <th class="CalDayHeader" align="center" abbr="五" scope="col">五</th>
       <th class="CalDayHeader" align="center" abbr="六" scope="col">六</th>
      </tr>
      <tr>
       <td class="CalOtherMonthDay" align="center" width="14%">26</td>
       <td class="CalOtherMonthDay" align="center" width="14%">27</td>
       <td class="CalOtherMonthDay" align="center" width="14%">28</td>
       <td align="center" width="14%">1</td>
       <td align="center" width="14%">2</td>
       <td align="center" width="14%">3</td>
       <td class="CalWeekendDay" align="center" width="14%">4</td>
      </tr>
      <tr>
       <td class="CalWeekendDay" align="center" width="14%">5</td>
       <td align="center" width="14%">6</td>
       <td align="center" width="14%">7</td>
       <td align="center" width="14%">8</td>
       <td align="center" width="14%">9</td>
       <td align="center" width="14%">10</td>
       <td class="CalWeekendDay" align="center" width="14%">11</td>
      </tr>
      <tr>
       <td class="CalWeekendDay" align="center" width="14%">12</td>
       <td align="center" width="14%">13</td>
       <td align="center" width="14%">14</td>
       <td align="center" width="14%">15</td>
       <td align="center" width="14%">16</td>
       <td align="center" width="14%">17</td>
       <td class="CalWeekendDay" align="center" width="14%">18</td>
      </tr>
      <tr>
       <td class="CalWeekendDay" align="center" width="14%">19</td>
       <td align="center" width="14%">20</td>
       <td align="center" width="14%">21</td>
       <td align="center" width="14%">22</td>
       <td align="center" width="14%">23</td>
       <td align="center" width="14%">24</td>
       <td class="CalWeekendDay" align="center" width="14%">25</td>
      </tr>
      <tr>
       <td class="CalWeekendDay" align="center" width="14%">26</td>
       <td class="CalTodayDay" align="center" width="14%">27</td>
       <td align="center" width="14%">28</td>
       <td align="center" width="14%">29</td>
       <td align="center" width="14%">30</td>
       <td align="center" width="14%">31</td>
       <td class="CalOtherMonthDay" align="center" width="14%">1</td>
      </tr>
      <tr>
       <td class="CalOtherMonthDay" align="center" width="14%">2</td>
       <td class="CalOtherMonthDay" align="center" width="14%">3</td>
       <td class="CalOtherMonthDay" align="center" width="14%">4</td>
       <td class="CalOtherMonthDay" align="center" width="14%">5</td>
       <td class="CalOtherMonthDay" align="center" width="14%">6</td>
       <td class="CalOtherMonthDay" align="center" width="14%">7</td>
       <td class="CalOtherMonthDay" align="center" width="14%">8</td>
      </tr> 
     </tbody>
    </table> 
    <h3>统计</h3> 
    <ul> 
     <li> 随笔 - 237 </li>
     <li> 文章 - 1 </li>
     <li> 评论 - 97 </li>
     <li> 引用 - 0 </li> 
    </ul> 
    <h3>常用链接</h3> 
    <ul> 
     <li><a id="SingleColumn1_ctl00_repeaterLinks_ctl01_lnkLinkItem" href="http://www.blogjava.net/waterjava/MyPosts.html">我的随笔</a></li> 
     <li><a id="SingleColumn1_ctl00_repeaterLinks_ctl02_lnkLinkItem" href="http://www.blogjava.net/waterjava/MyComments.html">我的评论</a></li> 
     <li><a id="SingleColumn1_ctl00_repeaterLinks_ctl03_lnkLinkItem" href="http://www.blogjava.net/waterjava/OtherPosts.html">我的参与</a></li> 
     <li><a id="SingleColumn1_ctl00_repeaterLinks_ctl04_lnkLinkItem" href="http://www.blogjava.net/waterjava/RecentComments.html">最新评论</a></li> 
    </ul> 
    <h3>留言簿<span style="font-size:11px;font-weight:normal;">(15)</span></h3> 
    <ul> 
     <li> <a id="SingleColumn1_ctl01_lnkMessages" href="http://www.blogjava.net/waterjava/Contact.aspx?id=1">给我留言</a> </li>
     <li> <a id="SingleColumn1_ctl01_lnkPublicMsgView" href="http://www.blogjava.net/waterjava/default.aspx?opt=msg">查看公开留言</a> </li>
     <li> <a id="SingleColumn1_ctl01_lnkPrivateMsgView" href="http://www.blogjava.net/waterjava/admin/MyMessages.aspx">查看私人留言</a> </li> 
    </ul> 
    <h3>随笔分类</h3> 
    <ul> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl01_Link" href="http://www.blogjava.net/waterjava/category/31364.html">Acegi(6)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl01_RssLink" title="Subscribe to Acegi(6)" href="http://www.blogjava.net/waterjava/category/31364.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl02_Link" href="http://www.blogjava.net/waterjava/category/50407.html">android(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl02_RssLink" title="Subscribe to android(1)" href="http://www.blogjava.net/waterjava/category/50407.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl03_Link" href="http://www.blogjava.net/waterjava/category/39024.html">Apache(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl03_RssLink" title="Subscribe to Apache(1)" href="http://www.blogjava.net/waterjava/category/39024.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl04_Link" href="http://www.blogjava.net/waterjava/category/23480.html">AXIS(8)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl04_RssLink" title="Subscribe to AXIS(8)" href="http://www.blogjava.net/waterjava/category/23480.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl05_Link" href="http://www.blogjava.net/waterjava/category/13188.html">Eclipse(12)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl05_RssLink" title="Subscribe to Eclipse(12)" href="http://www.blogjava.net/waterjava/category/13188.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl06_Link" href="http://www.blogjava.net/waterjava/category/36636.html">EJB3.0(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl06_RssLink" title="Subscribe to EJB3.0(1)" href="http://www.blogjava.net/waterjava/category/36636.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl07_Link" href="http://www.blogjava.net/waterjava/category/54876.html">elasticsearch(4)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl07_RssLink" title="Subscribe to elasticsearch(4)" href="http://www.blogjava.net/waterjava/category/54876.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl08_Link" href="http://www.blogjava.net/waterjava/category/50467.html">EPUB(5)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl08_RssLink" title="Subscribe to EPUB(5)" href="http://www.blogjava.net/waterjava/category/50467.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl09_Link" href="http://www.blogjava.net/waterjava/category/48343.html">EXTJS(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl09_RssLink" title="Subscribe to EXTJS(1)" href="http://www.blogjava.net/waterjava/category/48343.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl10_Link" href="http://www.blogjava.net/waterjava/category/23444.html">Globus(17)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl10_RssLink" title="Subscribe to Globus(17)" href="http://www.blogjava.net/waterjava/category/23444.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl11_Link" href="http://www.blogjava.net/waterjava/category/16551.html">Hibernate(3)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl11_RssLink" title="Subscribe to Hibernate(3)" href="http://www.blogjava.net/waterjava/category/16551.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl12_Link" href="http://www.blogjava.net/waterjava/category/31327.html">IBM CM(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl12_RssLink" title="Subscribe to IBM CM(1)" href="http://www.blogjava.net/waterjava/category/31327.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl13_Link" href="http://www.blogjava.net/waterjava/category/54878.html">impala</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl13_RssLink" title="Subscribe to impala" href="http://www.blogjava.net/waterjava/category/54878.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl14_Link" href="http://www.blogjava.net/waterjava/category/11991.html">J2EE(3)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl14_RssLink" title="Subscribe to J2EE(3)" href="http://www.blogjava.net/waterjava/category/11991.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl15_Link" href="http://www.blogjava.net/waterjava/category/9755.html">JAVA(26)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl15_RssLink" title="Subscribe to JAVA(26)" href="http://www.blogjava.net/waterjava/category/9755.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl16_Link" href="http://www.blogjava.net/waterjava/category/51595.html">JS(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl16_RssLink" title="Subscribe to JS(1)" href="http://www.blogjava.net/waterjava/category/51595.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl17_Link" href="http://www.blogjava.net/waterjava/category/16552.html">JSF(2)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl17_RssLink" title="Subscribe to JSF(2)" href="http://www.blogjava.net/waterjava/category/16552.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl18_Link" href="http://www.blogjava.net/waterjava/category/9750.html">LINUX(54)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl18_RssLink" title="Subscribe to LINUX(54)" href="http://www.blogjava.net/waterjava/category/9750.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl19_Link" href="http://www.blogjava.net/waterjava/category/48128.html">Mongo(10)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl19_RssLink" title="Subscribe to Mongo(10)" href="http://www.blogjava.net/waterjava/category/48128.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl20_Link" href="http://www.blogjava.net/waterjava/category/9752.html">MSSQL(4)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl20_RssLink" title="Subscribe to MSSQL(4)" href="http://www.blogjava.net/waterjava/category/9752.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl21_Link" href="http://www.blogjava.net/waterjava/category/9754.html">MYSQL(10)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl21_RssLink" title="Subscribe to MYSQL(10)" href="http://www.blogjava.net/waterjava/category/9754.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl22_Link" href="http://www.blogjava.net/waterjava/category/48084.html">NoSQL(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl22_RssLink" title="Subscribe to NoSQL(1)" href="http://www.blogjava.net/waterjava/category/48084.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl23_Link" href="http://www.blogjava.net/waterjava/category/48259.html">Office(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl23_RssLink" title="Subscribe to Office(1)" href="http://www.blogjava.net/waterjava/category/48259.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl24_Link" href="http://www.blogjava.net/waterjava/category/9753.html">ORACLE(9)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl24_RssLink" title="Subscribe to ORACLE(9)" href="http://www.blogjava.net/waterjava/category/9753.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl25_Link" href="http://www.blogjava.net/waterjava/category/9751.html">SOLARIS(10)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl25_RssLink" title="Subscribe to SOLARIS(10)" href="http://www.blogjava.net/waterjava/category/9751.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl26_Link" href="http://www.blogjava.net/waterjava/category/23752.html">Sybase(5)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl26_RssLink" title="Subscribe to Sybase(5)" href="http://www.blogjava.net/waterjava/category/23752.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl27_Link" href="http://www.blogjava.net/waterjava/category/23635.html">Tomcat(8)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl27_RssLink" title="Subscribe to Tomcat(8)" href="http://www.blogjava.net/waterjava/category/23635.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl28_Link" href="http://www.blogjava.net/waterjava/category/54877.html">triplestore</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl28_RssLink" title="Subscribe to triplestore" href="http://www.blogjava.net/waterjava/category/54877.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl29_Link" href="http://www.blogjava.net/waterjava/category/42658.html">VMware(4)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl29_RssLink" title="Subscribe to VMware(4)" href="http://www.blogjava.net/waterjava/category/42658.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl30_Link" href="http://www.blogjava.net/waterjava/category/23678.html">WAP(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl30_RssLink" title="Subscribe to WAP(1)" href="http://www.blogjava.net/waterjava/category/23678.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl31_Link" href="http://www.blogjava.net/waterjava/category/9749.html">WINDOWS(8)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl31_RssLink" title="Subscribe to WINDOWS(8)" href="http://www.blogjava.net/waterjava/category/9749.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl32_Link" href="http://www.blogjava.net/waterjava/category/20593.html">军事</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl32_RssLink" title="Subscribe to 军事" href="http://www.blogjava.net/waterjava/category/20593.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl33_Link" href="http://www.blogjava.net/waterjava/category/37865.html">户外(2)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl33_RssLink" title="Subscribe to 户外(2)" href="http://www.blogjava.net/waterjava/category/37865.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl34_Link" href="http://www.blogjava.net/waterjava/category/36601.html">摄影(3)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl34_RssLink" title="Subscribe to 摄影(3)" href="http://www.blogjava.net/waterjava/category/36601.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl35_Link" href="http://www.blogjava.net/waterjava/category/10952.html">有用连接(2)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl35_RssLink" title="Subscribe to 有用连接(2)" href="http://www.blogjava.net/waterjava/category/10952.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl36_Link" href="http://www.blogjava.net/waterjava/category/36599.html">硬件(2)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl36_RssLink" title="Subscribe to 硬件(2)" href="http://www.blogjava.net/waterjava/category/36599.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl37_Link" href="http://www.blogjava.net/waterjava/category/36600.html">网络</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl37_RssLink" title="Subscribe to 网络" href="http://www.blogjava.net/waterjava/category/36600.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl38_Link" href="http://www.blogjava.net/waterjava/category/28913.html">羽毛球(13)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl38_RssLink" title="Subscribe to 羽毛球(13)" href="http://www.blogjava.net/waterjava/category/28913.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl39_Link" href="http://www.blogjava.net/waterjava/category/31993.html">股票(1)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl39_RssLink" title="Subscribe to 股票(1)" href="http://www.blogjava.net/waterjava/category/31993.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl40_Link" href="http://www.blogjava.net/waterjava/category/54886.html">西安(2)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl40_RssLink" title="Subscribe to 西安(2)" href="http://www.blogjava.net/waterjava/category/54886.html/rss">(rss)</a></li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl41_Link" href="http://www.blogjava.net/waterjava/category/10819.html">随笔(10)</a> <a id="SingleColumn1_Categories_CatList_ctl00_LinkList_ctl41_RssLink" title="Subscribe to 随笔(10)" href="http://www.blogjava.net/waterjava/category/10819.html/rss">(rss)</a></li> 
    </ul> 
    <h3>随笔档案</h3> 
    <ul> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl01_Link" href="http://www.blogjava.net/waterjava/archive/2015/07.html">2015年7月 (7)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl02_Link" href="http://www.blogjava.net/waterjava/archive/2012/11.html">2012年11月 (1)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl03_Link" href="http://www.blogjava.net/waterjava/archive/2012/05.html">2012年5月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl04_Link" href="http://www.blogjava.net/waterjava/archive/2011/12.html">2011年12月 (6)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl05_Link" href="http://www.blogjava.net/waterjava/archive/2011/04.html">2011年4月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl06_Link" href="http://www.blogjava.net/waterjava/archive/2011/03.html">2011年3月 (13)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl07_Link" href="http://www.blogjava.net/waterjava/archive/2010/01.html">2010年1月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl08_Link" href="http://www.blogjava.net/waterjava/archive/2009/12.html">2009年12月 (9)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl09_Link" href="http://www.blogjava.net/waterjava/archive/2009/11.html">2009年11月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl10_Link" href="http://www.blogjava.net/waterjava/archive/2009/10.html">2009年10月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl11_Link" href="http://www.blogjava.net/waterjava/archive/2009/04.html">2009年4月 (1)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl12_Link" href="http://www.blogjava.net/waterjava/archive/2009/02.html">2009年2月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl13_Link" href="http://www.blogjava.net/waterjava/archive/2009/01.html">2009年1月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl14_Link" href="http://www.blogjava.net/waterjava/archive/2008/12.html">2008年12月 (5)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl15_Link" href="http://www.blogjava.net/waterjava/archive/2008/11.html">2008年11月 (1)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl16_Link" href="http://www.blogjava.net/waterjava/archive/2008/10.html">2008年10月 (3)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl17_Link" href="http://www.blogjava.net/waterjava/archive/2008/07.html">2008年7月 (5)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl18_Link" href="http://www.blogjava.net/waterjava/archive/2008/06.html">2008年6月 (3)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl19_Link" href="http://www.blogjava.net/waterjava/archive/2008/05.html">2008年5月 (19)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl20_Link" href="http://www.blogjava.net/waterjava/archive/2008/04.html">2008年4月 (16)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl21_Link" href="http://www.blogjava.net/waterjava/archive/2008/03.html">2008年3月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl22_Link" href="http://www.blogjava.net/waterjava/archive/2008/01.html">2008年1月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl23_Link" href="http://www.blogjava.net/waterjava/archive/2007/12.html">2007年12月 (2)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl24_Link" href="http://www.blogjava.net/waterjava/archive/2007/11.html">2007年11月 (3)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl25_Link" href="http://www.blogjava.net/waterjava/archive/2007/10.html">2007年10月 (5)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl26_Link" href="http://www.blogjava.net/waterjava/archive/2007/09.html">2007年9月 (3)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl27_Link" href="http://www.blogjava.net/waterjava/archive/2007/08.html">2007年8月 (4)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl28_Link" href="http://www.blogjava.net/waterjava/archive/2007/07.html">2007年7月 (48)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl29_Link" href="http://www.blogjava.net/waterjava/archive/2007/06.html">2007年6月 (16)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl30_Link" href="http://www.blogjava.net/waterjava/archive/2007/05.html">2007年5月 (1)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl31_Link" href="http://www.blogjava.net/waterjava/archive/2006/11.html">2006年11月 (19)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl32_Link" href="http://www.blogjava.net/waterjava/archive/2006/10.html">2006年10月 (7)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl33_Link" href="http://www.blogjava.net/waterjava/archive/2006/09.html">2006年9月 (1)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl34_Link" href="http://www.blogjava.net/waterjava/archive/2006/08.html">2006年8月 (1)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl35_Link" href="http://www.blogjava.net/waterjava/archive/2006/07.html">2006年7月 (3)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl36_Link" href="http://www.blogjava.net/waterjava/archive/2006/06.html">2006年6月 (4)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl37_Link" href="http://www.blogjava.net/waterjava/archive/2006/05.html">2006年5月 (3)</a> </li> 
     <li><a id="SingleColumn1_Categories_CatList_ctl01_LinkList_ctl38_Link" href="http://www.blogjava.net/waterjava/archive/2006/04.html">2006年4月 (10)</a> </li> 
    </ul> 
    <h3>hideto</h3> 
    <ul> 
     <li><a id="SingleColumn1_Categories_CatList_ctl02_LinkList_ctl01_Link" href="http://blog.guoshuang.com/index.asp">郭爽的博客</a> </li> 
    </ul> 
    <h3>java友</h3> 
    <ul> 
     <li><a id="SingleColumn1_Categories_CatList_ctl03_LinkList_ctl01_Link" href="http://www.williamlong.info/">月光博客</a> </li> 
     <li style="margin-top:2px;">青青子衿, 悠悠我心, 但为君故, 沉吟至今</li> 
    </ul> 
    <script language="JavaScript">
function SearchGoogle(key,evt,site)
		{
			if(evt.keyCode==13 || evt.keyCode==0 || evt.type =='click')
			{
				key.focus();
				var keystr = encodeURIComponent(key.value);
				url = "http://www.google.com/search?q=";
				url = url+keystr;
				url += "&ie=UTF-8&oe=GB2312&hl=zh-CN&domains="+site+"&sitesearch="+site;
				window.location=url;
				return false;
			}
		}
</script> 
    <h3>搜索</h3> 
    <ul> 
     <li> </li>
     <li><input style="WIDTH: 130px" type="text" name="q" id="q" onkeydown="return SearchGoogle(document.getElementById('q'),event,'www.blogjava.net/waterjava')" />&nbsp;<input onclick="SearchGoogle(document.getElementById('q'),event,'www.blogjava.net/waterjava')" type="button" value="搜索" name="sa" /> </li> 
    </ul> 
    <h3>最新评论 <a id="SingleColumn1__2e115bc_RSSHyperlink1" href="http://www.blogjava.net/waterjava/CommentsRSS.aspx"><img src="/images/xml.gif" border="0" /></a></h3> 
    <div class="RecentComment"> 
     <ul> 
      <li style="word-break:break-all"> <a id="SingleColumn1__2e115bc_CommentList_ctl01_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2015/04/28/347839.html#424717">1.&nbsp;re: 怎么修改ppt模板</a> </li> 
      <li style="word-break:break-all"> 修改，打不开<br /> </li> 
      <li style="text-align:right;margin-right:4px"> --马铁军</li> 
      <li style="word-break:break-all"> <a id="SingleColumn1__2e115bc_CommentList_ctl02_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2014/07/08/116146.html#415601">2.&nbsp;re: 安装了TomcatPlugin插件,为什么没有Tomcat？[未登录]</a> </li> 
      <li style="word-break:break-all"> @余金桂 <br /> </li> 
      <li style="text-align:right;margin-right:4px"> --peng</li> 
      <li style="word-break:break-all"> <a id="SingleColumn1__2e115bc_CommentList_ctl03_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2013/03/01/131399.html#395949">3.&nbsp;re: Ubuntu安装TomCat</a> </li> 
      <li style="word-break:break-all"> 评论内容较长,点击标题查看 </li> 
      <li style="text-align:right;margin-right:4px"> --路人甲</li> 
      <li style="word-break:break-all"> <a id="SingleColumn1__2e115bc_CommentList_ctl04_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2012/11/28/129298.html#392155">4.&nbsp;re: Windows XP下WS-core4.0.4Math实例调试(1)[未登录]</a> </li> 
      <li style="word-break:break-all"> @marry <br />你好，我也遇到这个问题不知道你后来是怎么解决的？谢谢 </li> 
      <li style="text-align:right;margin-right:4px"> --Owen</li> 
      <li style="word-break:break-all"> <a id="SingleColumn1__2e115bc_CommentList_ctl05_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2012/11/01/379423.html#390581">5.&nbsp;re: [字符编码]Invalid byte 1 of 1-byte UTF-8 sequence终极解决方案[未登录]</a> </li> 
      <li style="word-break:break-all"> 第一种方法成功通过，把你的service.xml 的encoding = &quot;gb2312&quot;; </li> 
      <li style="text-align:right;margin-right:4px"> --aa</li> 
     </ul> 
    </div> 
    <h3>阅读排行榜</h3> 
    <div class="RecentComment"> 
     <ul style="word-break:break-all"> 
      <li> <a id="SingleColumn1__3c122dd_TopList_ctl01_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/07/20/131399.html">1.&nbsp;Ubuntu安装TomCat(30406)</a> </li> 
      <li> <a id="SingleColumn1__3c122dd_TopList_ctl02_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/07/21/131590.html">2.&nbsp;修改Ubuntu启动菜单-使XP变为默认操作系统(14634)</a> </li> 
      <li> <a id="SingleColumn1__3c122dd_TopList_ctl03_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2011/03/23/346806.html">3.&nbsp;在eclipse中快速多行注释的方法(10903)</a> </li> 
      <li> <a id="SingleColumn1__3c122dd_TopList_ctl04_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/07/18/131085.html">4.&nbsp;ubuntu 中启用Root 账号(8243)</a> </li> 
      <li> <a id="SingleColumn1__3c122dd_TopList_ctl05_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2009/10/26/299779.html">5.&nbsp;Ubuntu下安装VNC server(7957)</a> </li> 
     </ul> 
    </div> 
    <h3>评论排行榜</h3> 
    <div class="RecentComment"> 
     <ul style="word-break:break-all"> 
      <li> <a id="SingleColumn1__3a8a5b1_TopList_ctl01_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/06/20/125253.html">1.&nbsp;Windows xp下安装globus toolkit 4.0(11)</a> </li> 
      <li> <a id="SingleColumn1__3a8a5b1_TopList_ctl02_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2008/05/03/197872.html">2.&nbsp;文件系统不同步问题resource is out of sync with the file system的解决办法(9)</a> </li> 
      <li> <a id="SingleColumn1__3a8a5b1_TopList_ctl03_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/07/12/129822.html">3.&nbsp;也谈GT4下Math的调试(8)</a> </li> 
      <li> <a id="SingleColumn1__3a8a5b1_TopList_ctl04_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/05/09/116146.html">4.&nbsp;安装了TomcatPlugin插件,为什么没有Tomcat？(8)</a> </li> 
      <li> <a id="SingleColumn1__3a8a5b1_TopList_ctl05_Hyperlink1" href="http://www.blogjava.net/waterjava/archive/2007/07/10/129298.html">5.&nbsp;Windows XP下WS-core4.0.4Math实例调试(1)(6)</a> </li> 
     </ul> 
    </div> 
   </div> 
   <div id="main"> 
    <p class="date"> <a id="homepage1_HomePageDays_ctl00_ImageLink" title="Day Archive" style="display:inline-block;">#</a> </p> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl00_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/23/202340.html">网格开发人员：值得关注的组织和项目</a></h2> 
     <h1> <p>级别： 初级</p> <p><a href="http://www.ibm.com/developerworks/cn/grid/gr-gridorgs/#author" cmimpressionsent="1">Edna Nerona</a> (<a href="mailto:edna@legacystudios.biz?subject=网格开发人员：值得关注的组织和项目" cmimpressionsent="1">edna@legacystudios.biz</a>), 顾问, Legacy Studios, Inc.<br /> </p> <p>2007 年 8 月 09 日</p> 
      <blockquote>
       之前，我们向您提供了一份 
       <a href="http://www.ibm.com/developerworks/cn/grid/gr-read/index.html" cmimpressionsent="1">“网格开发人员推荐阅读清单”</a> 和 
       <a href="http://www.ibm.com/developerworks/cn/grid/gr-start/index.html" cmimpressionsent="1">“面向网格开发人员的入门级开源工具”</a>。现在我们又编著了一份代表网格计算未来发展的产品项目和组织清单。本文提供了在目前在不同领域（例如癌症研究、天文学和物理学）中开展的项目的详细清单。本文还介绍了工具包、安全性和数据管理。它们都是从各种在线资源获得，向程序员、管理员和新用户介绍了与使用、部署和开发网格基础设施有关的具体信息和项目。
      </blockquote>
      <!--start RESERVED FOR FUTURE USE INCLUDE FILES-->
      <!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters -->
      <!--end RESERVED FOR FUTURE USE INCLUDE FILES--> <p><a name="Production Grid Organizations"><span class="atitle">开发网格的组织</span></a></p> <p>本节将介绍开发网格产品的组织，它们所解决的问题，以及它们是如何影响网格技术的。网格部署产品可以划分为几类：通用网格、科学和社区网格、国家网格、地区网格和大学网格。</p> <p><a name="st1"><span class="smalltitle">国家和国际通用网格</span></a></p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.deisa.org/" cmimpressionsent="1">Distributed European Infrastructure for Supercomputing Applications</a> </strong></strong> 
       </dt>
       <dd>
        作为一个领导国家超级计算中心的协会，DEISA（Distributed European Infrastructure for Supercomputing Applications）部署并操作了一个具有安全产品质量的分布式超级计算环境。通过增强欧洲在高性能计算方面的能力，该研究组织促进了各种科学和技术领域中的科学发现。DEISA 对现有国家高端平台进行了高度集成，使用了专用的网络，并获得了新型系统和网格软件的支持。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.dutchgrid.nl/" cmimpressionsent="1">DutchGrid</a> </strong></strong> 
       </dt>
       <dd>
        成立于 2000 年，DutchGrid 拥有很多成功的研究成果和计划，跨越多个科学协作领域。作为一个学术和研究网格计算的开放平台，DutchGrid 为荷兰的网格用户提供了可全球识别的身份证书。DutchGrid CA 是一个完全中立的项目。任何非盈利的研究人员和学术界用户都可以获得个人和服务器或主机证书来使用网格应用程序。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.eu-egee.org/" cmimpressionsent="1">Enabling Grids for E-science</a> </strong></strong> 
       </dt>
       <dd>
        Enabling Grids for E-science （EGEE）项目将来自 32 个国家的 90 多个机构的科学家和工程师组织在一起，为科学家使用的电子科学（e-scinece）提供了一个无缝的网格基础设施。EGEE 网格包含了超过 30,000 个 CPU，它们可以一周 7 天、每天 24 小时地使用，另外还提供了大约 5 PB（5 百万个 GB）的存储空间，平均要维护 30,000 个并发作业。拥有如此众多的资源改变了科学研究所采用的方法。EGEE 是由欧盟建立的一个为期 4 年的项目。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.grid5000.fr/" cmimpressionsent="1">Grid5000</a> </strong></strong> 
       </dt>
       <dd>
        Grid5000 项目的目标是建立一个高度可配置的具有可控性并可监视的实验网格平台，网格研究人员可以使用它来试验从网络协议层到应用程序层之间的所有软件。Grid5000 将法国地理上分布的 9 个城市连接在一起，提供了 5,000 个 CPU。这 9 个城市包括：Bordeaux、 Grenoble、 Lille、 Lyon、 Nancy、 Orsay、 Rennes、 Sophia-Antipolis 和 Toulouse。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://latinamericangrid.org/" cmimpressionsent="1">LA Grid</a> </strong></strong> 
       </dt>
       <dd>
        LA Grid 的发音是 “lah grid”，它是第一个全面的计算网格，将来自美国、拉美和西班牙各个机构的职员、学生和研究人员联系在一起，协作开发可满足医疗服务行业内商业和社会需求的复杂行业应用程序。除了大学之外，LA Grid 还吸引了全球工业界的参与，从而增强了在很多领域内的创新，包括卫生保健、生命科学和飓风灾难以及灾难防御。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.opensciencegrid.org/" cmimpressionsent="1">Open Science Grid</a> </strong></strong> 
       </dt>
       <dd>
        Open Science Grid （OSG）是科学研究使用的一个分布式计算基础设施。OSG 联盟是惟一一个由各大学、国家实验室、科学协作组织和软件开发人员将海量计算和存储资源组成一个共享的统一网络基础设施的联盟。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://teragrid.org/" cmimpressionsent="1">TeraGrid</a> </strong></strong> 
       </dt>
       <dd>
        TeraGrid 是由 National Science Foundation 创建的一个开放科学研究基础组织。将 9 个合作站点的业界领先的资源组合起来，TeraGrid 创建了一个集成的持久计算资源。通过采用国家专用网络的一条高速千兆网络彼此连接，TeraGrid 提供了超过 150 teraflops 的计算能力、以及接近 2 PB 的循环存储空间、无数的科学数据集、专用的数据分析工具、科学网关、以及用来简化对有价值资源和可视化资源访问的用户门户。 
       </dd>
      </dl> <p><a name="st1"><span class="smalltitle">科学和社区网格</span></a></p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www2.astrogrid.org/" cmimpressionsent="1">AstroGrid</a> </strong></strong> 
       </dt>
       <dd>
        AstroGrid 是一个开源项目，它的建立是为英国和国际天文学家创建一个工作用的虚拟天文台（Virtual Observatory，VO）。AstroGrid 是由英国政府建立，它通过 International Virtual Observatory Alliance （IVOA）与国际上其他 VO 项目紧密协作。作为这个社区的领导成员之一，AstroGrid 提供了国际通用的接口标准，用来促进天文数据的科学集成，并在全球范围内处理资源。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://cabig.nci.nih.gov/" cmimpressionsent="1">cancer Biomedical Informatics Grid</a> </strong></strong> 
       </dt>
       <dd>
        cancer Biomedical Informatics Grid （caBIG）是一个自发组织的网络或网格，它将个人和机构联系在一起，可以共享很多数据和工具，它创建了一个全球范围的癌症研究资源。caBIG 的目标是为了加速癌症预防和治疗方面的创新方法的迅速问世。caBIG 所创建的基础设施和工具在癌症社区之外也有很广泛的应用。caBIG 目前正在 National Cancer Institute 的 Center for Bioinformatics 的领导下进行开发。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.ivdgl.org/" cmimpressionsent="1">International Virtual Data Grid Laboratory</a> </strong></strong> 
       </dt>
       <dd>
        International Virtual Data Grid Laboratory （iVDGL）是一个全球的数据网格，用于物理和天文领域的前沿实验。它的计算、存储和网络资源分布于美国、欧洲、亚洲和南美，提供了一个独特的实验环境，可用来测试和验证国际的和全球范围的网格技术。位于欧洲和美国的站点通过一个由 European DataTAG 项目创建的数千兆每秒的跨越大西洋的链接链接在一起。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.worldcommunitygrid.org/" cmimpressionsent="1">World Community Grid</a> </strong></strong> 
       </dt>
       <dd>
        World Community Grid 的使命是创建全世界最大的公共计算网格，研究对人类有益的项目。World Community Grid 的成功在于：集合了个体为实现更美好的世界而贡献出的未用的计算时间。World Community Grid 正在研究一些公共和非盈利组织才能使用的技术，从而开展一些人道主义研究；如果没有公共网格，高昂的计算基础设施将使研究无法完成。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://lcg.web.cern.ch/LCG/" cmimpressionsent="1">Worldwide Large Hadron Collider Computing Grid</a> </strong></strong> 
       </dt>
       <dd>
        Worldwide Large Hadron Collider（LHC）Computing Grid 的目的是处理 2007 年前 CERN 的 LHC 所开展的实验所产生的空前数据量。LHC 开展的实验的计算需求极为庞大。每年大概会生成 12 到 14 PB 的数据，这大约相当于 2 千万张 CD。对这些数据进行分析大约需要 70,000 台目前最快的 PC。通过部署一个全球范围的计算网格，将分布在欧洲、美国和亚洲的科学计算中心的资源集成到一个全球虚拟化计算服务中，LHC Computing Grid 可以满足这些需求。 
       </dd>
      </dl><br /> 
      <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
       <tbody> 
        <tr> 
         <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
        </tr> 
       </tbody> 
      </table> 
      <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
       <tbody> 
        <tr align="right"> 
         <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
          <table cellspacing="0" cellpadding="0" border="0"> 
           <tbody> 
            <tr> 
             <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
             <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/grid/gr-gridorgs/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
            </tr> 
           </tbody> 
          </table> </td> 
        </tr> 
       </tbody> 
      </table> <br /> <br /> <p><a name="N1012B"><span class="atitle">美国地区的网格</span></a></p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.nwicgrid.org/" cmimpressionsent="1">Northwest Indiana Computational Grid</a> </strong></strong> 
       </dt>
       <dd>
        Northwest Indiana Computational Grid（NWICG）是来自 Purdue University-West Lafayette、 Purdue University-Calumet 和 University of Notre Dame 的合作研究和教育组织。NWICG 重点关注的是国家科学和研究活动，其创建的网络基础设施可以支持重大问题的解决方案，以及在高性能计算底层技术领域启用保持世界领先的技术。它们正在 Department of Energy's Argonne National Laboratories 的协助下，在这 3 个大学之间为 Northwest Indiana 开发一个可扩充的高速、高带宽的科学驱动计算网格。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.sura.org/programs/sura_grid.html" cmimpressionsent="1">SURAGrid</a> </strong></strong> 
       </dt>
       <dd>
        Southeastern Universities Research Association（SURA）是一个组织协作联盟，它合并各种资源以将网格技术上升到无缝的共享基础设施。SURAgrid 着重关注的是对大量分布式能力的直接访问，从而用于研究和教育社区。SURAgrid 促进了以下领域的开发：所贡献的资源、项目特有的工具和环境、高度专门化访问、通往国家和国际的网络基础设施网关。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.hipcat.net/Projects/tigre" cmimpressionsent="1">Texas Internet Grid for Research and Education</a> </strong></strong> 
       </dt>
       <dd>
        Texas Internet Grid for Research and Education （TIGRE）项目的使命是将整个得克萨斯州的计算系统、存储系统、数据库、可视化实验和显示以及仪器和传感设备整合在一起，创建一个计算网格。通过集成强大的计算能力，为得克萨斯州在学术、政府以及工业界的研究人员提供增强的计算能力，TIGRE 希望能够对生物医学、能源和环境、航空宇宙、材料科学、农业和信息技术的进步提供帮助。 
       </dd>
      </dl><br /> 
      <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
       <tbody> 
        <tr> 
         <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
        </tr> 
       </tbody> 
      </table> 
      <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
       <tbody> 
        <tr align="right"> 
         <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
          <table cellspacing="0" cellpadding="0" border="0"> 
           <tbody> 
            <tr> 
             <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
             <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/grid/gr-gridorgs/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
            </tr> 
           </tbody> 
          </table> </td> 
        </tr> 
       </tbody> 
      </table> <br /> <br /> <p><a name="Open source grid projects"><span class="atitle">开源网格项目</span></a></p> <p>这些网格项目覆盖了很多领域，包括网格基础设施工具包、中间件工具包、数据工具、安全等。下面给出了一些迅速发展的网格项目和工具。经常访问这些站点可以了解有关它们领导网格技术不断发展的最新消息。</p> <p><a name="GridInfrastructureProjects"><span class="smalltitle">网格基础设施项目 </span></a></p> <p>帮助建立自己网格的开源网格基础设施项目。 </p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://boinc.berkeley.edu/" cmimpressionsent="1">Berkeley Open Infrastructure for Network Computing</a> </strong></strong> 
       </dt>
       <dd>
        Berkeley Open Infrastructure for Network Computing （BOINC）是项目使用的一个软件平台，例如 distributed.net 和 SETI@home，它使用了数百万台志愿者计算机组成一个并行的超级计算机。可以获得该平台的源代码，并且鼓励感兴趣的 C++ 开发人员帮助开发平台代码。BOINC 目前可以支持 Windows&reg;、Linux&reg;、UNIX&reg; 和 Mac OS X。 CPU 平台的需求可能在使用 BOINC 的项目客户机之间会有所不同。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.unicore.eu/" cmimpressionsent="1">Uniform Interface to Computing Resources</a> </strong></strong> 
       </dt>
       <dd>
        Uniform Interface to Computing Resources（UNICORE）提供了一个可随时运行的网格系统，包括客户机和服务器软件。UNICORE 让分布的计算和数据资源在内部网和互联网上以一种无缝的安全方式使用。UNICORE 设计的重点是几个核心原则：无缝访问异构环境、安全性、站点自治、易于使用的强大的 GUI 客户机，以及可以进行简单安装的快速启动包。 
       </dd>
      </dl> <p><a name="GridMiddlewareProjects"><span class="smalltitle">网格中间件项目 </span></a></p> <p>以下项目已经为美国和国际项目提供了一些高级工具，可以简化访问大量网格功能，例如计算、可视化和存储资源。您可以与不同的网格进行交互，或者为自己的网格进行定制。</p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://glite.web.cern.ch/glite/" cmimpressionsent="1">gLite</a></strong><a href="http://glite.web.cern.ch/glite/" cmimpressionsent="1"> </a></strong>
        <a href="http://glite.web.cern.ch/glite/" cmimpressionsent="1"> </a>
       </dt>
       <dd>
        <a href="http://glite.web.cern.ch/glite/" cmimpressionsent="1">gLite 是网格计算使用的下一代中间件，它诞生于 12 个学术机构和行业研究中心的 80 多个工作人员的联合努力，是 EGEE 项目的一部分。gLite 充分利用分布在 Internet 上的计算和存储资源，为构建网格应用程序提供了一个最佳框架。 </a>
       </dd>
      </dl><a href="http://glite.web.cern.ch/glite/" cmimpressionsent="1"> </a>
      <dl>
       <a href="http://glite.web.cern.ch/glite/" cmimpressionsent="1"> 
        <dt>
         <strong><strong><a href="http://www.naregi.org/index_e.html" cmimpressionsent="1">National Research Grid Initiative</a> </strong></strong> 
        </dt></a>
       <dd>
        National Research Grid Initiative（NAREGI）位于日本，它着重于网格中间件的研究和开发，为广泛分布的、高级研究和教育目的实现大规模的计算环境。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://ninf.apgrid.org/" cmimpressionsent="1">Ninf-G</a> </strong></strong> 
       </dt>
       <dd>
        Ninf 也是日本的一个项目，正在开发编程中间件，使用户能够通过一个简单易用的接口来访问各种资源，例如网格中的硬件、软件和科学数据。Ninf-G 是一个开源软件，支持开发和执行分布式计算资源中使用 Grid Remote Procedure Call（GridRPC）的启用网格的应用程序。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.nordugrid.org/middleware/" cmimpressionsent="1">NorduGrid</a> </strong></strong> 
       </dt>
       <dd>
        NorduGrid 中间件，也称为 Advanced Resource Connector（ARC），是一个按照 GPL 许可发布的开源软件解决方案，可以实现保证产品质量的计算和数据网格。ARC 为基本网格服务提供了一个可靠实现，例如信息服务、资源查找和监视、作业提交和管理、代理和数据管理，以及资源管理。大部分服务都是通过 GSI 的安全层提供的。中间件是在诸如 OpenLDAP、OpenSSL、SASL 和 Globus Toolkit（GT）之类的开源解决方案基础上构建的。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.ogsadai.org.uk/" cmimpressionsent="1">OGSA-DAI</a> </strong></strong> 
       </dt>
       <dd>
        OGSA-DAI 项目着重关注的是中间件的开发，从而有助于对网格中不同来源的数据进行访问和集成。这个项目与 Globus、OMII-Europe、NextGRID、SIMDAT 和 BEinGRID 紧密协作，确保 OGSA-DAI 软件可以在各种网格环境中很好地工作。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www-sop.inria.fr/oasis/proactive" cmimpressionsent="1">ProActive</a> </strong></strong> 
       </dt>
       <dd>
        ProActive 是 Java64 网格中间件库（其开源代码具有 LGPL 许可），可用于进行并行、分布式和多线程计算。通过采用一个简单元语的精简集，ProActive 提供了一个详尽的 API 来简化网格计算应用程序的编程，这些程序均分布在 LAN、工作站集群和 Internet 网格中。 
       </dd>
      </dl> <p><a name="SecurityProjects"><span class="smalltitle">安全项目 </span></a></p> <p>为了保护重要的基础设施和信息，安全性需求一直以来都随网格计算的发展而演变。这些项目代表了一些网格安全解决方案的一些最先进的安全标准和实现。 </p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://gridshib.globus.org/" cmimpressionsent="1">GridShib</a> </strong></strong> 
       </dt>
       <dd>
        GridShib 是在 NCSA 和 University of Chicago 之间开展的由 NFS 创建的项目，用来将联合授权基础设施（Shibboleth）与网格技术（Globus Toolkit）进行集成，从而为分布的科学社区提供基于属性的授权。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://grid.racf.bnl.gov/GUMS/" cmimpressionsent="1">Grid User Management System</a> </strong></strong> 
       </dt>
       <dd>
        Grid User Management System（GUMS）是一个网格身份映射服务（Grid Identity Mapping Service）。当站点资源不使用本地网格凭证，而是使用一种不同的机制来标识用户时（例如 UNIX 帐号或 Kerberos 准则），就需要使用身份映射。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://computing.fnal.gov/docs/products/voprivilege/prima/prima.html" cmimpressionsent="1">PRIvilege Management and Authorization</a> </strong></strong> 
       </dt>
       <dd>
        PRIvilege Management and Authorization（PRIMA）是一个提供增强的网格安全的系统。PRIMA 是一个全面的网格安全模型和系统。在 PRIMA 中，特权是一种与平台无关的、细粒度权限的自包含表示。PRIMA 通过从资源内部表示来具体化对资源对象的细粒度访问权限实现了特权的平台无关性。 
       </dd>
      </dl> <p><a name="ResourceManagement"><span class="smalltitle">资源管理和调度 </span></a></p> <p>网格的一个基本部分就是在资源之间管理和调度作业。下面这些项目展示了有关的一些策略。</p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.globus.org/grid_software/computation/csf.php" cmimpressionsent="1">Community Scheduler Framework</a> </strong></strong> 
       </dt>
       <dd>
        Community Scheduler Framework（CSF）是一个基于 OGSA 的元调度器的开源实现。它可以支持最新的 WS-Agreement 规范和 Globus Toolkit 的 GRAM 服务。CSF 填补了现有资源管理现状的不足，并集成了 Platform LSF 和 Platform Multicluster。CSF 开源项目已经包括到了 Globus Toolkit V4.0 发行版中。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://spruce.teragrid.org/" cmimpressionsent="1">Special Priority and Urgent Computing Environment</a> </strong></strong> 
       </dt>
       <dd>
        高性能建模和仿真在决策制定和预测方面起到了推动作用。对于时间关键型的应急应用程序，例如灾害天气预报、洪水建模、流感建模，任何延时会使结果变得毫无用处。这需要使用专用的基础设施快速、自动而且可靠地提供计算资源。Special Priority and Urgent Computing Environment（SPRUCE）是一个用来在传统超级计算机和分布式网格上支持紧急或事件驱动计算的系统。 
       </dd>
      </dl> <p><a name="GridResourceMonitoring"><span class="smalltitle">网格资源监视 </span></a></p> <p>对资源和应用程序的监视是网格成功的关键。通过一个简单易用的接口，这些复杂工具可以帮助用户搜集、分类和监视各种类型的资源。另外，系统管理员还可以监视网格的健康状况。这些不断发展的网格项目列出了几个开源选择。</p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.ivdgl.org/gridcat/home/index.html" cmimpressionsent="1">GridCat</a> </strong></strong> 
       </dt>
       <dd>
        GridCat 是一个在地理图上使用状态点以及编目的高级网格编目系统。这个图可以帮助调试站点问题。编目中包含了有关站点的准备信息，以及每个站点的很多其他有价值的信息，帮助应用程序用户和网格调度器开发人员进行作业提交和作业调度。GridCat 尝试在其最简单的状态表示中表示网格站点。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.gridbus.org/gridscape/" cmimpressionsent="1">Gridscape II</a> </strong></strong> 
       </dt>
       <dd>
        Gridscape II 是一个定制的门户组件，可以在其自身的网格门户中使用，也可以插入到现有网格门户中。Gridscape II 负责从各种异构和分布式资源中搜集信息，并在单个界面中无缝地将它们呈现出来。它充分利用了 Google Maps API 来提供一个高交互性的用户界面。Gridscape II 非常简单易用，为那些不希望大量投资以从头开始开发自己的监视门户的用户提供了一个解决方案，也为那些希望简化定制内容的用户提供了一种解决方案。 
       </dd>
      </dl> <p><a name="Storage"><span class="smalltitle">存储和数据管理 </span></a></p> <p>从开源高性能文件系统到无缝地访问异构环境中的数据，以下项目集合了各种存储和数据管理解决方案并进行了优化。这种趋势强调的是资源之间的数据存储、管理和移动，以及通过网络对数据资源的连接。</p> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.lustre.org/" cmimpressionsent="1">Lustre</a> </strong></strong> 
       </dt>
       <dd>
        Lustre File System，这是一个来自 Cluster File Systems Inc. 的高性能开源文件系统，它是一个分布式文件系统，消除了很多传统分布式文件系统中存在的性能、可用性和可伸缩性问题。Lustre 是一个高度模块化的下一代存储架构，它将现有的开放标准、Linux 操作系统和创新协议组合成一种可靠的、网络中立的数据存储和检索解决方案。通过在集群和数据共享环境中提供高 I/O 吞吐量，Lustre 还提供了与物理存储上的数据位置无关的独立性，防止单点失效，并且可以从集群的重新配置和服务器或网络故障中快速恢复。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://www.cs.wisc.edu/condor/nest/" cmimpressionsent="1">NeST</a> </strong></strong> 
       </dt>
       <dd>
        NeST 是一个软件网络存储设备，为特定时间段提供了安全的存储分配。分配单元或份额（lot）的大小和持续时间可以在 NeST 和用户或应用程序之间进行协商。这些份额的大小也可以扩充，时间可以扩展，或者划分成不同的层次。另外，NeST 还为份额和文件访问提供了访问控制列表。NeST 提供了多种协议接口，包括内部使用的 Chirp、HTTP 和 GSI-FTP。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://projects.fnal.gov/samgrid/" cmimpressionsent="1">SAMGrid</a> </strong></strong> 
       </dt>
       <dd>
        SAMGrid 是一个通用数据处理系统，它被设计为用来测试大量数据（PB 级）集和广泛分布的产品和分析工具的一个关键设备。当前产品的组件提供了大量的服务，可用于分布式系统中的数据传输、数据存储和进程记录。 
       </dd>
      </dl> 
      <dl> 
       <dt>
        <strong><strong><a href="http://dims.ncsa.uiuc.edu/set/uberftp/index.html" cmimpressionsent="1">UberFTP</a> </strong></strong> 
       </dt>
       <dd>
        UberFTP 是在 GridFTP 基础上构建的，它是第一个启用 GridFTP 的交互式 FTP 客户机。基本的 GridFTP 客户机不是可交互式的，它一次只允许传输一个文件。UberFTP 提供了交互式工具，工作方式与流行的 NCFTP 工具类似。它支持 GSI 认证、并行数据通道以及第三方传输功能。 
       </dd>
      </dl><br /> 
      <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
       <tbody> 
        <tr> 
         <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
        </tr> 
       </tbody> 
      </table> 
      <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
       <tbody> 
        <tr align="right"> 
         <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
          <table cellspacing="0" cellpadding="0" border="0"> 
           <tbody> 
            <tr> 
             <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
             <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/grid/gr-gridorgs/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
            </tr> 
           </tbody> 
          </table> </td> 
        </tr> 
       </tbody> 
      </table> <br /> <br /> <p><a name="N102EB"><span class="atitle">结束语</span></a></p> <p>网格计算是最令人兴奋的技术之一，它在很大程度上影响了我们解决复杂问题和共享各种资源的方式。除了癌症和物理学之外，它对于安全和认证、查找、监视、信息服务、数据管理、资源管理和调度也有重大影响。</p> <br /> <br /> <p><a name="resources"><span class="atitle">参考资料 </span></a></p> <strong>学习</strong><br /> 
      <ul> 
       <li>您可以参阅本文在 developerWorks 全球网站上的 <a href="http://www.ibm.com/developerworks/grid/library/gr-gridorgs/index.html?S_TACT=105AGX52&amp;S_CMP=cn-a-gr" target="_blank" cmimpressionsent="1">英文原文</a>。<br /> <br /> </li>
       <li>查看 developerWorks 中的 “<a href="http://www.ibm.com/developerworks/cn/grid/library/technical/grid.html" cmimpressionsent="1">网格计算文档库</a>”。<br /> <br /> </li>
       <li>要收听面向软件开发人员的有趣访谈和讨论，请查看 <a href="http://www.ibm.com/developerworks/podcast/?S_TACT=105AGX52&amp;S_CMP=cn-a-gr" cmimpressionsent="1">developerWorks podcasts</a>。<br /> <br /> </li>
       <li>随时关注 developerWorks 的 <a href="http://www.ibm.com/developerworks/cn/offers/techbriefings/" cmimpressionsent="1">developerWorks 技术活动和网络广播</a>。<br /> <br /> </li>
       <li>了解世界范围内面向 IBM 开源开发人员的即将召开的会议、商业展示、webcasts 和其他 <a href="http://www.ibm.com/developerworks/views/opensource/events.jsp?S_TACT=105AGX52&amp;S_CMP=cn-a-gr" cmimpressionsent="1">事件</a>。<br /> <br /> </li>
       <li>请访问 <a href="http://www.ibm.com/developerworks/cn/opensource" cmimpressionsent="1">developerWorks 中国网站开源软件技术专区</a>，这里有丰富的 how-to 信息、工具和项目更新信息，可以帮助您使用开源技术进行开发，并与 IBM 产品一起使用。<br /> <br /> </li> 
      </ul> <br /> <strong>获得产品和技术</strong><br /> 
      <ul> 
       <li>请下载 <a href="http://www.ibm.com/developerworks/cn/downloads/" cmimpressionsent="1">IBM 产品评测版</a>，尝试使用来自 DB2&reg;、Lotus&reg;、Rational&reg;、Tivoli&reg; 和 WebSphere&reg; 的应用程序开发工具和中间件产品。 <br /> <br /> </li>
       <li>使用 <a href="http://www.ibm.com/developerworks/cn/downloads/" cmimpressionsent="1">IBM 试用软件</a> 改进您的下一个开源开发项目，这些软件可以从 developerWorks 下载或从 DVD 获得。</li> 
      </ul> <br /> <strong>讨论</strong><br /> 
      <ul> 
       <li>请访问 developerWorks 上的 <a href="http://www.ibm.com/developerworks/forums/dw_forum.jsp?forum=531&amp;cat=52" cmimpressionsent="1">网格计算论坛</a>。<br /> <br /> </li>
       <li>通过参与 <a href="http://www.ibm.com/developerworks/blogs?S_TACT=105AGX52&amp;S_CMP=cn-a-gr" cmimpressionsent="1">developerWorks blogs</a>，加入 developerWorks 社区。<br /> <br /> </li> 
      </ul> <br /> <br /> <p><a name="author"><span class="atitle">关于作者</span></a></p> 
      <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
       <tbody> 
        <tr> 
         <td colspan="3"><img height="5" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /></td> 
        </tr> 
        <tr valign="top" align="left"> 
         <td> <p><img alt="Edna Nerona" src="http://www.ibm.com/developerworks/i/p-enerona.jpg" align="left" valign="top" /></p> </td> 
         <td><img height="5" alt="" src="http://www.ibm.com/i/c.gif" width="4" /></td> 
         <td width="100%"> <p>Edna Nerona 是 Legacy Studios，Inc. 的所有人，这是一家位于 San Diego 的创新服务公司。她拥有 San Diego State University 的新闻学学士学位，曾经在 San Diego Supercomputer Center 和 Entropia，Inc. 工作过。她还是 Toastmasters International 的一名多才多艺的发言人。</p> </td> 
        </tr> 
       </tbody> 
      </table> </h1> 
     <p><br /> <br /> 来自: http://www.ibm.com/developerworks/cn/grid/gr-gridorgs/</p> 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/23/202340.html" title="permalink">2008-05-23 10:55</a> 狼爱上狸 阅读(366) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/23/202340.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=202340">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=202340">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl01_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/19/201410.html">羽球服装及附件</a></h2> 
     <p><font size="4">羽球服装及附件：
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman"></font><font size="3">羽毛球服装选择相对容易了很多。但不是任何运动衫都有资格可以成为羽毛球衣。选择的时候还是要有一些原则的。不要选择纯棉的衣服，因为纯棉的衣服虽然吸汗，但是能力有限，并且不容易蒸发，随着汗水的吸收，自重会加大，到最后会贴在身上，非常的不舒服。夏季不要选择涤棉的衣服，涤棉的衣服虽然比纯棉舒服了很多，但天气炎热的时候还是会出现与纯棉服装一样的结果。冬季如果不是在非常温暖的地区，选择涤棉服装会提高保暖性能。不要选择过于贴身的衣服。过于贴身的衣服有可能会限制球员的运动范围，打球的时候会不太舒服。要选择轻量化服装。并不是每一件衣服都会像知名品牌羽球服装那样的轻盈。进行羽毛球运动时，最好还是穿着专门的羽毛球品牌服装，或是针对羽毛球运动的特点而开发出来的服装。<font face="Times New Roman">YONEX</font>的衣服具有加热降温功能。夏天和冬天分别能提供低<font face="Times New Roman">3</font>度和高<font face="Times New Roman">3</font>度的感觉，是羽球服装的精品。选择运动短裤时要选弹性大的，因为羽毛球运动经常需要球员以蹬跨步移动，一件有弹性的运动短裤可以使动作更舒展而不必担心对服装构成任何伤害。
       <o:p></o:p></font></p> 
     <p><font size="3">羽球服装特点简述：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">YONEX</font>：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">YONEX</font>品牌的服装上镜率最高。其特点也比较明显。材料大致分两大类，特殊功能性纤维和普通功能性纤维。
       <o:p></o:p></font></p> 
     <p><font size="3">普通功能型纤维就是常见的<font face="Times New Roman">YONEX 100</font>％涤纶（<font face="Times New Roman">polyster</font>）的产品。这里要特别说明的是，有很多走私水货的<font face="Times New Roman">YONEX</font>服装，或假冒的<font face="Times New Roman">YONEX</font>服装，都是涤＋棉的。这种衣服的排水性和蒸发汗水能力都远差于正品行货。在天气较热出汗量较大时穿着，衣服会因含有棉的成分而粘贴在身上。令人非常难受。但因其售价低廉，还是可以迎合一小部分人的消费需要。<font face="Times New Roman">SHBC</font>不推荐穿着这样的服装上场打球，如果真的不愿意花很多钱来购买<font face="Times New Roman">YONEX</font>品牌的服装，还有<font face="Times New Roman">KASON</font>服装可供选择。<font face="Times New Roman">KASON</font>的服装也有<font face="Times New Roman">100</font>％涤纶（<font face="Times New Roman">polyster</font>）的，在提供了较低价格的同时，保证了羽球服装应有的性能。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3">特殊功能性纤维指的是<font face="Times New Roman">YY</font>的<font face="Times New Roman">HEAT CAPSULE(</font>热囊<font face="Times New Roman">)</font>和<font face="Times New Roman">VERY COOL(</font>冷却<font face="Times New Roman">)</font>纤维。这两种材料成分标识其实也是100％涤，但所用的材料与普通的YONEX服装不同，VERY COOL服装一般在领子后面的吊牌下方都会带有VERY COOL的标记，比较好辨认。 需要注意的是，SP版的衣服使用了一种叫做TRUE COOL的标记，TRUE COOL的标记与VERY COOL类似，但所谓的TRUE COOL是100％棉生产的，这种衣服很明显是根本不值得购买的。且棉产品容易起皱，放在球包内挤压后穿着会比较难看。</font></p> 
     <p><font size="3">VERY COOL和HEAT CAPSULE可以提供升高
       <st1:chmetcnv w:st="on" tcsc="1" numbertype="3" negative="False" hasspace="False" sourcevalue="3" unitname="摄氏度">
        三摄氏度
       </st1:chmetcnv>或降低
       <st1:chmetcnv w:st="on" tcsc="1" numbertype="3" negative="False" hasspace="False" sourcevalue="3" unitname="摄氏度">
        三摄氏度
       </st1:chmetcnv>的体表感受，在适当的季节穿着相应特性的产品打球，是非常舒适的。因其功能特殊，价格较一般产品贵了不少。约为普通功能型纤维衣物的<font face="Times New Roman">1.5-2</font>倍，但因其舒适性出色，还是很受欢迎的。</font></p> 
     <p><font size="3">VICTOR(胜利）的服装以及KASON（凯胜）的服装虽然品牌不如YONEX那么出名，但衣服的质量是不错的。尤其是VICTOR的服装，06年的设计非常新颖，色彩也很讨好。一样是排汗速干面料，不是非常追求品牌的话，穿起来一样很舒服。</font></p> 
     <p><font size="3">其他还有如BONNY(波力）的银纤维，竹炭纤维也是很不错的衣服，只是设计实力略欠缺，如果能买到心仪的款式，也是很好的选择。</font></p> 
     <p><font size="3">羽毛球袜：</font></p> 
     <p><font size="3">很多人觉得自己的袜子已经够厚了，没必要花几十块去买一双名牌羽球袜，就算是KASON,FLEX等品牌，一双袜子也要二十元以上，其实这种想法是不对的。再厚的袜子，也很难比的上专业羽球袜的厚度。很多对此想法持怀疑态度的人，在亲手摸过羽毛球袜以后，往往会立刻购买。足见普通加厚运动袜与专业羽球袜的区别。</font></p> 
     <p><font size="3">勿庸置疑，YONEX的VERY COOL羽毛球袜是穿着最舒适的羽毛球袜了。关于VERY COOL，这里就不再多说了。价格要比一般的袜子略贵一些，有条件的话这是第一选择。</font></p> 
     <p><font size="3">其他品牌如VICTOR,KASON,FLEX的袜子质量基本相同，价格低但是品质不低，也都可以起到良好的保护作用。只是没有VERY COOL那么舒服。</font></p> 
     <p><font size="3">需要注意的是，一双正品羽毛球袜的厚度大致相当于半码鞋，考虑到运动中双脚会继续充血膨胀，买鞋最好大1码。</font></p> 
     <p><br /> 来自：<a href="http://www.shbc.cn/dispbbs.asp?boardID=307&amp;ID=40224&amp;page=1">http://www.shbc.cn/dispbbs.asp?boardID=307&amp;ID=40224&amp;page=1</a></p> 
     <p>&nbsp;&nbsp;&nbsp;&nbsp; </p> 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201410.html" title="permalink">2008-05-19 16:08</a> 狼爱上狸 阅读(141) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201410.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=201410">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=201410">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl02_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/19/201409.html">羽毛球拍选购</a></h2> 
     <p><font size="3">羽毛球拍：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>拍子的选择是目前球友们最关心的一个问题了。在上羽网论坛上每天要有很多次发言是与球拍的选择有关的。虽然球拍是一个很重要的部分，但在实际运动中，球拍的重要性被夸大了不少。需要强调的是，一把好的球拍可以给使用者以信心，但是根本不可能提高使用者自身的水平。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>目前几乎所有的球拍都是碳素，石墨复合材料制成的。有些生产商喜欢加一些特殊的材料如<font face="Times New Roman">TI</font>金属网，<font face="Times New Roman">KEVLAR</font>（凯芙拉），纳米复合材料。需要着重说明的是，这些附加材料只占了总材料的一少部分，一支球拍的<font face="Times New Roman">99</font>％以上始终还是这种碳素石墨复合材料。附加材料带给球拍性能的改变并不会是非常明显的<font face="Times New Roman">,</font>但确实有效。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>羽毛球拍是球员和球之间的“中介”，由以下几种特性来分类：形状，硬度，重量，平衡点。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>目前的球拍主要有两种形状：圆头拍和方头拍。圆头拍就是传统的拍形，拍头上部略尖，球拍整体呈卵形。这种卵形球拍甜区较小，但甜区部位力量爆发非常的集中。圆头拍对初学者来说较难上手。目前此类拍头的球拍型号已经不是很多了。方头拍<font face="Times New Roman">(ISO</font>拍面<font face="Times New Roman">)</font>是后起之秀，因其甜区巨大在<font face="Times New Roman">90</font>年代初期后迅速风靡全球。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>球拍的硬度类似于拍线的拉力大小。越硬的球拍需要越大的力量驱动，反之亦然。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>球拍的重量是多样化的。常见的球拍重量范围一般在<font face="Times New Roman">80</font>－
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="95" unitname="克">
        <font face="Times New Roman">95</font>克
       </st1:chmetcnv>。同拍柄尺寸单位一样，不同的厂商有各自的重量单位定义，但是最流行的就是<font face="Times New Roman">YONEX</font>公司所使用的<font face="Times New Roman">U</font>系统。<font face="Times New Roman">U</font>＝<font face="Times New Roman">95</font>－
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="100" unitname="克">
        <font face="Times New Roman">100</font>克
       </st1:chmetcnv>，<font face="Times New Roman">2U</font>＝<font face="Times New Roman">90</font>－
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="94" unitname="克">
        <font face="Times New Roman">94</font>克
       </st1:chmetcnv>，<font face="Times New Roman">3U=85</font>
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="True" hasspace="False" sourcevalue="89" unitname="克">
        <font face="Times New Roman">-89</font>克
       </st1:chmetcnv>，<font face="Times New Roman">4U</font>＝<font face="Times New Roman">80</font>－
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="84" unitname="克">
        <font face="Times New Roman">84</font>克
       </st1:chmetcnv>，<font face="Times New Roman">5U</font>＝<font face="Times New Roman">79</font>－<font face="Times New Roman">75</font>，一般常用的球拍基本上都是<font face="Times New Roman">2U-4U</font>，
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="79" unitname="克">
        <font face="Times New Roman">79</font>克
       </st1:chmetcnv>以下的一般都叫做超轻拍，主要是设计给女性，或有特殊需要的球友。而
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="95" unitname="克">
        <font face="Times New Roman">95</font>克
       </st1:chmetcnv>以上的一般都是金属拍，主要是给以打羽毛球为健身手段而不愿在器材上花费过多的人。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>球拍的重量决定了挥拍速度。使用同样的挥拍力量，越轻的球拍可以产生越高的挥拍速度。简单来说，越轻的球拍使用起来越灵活。但是球拍并不是越轻越好的，因为越轻的球拍就越不稳定，需要越多的力量保持其运动轨迹。重一些的拍子在挥动时可以带有更多的动能，击球瞬间可以产生更大的势能。这就是为什么很多进攻型的拍子头都会比较重的原因。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>球拍的平衡点决定了一支球拍的重量分部情况。目前市场上的很多球拍都已经是头重型的了，头重型的球拍在挥动时可以更加的稳定，而平衡型球拍更灵活一些。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>球拍的选择是非常个性化的，没有任何人可以说某种球拍的某种特性就一定强过另一种。选择球拍可以参考一些专业意见，但最终如何选择还是要由自己来决定。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">YONEX</font>球拍特点：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">NS</font>系列<font face="Times New Roman"> NS</font>系列目前成员有<font face="Times New Roman">NS6000</font>，<font face="Times New Roman">NS7000</font>，<font face="Times New Roman">NS8000</font>。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">NS6000</font>的拍杆较软，带有<font face="Times New Roman">LSC</font>减震系统，是<font face="Times New Roman">YONEX</font>于<font face="Times New Roman">2006</font>年推出的专为女性设计的球拍。该拍拍身较柔软，<font face="Times New Roman">ISO</font>（小平头）拍面，适合女性使用。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">NS7000</font>，此拍是为中高级业余选手设计的。采用
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="8" unitname="mm">
        <font face="Times New Roman">8mm</font>
       </st1:chmetcnv>粗杆，杆身弹性很好，拍头采用破风设计，<font face="Times New Roman">ISO</font>中型拍面，用于防守时非常轻松。平抽挡能力低于<font face="Times New Roman">NS8000</font>，<font face="Times New Roman">MP-100</font>等。由于平衡点适中，驱动轻松，所以拉后场球比较容易。杀球威力与<font face="Times New Roman">TI-10,MP-100</font>相比略有不足。适合控球型选手。此拍曾被国家队混双世界冠军高凌所选用。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">NS8000</font>，此拍是目前纳米系列中销量很大的型号。目前销量甚至要超过最新款的NS-9000。拍框<font face="Times New Roman">10</font>点<font face="Times New Roman">2</font>点位以及拍杆顶端采用了<font face="Times New Roman">C60(</font>弗拉伦<font face="Times New Roman">)</font>填充的纳米材料。
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="7" unitname="mm">
        <font face="Times New Roman">7mm</font>
       </st1:chmetcnv>细杆，爆发力极好。摒弃了传统的吹气管工艺而采用了发泡材料成型的制作方法，使拍框稳定性更好，击球时落点非常准确。采用了单向线孔设计，使球拍受力更加均匀，更耐用。因其弹性出色，拉球比较省力。均衡的设计使此拍处理网前球轻松自如，用于双打时，<font face="Times New Roman">NS8000</font>平抽挡出球的速度比<font face="Times New Roman">NS7000</font>要快。虽然是轻量化设计，但在<font face="Times New Roman">YONEX</font>球拍坐标中，<font face="Times New Roman">NS8000</font>进攻能力以极微小差别仅低于<font face="Times New Roman">MP-100</font>。因其拍头较轻，连续进攻能力很强，在业余选手中此拍比<font face="Times New Roman">MP-100</font>更受欢迎，销量很大。</font></p> 
     <p><font size="3">NS9000，最新款重型武器。拍头明显重于NS8000。9000的出现将MP-100赶下了进攻王者的宝座。分为S/X两款分别对应硬和超硬两种中杆硬度。8mm粗杆拍柄加长，想要用好NS9000确实需要一些力量的支持。同样采用发泡成型的制作方法。新的线孔位置，将球拍击球甜区略微上移。ELASTIC TI的使用是拍框的稳定性和弹性都有不小的进步。关于此拍更详细的内容，可参考本论坛steven_gu所作的“NS-9000使用体会”一文。</font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">AT</font>系列
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">AT</font>系列是<font face="Times New Roman">TI</font>系列高端拍升级后的产品。拍框底部采用了传统的盒式结构，而上部则采用了创新的<font face="Times New Roman">ARMORTEC</font>技术。<font face="Times New Roman">ARMORTEC</font>技术最大的特点就是强度高，并带有钛金属条配重。在加强了拍框<font face="Times New Roman">12</font>点位强度的同时也将球拍的中心向<font face="Times New Roman">12</font>点位移动，使进攻更加凌厉。<font face="Times New Roman">AT</font>系列拍身都采用了轻量化设计，在保持了拍头足够重的前提下使整拍重量只有<font face="Times New Roman">3U</font>，<font face="Times New Roman">4U</font>。专业选手使用此拍实测时杀球速度可以有<font face="Times New Roman">5</font>％的提高。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">AT700</font>，<font face="Times New Roman">2003</font>年诞生，在<font face="Times New Roman">2004</font>年遍地开花，<font face="Times New Roman">2005</font>年几乎是言必谈<font face="Times New Roman">700</font>了。此拍因为有大量的优秀选手选用，所以几乎成了业余中高级选手购拍的首选。就连国家队内多年使用<font face="Times New Roman">CAB20</font>的夏煊泽也已经换成了<font face="Times New Roman">AT700</font>了。<font face="Times New Roman">AT700</font>的杆身很硬，头很重，进攻能力极强，拍框采用盒式结构加<font face="Times New Roman">ARMORTEC</font>钛装甲配重，稳定性很好，强度极高，可以承受很高的拍线拉力，深受专业选手的喜爱。驱动这样的球拍需要较强的腕力。如果力量不足，可以考虑用<font face="Times New Roman">NS8000</font>代替。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">AT800</font>，世界著名双打选手拉斯姆森用的就是<font face="Times New Roman">AT800</font>中的进攻型（<font face="Times New Roman">OFFENSIVE</font>）。而另一位著名双打选手西吉特使用的是防守型（<font face="Times New Roman">DEFENSIVE</font>）。进攻型的<font face="Times New Roman">AT800</font>包括了<font face="Times New Roman">AT700</font>所有的特点，而且<font face="Times New Roman">800</font>比<font face="Times New Roman">700</font>还要硬一些。由于球拍的<font face="Times New Roman">KICKPOINT(</font>弯折点<font face="Times New Roman">)</font>不同，<font face="Times New Roman">AT800</font>的平抽挡速度更快，更精准。<font face="Times New Roman">800</font>进攻型杀球的威力也要比<font face="Times New Roman">700</font>略微大一点点。<font face="Times New Roman">AT800/OF</font>和<font face="Times New Roman">DE</font>是非常适合双打的一对球拍。也是目前高端拍中唯一的一对专为双打而设计的球拍。性能非常的优异。是喜爱双打的业余爱好者首选。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">MP</font>系列
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">MP</font>系列是<font face="Times New Roman">YONEX</font>产品线最全面的一个系列。从进攻性最强的<font face="Times New Roman">MP100</font>到柔软舒适的<font face="Times New Roman">MP23</font>一应俱全。该系列产品最大的特点就是拍框上带有<font face="Times New Roman">muscle power</font>弧形设计。<font face="Times New Roman">Muscle power</font>最主要的作用就是降低拍线张力对线孔边缘的压力，减少较高磅数对球拍的伤害，并在拉线厚较长的一段时间内保持相对较稳定的线床张力。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">MP100</font>，<font face="Times New Roman">2000</font>年<font face="Times New Roman">YONEX</font>推出的产品。红＋黑的涂装非常惹眼。该产品设计定位就是进攻。是一把除了进攻还是进攻的球拍。拍框采用加钛设计，强度高，稳定性好，<font face="Times New Roman">MUSCLE POWER</font>技术的使用更保持了线床张力的持久，平衡的设计使球员可以在连续进攻中节省不少的体力。添加<font face="Times New Roman">U Ti</font>的<font face="Times New Roman"> 
        <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="8" unitname="mm">
         8mm
        </st1:chmetcnv></font>中杆非常硬，弹性极好，但是因为此拍只适合于爆发力很好的进攻型球员，所以在业余选手中选用不多。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">MP99,</font>世界一号男单选手林丹在换用<font face="Times New Roman">AT700</font>之前使用的就是这个型号。<font face="Times New Roman">MP99</font>的亮黄色外观非常讨人喜欢，尤其是讨女生的喜欢。所以有很长的一段时间，国家队女队中几乎是一片香蕉黄。与<font face="Times New Roman">MP100</font>类似，<font face="Times New Roman">MP99</font>也是<font face="Times New Roman">3</font>、<font face="Times New Roman">9</font>点加钛的设计。
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="7" unitname="mm">
        <font face="Times New Roman">7mm</font>
       </st1:chmetcnv>的细杆同样带有了<font face="Times New Roman">U Ti</font>，因拍杆细了<font face="Times New Roman">1</font>毫米，所以比<font face="Times New Roman">MP100</font>要略软一些。虽然当年此拍风靡一时，但是因为近一段时间与<font face="Times New Roman">MP99</font>球拍特点类似的新款球拍大量涌现，现时的<font face="Times New Roman">99</font>已经不再吃香了。想要购买<font face="Times New Roman">MP99</font>的人不妨试试<font face="Times New Roman">NS7000</font>。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">MP88</font>，<font face="Times New Roman">peter gade</font>曾经使用这把球拍很长时间。现在已经更换为<font face="Times New Roman">AT700</font>了。<font face="Times New Roman">MP88</font>的拍杆中也使用了<font face="Times New Roman">U Ti</font>，保持了<font face="Times New Roman">MP</font>高端拍一贯的高弹性。<font face="Times New Roman">MP88</font>拍杆比<font face="Times New Roman">MP99 100</font>要软一些，发力相对容易一些。拍头较重，拍面比较稳定。是一把性能出色非常适合业余爱好者使用的球拍。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">MP66</font>，这把球拍的风格与<font face="Times New Roman">NS6000</font>有些类似。色彩也比较相似，都很时尚。只是没有<font face="Times New Roman">NS6000</font>那么多的高科技。头轻型的<font face="Times New Roman">MP66</font>在使用中非常的灵活，深受女性球友的欢迎。此拍弹性适中，用于双打时是一把很好的防守拍。</font></p> 
     <p>&nbsp;</p> 
     <p>&nbsp;来自：http://www.shbc.cn/dispbbs.asp?boardID=307&amp;ID=40224&amp;page=1</p> 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201409.html" title="permalink">2008-05-19 16:06</a> 狼爱上狸 阅读(412) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201409.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=201409">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=201409">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl03_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/19/201408.html">羽毛球拍手胶选购</a></h2> 
     <p><font size="3">手胶（柄皮）<font face="Times New Roman">:
        <o:p></o:p></font></font></p> 
     <p><font size="3">手胶是缠在球拍握把上用以提高摩擦力的物品的统称。目前主要分两类，<font face="Times New Roman">PU</font>手胶和毛巾手胶。早起曾经使用过的真皮手胶现在已经基本退出市场。只有个别款式的球拍原配的柄皮还在使用真皮制品。与拍线和球之间的关系类似，手胶是和球员双手关系最密切的。羽毛球运动需要很多手指，手腕的细腻动作，一根合适的手胶可以及时准确的将击球后的感觉反馈给球员的手部。
       <o:p></o:p></font></p> 
     <p><font size="3">一根好的手胶不但可以提供适当的阻尼使球拍握的更牢，还可以带给球员柔软舒适的手感，吸收打球时球员手部的汗水使球员保持手部干燥不易打滑。<font face="Times New Roman">PU</font>手胶因其较长的使用寿命，不易滋生细菌，吸汗后手感的保持和低廉的价格而深受广大业余爱好者的欢迎。毛巾胶虽然价格相对较贵并且使用寿命断，但因其手感柔软，吸汗能力强还是有很多人坚持使用。
       <o:p></o:p></font></p> 
     <p><font size="3">一条好的<font face="Times New Roman">PU</font>手胶应该相对耐用，阻尼适当，吸汗抗水能力强，抗菌，不产生异味。一条好的毛巾胶应该不掉色，不掉毛，圈绒较粗壮，薄厚适中，吸汗后不僵硬，不起球。
       <o:p></o:p></font></p> 
     <p><font size="3">使用手胶时应在保证称手，适当柔软的前提下尽可能的薄。过厚（过粗）的手胶会使手部僵硬，影响技术的发挥。
       <o:p></o:p></font></p> 
     <p><font size="3">选择手胶的三要素：类型（毛巾还是<font face="Times New Roman">PU</font>），尺寸（薄或厚），阻尼（该特点主要针对<font face="Times New Roman">PU</font>手胶的黏性）
       <o:p></o:p></font></p> 
     <p><font size="3">使用手胶的几种方法：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">1</font>、在原配柄皮上加<font face="Times New Roman">PU</font>手胶。目前国内市场的各品牌球拍最常见的尺寸是周长
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="86" unitname="mm">
        <font face="Times New Roman">86mm</font>
       </st1:chmetcnv>的握把。该尺寸等同于<font face="Times New Roman">YY G4</font>的粗细。在缠新的<font face="Times New Roman">PU</font>手胶上去的时候，尽量不要撕掉拍柄的原配热缩膜（目前只有<font face="Times New Roman">YY</font>用热缩膜包装）。如果是普通的拍柄包装，则需在取下包装物后加缠一层<font face="Times New Roman">UNDERLAP</font>。<font face="Times New Roman">UNDERLAP</font>弹性很大，强度也不错，吸水性强，是非常好的衬垫物。如果没有<font face="Times New Roman">UNDERLAP</font>，也可以用一层保鲜膜代替。只是手感会稍差一些。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">2</font>、拆掉原配柄皮后加缠毛巾胶。这样做是为了保持球拍合理的尺寸。因为毛巾胶比较厚，不拆除原配柄皮直接加缠毛巾胶会导致拍柄过粗，影响水平发挥。在缠毛巾胶之前，一定要使用<font face="Times New Roman">UNDERLAP</font>保护拍柄。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">3</font>、拆除原配柄皮后用<font face="Times New Roman">PU</font>手胶调整握把粗细。有很多球友在不同季节喜欢换用不同类型的手胶。夏天用毛巾胶，冬天用<font face="Times New Roman">PU</font>手胶。这种做法比较符合上海的季节特点，但是手胶的尺寸比较难控制。所以一般都需要去除原配柄皮，然后重新以<font face="Times New Roman">PU</font>柄皮来调整整个握把的粗细。在需要用毛巾胶的时候，只要去除所有的<font face="Times New Roman">PU</font>手胶即可，等到冬季来临，再按原来习惯缠回<font face="Times New Roman">PU</font>手胶。
       <o:p></o:p></font></p> 
     <p><font size="3">市场上的手胶品种非常多，比较优秀的品牌低价位的有<font face="Times New Roman">ALPHA</font>，中极星，中高价位的<font face="Times New Roman">KIMONI, YONEX</font>。其中<font face="Times New Roman">YONEX</font>的毛巾胶手感较好。为世界各国专业运动员所喜爱。美国品牌<font face="Times New Roman">FORTEN</font>（华腾）虽然进入中国市场很晚，但是其手胶色彩鲜艳，价格低廉，颇受时尚球友的喜爱。KIMONI(金万利）手胶是制作手胶起家的专业公司，与YONEX不同的是，KIMONI手胶是全日本制造。品质极佳，是目前为止唯一一个手感，耐用性都要超越YONEX的产品。不过用好东西总要有点代价，其薄手胶KGT100价格要高于目前YONEX 102C的售价。其实KIMONI的手胶在原产国的价格与YONEX相比并不高，只是YONEX的手胶在国内卖的太廉价了。</font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3">手胶简介：
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman"><font size="3">YONEX
        <o:p></o:p></font></font></p> 
     <p><font size="3"><font face="Times New Roman">AC-102</font>，销量最大的<font face="Times New Roman">YONEX</font>手胶。<font face="Times New Roman">PU</font>材料制造。标准长度<font face="Times New Roman">1100</font>毫米。实际长度大约为<font face="Times New Roman">1150</font>毫米左右。<font face="Times New Roman">PU</font>材料的表层有一层<font face="Times New Roman">YONEX</font>专门开发的柔软覆膜，表层材料黏性好，吸汗能力强，手感舒适。因其表层材料是覆盖在带基上的，一旦表层材料磨穿，手感会下降较快。该手胶耐用性一般，在高强度使用条件下，表面覆膜经常会大片脱落，这种情况属于产品特征，并不代表质量有问题。</font></p> 
     <p><font size="3"><font face="Times New Roman">AC-104EX</font>，聚氨酯＋橡胶制造。标准长度<font face="Times New Roman">1100</font>毫米。在手胶的中间带有一条<font face="Times New Roman">5</font>毫米宽<font face="Times New Roman">2</font>毫米高的发泡材料制造的长条。缠好以后会显出一条一条的龙骨，使球拍更易于掌握。因为这种手胶加入了橡胶材料，故该手胶价格昂贵，但是此款手胶耐用性较好，也有一部分用户坚持使用。</font></p> 
     <p><font size="3">KIMONI</font></p> 
     <p><font size="3">世界第一手胶品牌，其性能有口皆碑。</font></p> 
     <p><font size="3">KGT－100 无孔薄手胶。PU材料，标长1050mm。颜色丰富（19色），手感极佳。各方面性能均超越YONEX产品。</font></p> 
     <p><font size="3">最大特点：耐用，手感保持时间长。</font></p> 
     <p><font size="3">KGT－170 我所用过的性能最出色的厚手胶，难怪其包装外面印着“世界最强”，我觉得是当之无愧的。如果非要说有缺点，那就只能说他的价格不够“实惠”了。不过好东西从来就没实惠过，可以理解的。如果有条件，购买一支高端球拍时，可以当场将原配柄皮撕掉，换装此产品。其优异的性能绝不会令你失望。</font></p> 
     <p><font size="3">最大特点：弹性保持时间长，隔离性好，对拍柄保护能力强。相同情况下，此产品弹性保持能力比最接近它的产品要长3－5倍。</font></p> 
     <p><font size="3">该品牌其他型号虽然很多，但所用原料相同，带有龙骨的产品价格要低于YONEX AC104EX。还有打孔的产品以增加透气性，需要注意的是，打孔的产品最好先做隔水处理后再使用，不推荐手汗多的人使用打孔手胶。</font></p> 
     <p><font size="3">值得一提的是，现在只有此品牌还有传统的真皮手胶。如果你心爱的老款名拍手胶破损，可以用此来替换了。</font></p> 
     <p><font size="3">KARAKAL</font></p> 
     <p><font size="3">该品牌的厚手胶手感良好，虽然比不过世界第一的KIMONI KGT-170，但价格实惠的多，也是值得推荐的。</font></p> 
     <br /> 
     <br /> 来自：http://www.shbc.cn/dispbbs.asp?boardID=307&amp;ID=40224&amp;page=1 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201408.html" title="permalink">2008-05-19 16:04</a> 狼爱上狸 阅读(2201) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201408.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=201408">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=201408">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl04_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/19/201406.html">羽毛球拍线选购</a></h2> 
     <p><font size="3">羽毛球拍线：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>羽毛球拍线是羽毛球运动中非常重要的一种耗材。球员每一次正确击球动作唯一会接触到羽毛球的就是拍线了。每一次击球质量的感觉将直接由拍线传递给球拍然后到达球员的手上。根据球员当前的打球风格以及打球的水平，选择适合的拍线及拍线拉力是非常重要的。拍线的基本特点有耐用性，弹性，击球声音，控球能力和吸震性。生产厂家会将不同拍线的性能特点以<font face="Times New Roman">5</font>边形的方式表现在该拍线的包装上。选择自己所需要的指数最高的拍线就可以了。举例，如果追求耐用性，那么就选择耐用指数最高的拍线。如果追求高弹性，则需选择弹性直属最高的线。一般来说，冬天应该用略粗一点的拍线，因为冬天气温低，拍线变的相对较脆，很容易断裂。夏天拍线的选择可以随意一些。<font face="Times New Roman"> </font>相同材质情况下，越粗的线就越结实（耐用），越细的线弹性就越大，越不耐用。目前高档球线中最耐用的拍线是<font face="Times New Roman">YONEX BG 65，以及ASHAWAY（傲狮威）的A65(RALLY系列)。注意，ASHAWAY的中文名是傲狮威，而不是雅沙维。品牌名称问题最后再讲。</font></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>拍线拉力将直接影响到球拍的使用性能，一般来说，击球点越准，力量越大，可以使用的拍线拉力就越高。随着拍线拉力的提高，羽毛球拍上甜区的尺寸也快速的缩小，如果只是单纯的力量大而击球点准确度不够，高拉力拍线将会把每一次偏离甜区的击打所产生的所有震动通过球拍直接传递到球员的手腕、前臂，使球员受到慢性的隐性伤害。这种伤害是在相对较长的一段时间内所积累下来的。起初症状并不明显，但到达一定程度后，将会立刻凸显出来。具体症状为手腕内有撕裂感剧痛，手无法大力紧握等。一旦发现自己的前臂具有这种特征，就应该减少打球时间，运动后采取一定的养护措施，降低拍线拉力，或更换较软球拍。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3">判断是否已受到这种伤害可用以下方法。持拍手自然端平，大臂和小臂呈<font face="Times New Roman">90</font>度夹角。此时，小臂应指向身体的一侧。手掌外翻对准自己面对的方向，另一只抓住自己的持拍手，慢慢加力向内扭转（逆时针方向）。如果达到一定角度以后还只是单纯的自然疼痛（因肌肉、韧带、关节等达到极限位置产生的不强烈的隐性疼痛），则是手腕还处于健康状态。如果扭转到一定程度后感觉到手腕内的撕裂性的疼痛或针刺性的疼痛，则是已经受伤了。如果轻轻一扭就已经产生了强烈的疼痛，则是伤的较重了。
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman"><font size="3">
        <o:p></o:p></font></font></p> 
     <p><font size="3">随着拍线拉力的提高，拍线的弹性将快速降低，寿命也急速缩短。一些使用高拉力拍线的业余高手们即使用了<font face="Times New Roman">BG65</font>这样极高耐用性的线，<font face="Times New Roman">1</font>－<font face="Times New Roman">2</font>周内也会断线。而国家羽毛球队运动员甚至每<font face="Times New Roman">1</font>－<font face="Times New Roman">2</font>天就会断线一次。当拍线拉力到达一定程度时，所有弹性特征都会消失的无影无踪。这也是为什么国家队员一般都只选择高耐用性的线（如<font face="Times New Roman">BG65,65TI</font>）而不考虑高弹线的原因了。过高的拍线拉力会严重影响球拍的使用寿命，也会使球拍丧失保修资格。一般业余爱好者应该根据自己的能力或参考比较专业的建议来选择适合自己的拍线拉力。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">SHBC(</font>上海羽毛球网<font face="Times New Roman">)</font>推荐拍线拉力：
       <o:p></o:p></font></p> 
     <p><font size="3">初学者<font face="Times New Roman"> </font>男性<font face="Times New Roman">20/21 </font>女性<font face="Times New Roman">19/20</font>，中级水平<font face="Times New Roman"> </font>男性<font face="Times New Roman">23/24 </font>女性<font face="Times New Roman">22/23</font>，高级水平<font face="Times New Roman"> </font>男性<font face="Times New Roman">25</font>＋<font face="Times New Roman"> </font>女性<font face="Times New Roman"> 24</font>＋
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3">知名羽毛球拍线品牌有：<font face="Times New Roman">ASHAWAY</font>（雅沙维），<font face="Times New Roman">GOSEN(</font>高神<font face="Times New Roman">), MIZUNO</font>（美津浓）<font face="Times New Roman">, YONEX</font>（尤尼克斯）
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3">品牌简介：
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman"><font size="3">YONEX
        <o:p></o:p></font></font></p> 
     <p><font size="3"><font face="Times New Roman">BG65</font>，高档拍线中最耐用的一根，同类产品至今无人能出其右。进攻性能良好。控球型球员也可采用。吸震能力始终。<font face="Times New Roman">0.70</font>毫米的线径
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman" size="3"></font></p> 
     <p><font size="3"><font face="Times New Roman">BG65TI</font>，在<font face="Times New Roman">BG65</font>的基础上加<font face="Times New Roman">TI</font>增加了弹性<font face="Times New Roman">,</font>牺牲了一部分的耐用性。击球音略好。提高了线的强度，更适合暴力攻击型选手。吸震能力与<font face="Times New Roman">65</font>相同。<font face="Times New Roman">0.70</font>毫米的线径
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman">BG70PRO</font>，与<font face="Times New Roman">65TI</font>弹性相仿，击球声音与<font face="Times New Roman">65</font>类似。也很耐用。因为外皮采用了卵形纤维，所以耐拉能力极强，保持拍线拉力的性能非常好，但因吸震性能一般而使手感略微偏硬。<font face="Times New Roman">0.70</font>毫米的线径。
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman" size="3"></font></p> 
     <p><font size="3"><font face="Times New Roman">BG80</font>，采用卵形纤维外皮，内包<font face="Times New Roman">VECTRAN</font>纤维，具有很高的反弹性和良好的爆发力，适合大力抽球，深受双打选手喜爱。耐用度一般，但是声音很好。<font face="Times New Roman">0.68</font>毫米线径。为了保证<font face="Times New Roman">VECTRAN</font>纤维的效果，最好降低拉力<font face="Times New Roman">1</font>－
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="2" unitname="磅">
        <font face="Times New Roman">2</font>磅
       </st1:chmetcnv>使用。
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman" size="3"></font></p> 
     <p><font size="3"><font face="Times New Roman">BG85</font>，控球线，表皮非常粗糙，只有<font face="Times New Roman">0.67</font>毫米线径。耐用性一般，吸震性能很好，手感柔软。击球音很好听。弹性超过<font face="Times New Roman">BG80</font>。因此线同样采用了<font face="Times New Roman">VECTRAN</font>纤维而线径更细，所以要降低拉力<font face="Times New Roman">2</font>－
       <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="3" unitname="磅">
        <font face="Times New Roman">3</font>磅
       </st1:chmetcnv>使用。
       <o:p></o:p></font></p> 
     <p><font face="Times New Roman" size="3"></font></p> 
     <p><font size="3"><font face="Times New Roman">BG68TI</font>，综合性能非常优异的一根球线。各方面的能力都比较出色。是目前市场上可见的弹性最高的<font face="Times New Roman">YONEX</font>拍线。击球音清脆响亮，吸震性控制力都很出色。<font face="Times New Roman">0.68</font>毫米线径。深受业余球友的欢迎。耐用性一般，冬天低温很容易变脆断线，尽量避免低温使用。此线弹性很大，但是保持张力性能很一般，掉磅较快。为了保持一定的张力，需频繁更换。印尼双打名将西吉特的选择。</font></p> 
     <p><font size="3">ASHAWAY 傲狮威</font></p> 
     <p><font size="3">ASHAWAY曾经叫做雅沙维，这是中国总代所用的名字且已经注册了中文商标。但随着ASHAWAY公司亲自进入中国市场，原雅沙维品牌持有人拒绝放弃ASHAWAY产品及商标带给其的经济效益，将产品转为由其他厂家OEM。美国ASHAWAY公司只好责令其禁止使用ASHAWAY商标但对其中文名称无能为力。所以，“雅沙维”这个品牌已经不再是美国原产产品了。而真正的ASHAWAY中文名称已经改为傲狮威，习惯使用ASHAWAY产品的人购买时要注意一下品名和商标。</font></p> 
     <br /> 
     <br /> 来自：http://www.shbc.cn/dispbbs.asp?boardID=307&amp;ID=40224&amp;page=1 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201406.html" title="permalink">2008-05-19 16:03</a> 狼爱上狸 阅读(636) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201406.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=201406">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=201406">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl05_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/19/201405.html">羽毛球鞋选购</a></h2> 
     <p><font size="3">所有的羽球爱好者都要面对一个相同的问题：我到底该买什么样的器材？为什么要买这个器材？这个器材对这项运动有多重要？下面我按照我个人认为的商品重要性进行了排列并做了简单的说明。希望这篇羽球用品选购指南能对所有正在犹豫不决的羽球爱好者有所帮助。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>因水平有限，未能列出全部羽球用品。日后会逐渐添加。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3">羽毛球鞋：
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>很多人都没有认识到，一双好的羽毛球鞋对这项运动到底有多重要。随着球员在场上不停的快速移动，双脚要承受平时几倍的压力，伴随着每一次的启动，球员的双脚要作出扭，转，跳跃，急停，换向等等极高机动性的动作。这所有的一切都是靠羽毛球鞋的支撑才得以完成。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>有别于普通运动鞋，羽毛球鞋是专为羽毛球运动特点而设计的。较薄的鞋底，很强的侧面支撑能力使双脚尽可能的靠近地面。这种设计在保证了允许踝关节快速的弯曲，双脚运动方向频繁转变的前提下尽可能低的降低了双脚受伤的可能性。轻量化的设计可以使双脚移动速度更快，专门的鞋底材料可以保证双脚在球场上的抓地力。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>在羽毛球运动中，我们对下半身所施加的压力可以由一双羽毛球鞋清晰的显现出来。一双高质量的羽毛球鞋，在高手的使用下只有<font face="Times New Roman">3</font>－<font face="Times New Roman">6</font>个月的有效寿命。此时的羽毛球鞋鞋底已经快要磨穿了，鞋垫也会磨透，高强度人造材料的鞋面，也会因为运动中所承受巨大压力而开裂，破损。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>选择羽毛球鞋一定要仔细，确保选择了一双适合双脚形状及尺寸的，穿着舒适的球鞋。</font></p> 
     <p><font size="3">选择羽毛球鞋一定要比平常的鞋略大一点，不然跑动起来脚会包的很难受。</font></p> 
     <p><font size="3">羽毛球鞋选择时应注意前松侧紧。</font></p> 
     <p><strong><font color="#0000ff" size="4">侧紧，为了避免侧滑，防止扭伤；前松，上网时可起到缓冲作用。</font></strong></p> 
     <p><font size="3">一般来说，羽毛球鞋要比平常的鞋大半码到一码，不过记得要穿专业的羽毛球袜，一双袜子半码，留半码给脚，刚刚好。</font></p> 
     <p><font size="3">激烈的羽毛球运动中双脚的血液循环要比平时快的多，双脚充血也较平常严重，别说小了，就是试穿的时候正好合适下场以后都有可能觉得紧。</font></p> 
     <p><font size="3">很多羽毛球爱好者总是觉得鞋买大了一码以后会非常别扭，每次买鞋都要考虑买正好甚至略小的，这是非常错误的。</font></p> 
     <p><font size="3">1、我们平常不会穿专门的羽毛球袜去试鞋，试出来的感觉本身就不够准确。</font></p> 
     <p><font size="3">2、鞋头不宽松的话，上网时极有可能会顶到最长的脚趾，严重的还会使脚趾甲受损。</font></p> 
     <p><font size="3">球鞋尺寸大了，有可能走路会觉得别扭，甚至会出现上楼梯踢台阶的现象，这是因为我们的大脑已经习惯了鞋+脚的尺寸，在做上楼梯这个动作时，大脑发令总是以我们常用鞋码的尺寸来作为抬腿出脚距离的标准，这是为了最大限度节省体力，是本能。</font></p> 
     <p><font size="3">但羽毛球步法和上楼梯完全不是一回事，与平时走路也完全不是一回事。这也是为什么尽量到场馆以后才换鞋的另一个原因。</font></p> 
     <p><font size="3">注意不要穿厚底鞋(如篮球鞋)上场打羽毛球。厚底鞋会把脚抬离地面过高，导致严重的意外扭伤，甚至会带来后遗症，如习惯性扭伤等。这种运动伤害会在今后的很长一段时间影响你的羽毛球水平。
       <o:p></o:p></font></p> 
     <p><font size="3"><font face="Times New Roman"></font>常见的不错的羽毛球鞋品牌有<font face="Times New Roman">MIZUNO,YONEX</font>。国产品牌如<font face="Times New Roman">VICTOR</font>，<font face="Times New Roman">KASON</font>等因技术原因暂时无法与国外品牌抗衡，但因其价格低廉，也是不错的选择。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">YONEX</font>羽毛球鞋产品特点简介：
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">YONEX</font>的高级球鞋都带有专利<font face="Times New Roman">POWER CUSHION</font>动力垫。<font face="Times New Roman">Power cushion</font>的减震能力和弹性极好，一个生鸡蛋从
       <st1:chmetcnv w:st="on" tcsc="1" numbertype="3" negative="False" hasspace="False" sourcevalue="2" unitname="米">
        两米
       </st1:chmetcnv>高度下落掉在动力垫上不会损坏，还可以跳起
       <st1:chmetcnv w:st="on" tcsc="1" numbertype="3" negative="False" hasspace="False" sourcevalue="1" unitname="米">
        一米
       </st1:chmetcnv>。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">99LOW </font>鞋面由柔韧的高级<font face="Times New Roman">PU</font>合成皮革加双层透气网制成。超轻量<font face="Times New Roman">EVA</font>中底（<font face="Times New Roman">GLITE</font>）带有专利<font face="Times New Roman">POWER CUSHION</font>材料制成的动力垫，鞋垫下部带有<font face="Times New Roman">TPU</font>稳定片防止足弓变形。高强度石墨连接桥，外装爪型<font face="Times New Roman">TPU</font>支撑片（<font face="Times New Roman">lateral claw</font>）<font face="Times New Roman"> </font>鞋底是防滑耐磨的橡胶大底。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">
        <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="99" unitname="m">
         99M
        </st1:chmetcnv> </font>同上
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">89MG </font>高级<font face="Times New Roman">PU</font>合成皮革，聚酯透气网，护踝柔韧合成皮。<font face="Times New Roman">EVA</font>中底。耐磨，防滑大底。立体石墨支撑片。防扭系统。
       <o:p></o:p></font></p> 
     <p>
      <o:p>
       <font face="Times New Roman" size="3"></font>
      </o:p></p> 
     <p><font size="3"><font face="Times New Roman">
        <st1:chmetcnv w:st="on" tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="56" unitname="C">
         56C
        </st1:chmetcnv> </font>柔韧<font face="Times New Roman">PU</font>（合成皮），脚跟动力垫<font face="Times New Roman">(POWER CUSHIO)</font>，<font face="Times New Roman">EVA</font>中底。耐磨橡胶外底。</font></p> 
     <p><font size="3">06年新款的90M 90L采用了圆鞋底，这种设计可使脚底受力更均匀，减轻脚底局部区域的压力，使得穿着，使用更舒适。新品价格略高，但还是值得一试。<br /> <br /> 来自：http://www.shbc.cn/dispbbs.asp?boardID=307&amp;ID=40224&amp;page=1</font></p> 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201405.html" title="permalink">2008-05-19 16:01</a> 狼爱上狸 阅读(193) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/19/201405.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=201405">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=201405">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl06_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/08/199314.html">acegi,IBM的Acegi Security System（4） </a></h2> 
     <p>2008 年 3 月 20 日</p> 
     <blockquote>
      Bilal Siddiqui 将继续在他的 
      <a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/views/java/articles.jsp?view_by=search&amp;search_by=acegi" cmimpressionsent="1">系列文章</a> 中展示如何使用 Acegi 保护 Java64Server Faces (JSF) 应用程序。配置 JSF 和 Acegi，让它们在 servlet 容器中协作，探索 JSF 和 Acegi 组件如何彼此协作。
     </blockquote>
     <!--start RESERVED FOR FUTURE USE INCLUDE FILES-->
     <!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters -->
     <!--end RESERVED FOR FUTURE USE INCLUDE FILES--> 
     <p>本 <a href="http://www.ibm.com/developerworks/cn/views/java/articles.jsp?view_by=search&amp;search_by=acegi" cmimpressionsent="1">系列</a> 的前 3 部分讨论了如何使用 Acegi Security System 保护 Java 企业应用程序：</p> 
     <ul> 
      <li><a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/" cmimpressionsent="1">第 1 部分</a> 解释了如何使用 Acegi 的内置过滤器实现一个简单的基于 URL 的安全系统。 </li>
      <li><a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/" cmimpressionsent="1">第 2 部分</a> 展示了如何编写访问控制策略、将其存储在 LDAP 目录服务器中，以及配置 Acegi 与 LDAP 服务器交互，从而实现访问控制策略。 </li>
      <li><a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi3/" cmimpressionsent="1">第 3 部分</a> 展示了如何在企业应用程序中使用 Acegi 保护对 Java 类实例的访问。 </li> 
     </ul> 
     <p>第 4 部分将讨论如何使用 Acegi 保护在 servlet 容器中运行的 JavaServer Faces (JSF) 应用程序。本文首先解释 Acegi 针对此目标提供的特性，并澄清一些关于使用 Acegi 和 JSF 的常见误解。然后提供一个简单的 web.xml 文件，可以用来部署 Acegi，从而保护 JSF 应用程序。然后深入探讨 Acegi 和 JSF 组件，了解在部署 web.xml 文件和用户访问 JSF 应用程序时所发生的事件。本文最后提供了一个由 Acegi 保护的示例 JSF 应用程序。 </p> 
     <p><a name="section1"><span class="atitle">无需编写 Java 代码即可添加安全性</span></a></p> 
     <p>回顾一下本系列的第一个示例 Acegi 应用程序（请参阅 <a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/" cmimpressionsent="1">第 1 部分</a> 中的 “一个简单 Acegi 应用程序” 一节）。该应用程序使用 Acegi 提供了以下安全特性：</p> 
     <ul> 
      <li>当一个未经验证的用户试图访问受保护的资源时，提供一个登录页面。 </li>
      <li>将授权用户直接重定向到所需的受保护资源。 </li>
      <li>如果用户未被授权访问受保护资源，提供一个访问拒绝页面。 </li> 
     </ul> 
     <p>回想一下，您无需编写任何 Java 代码就能获得这些特性。只需要对 Acegi 进行配置。同样，在 JSF 应用程序中，无需编写任何 Java 代码，也应该能够从 Acegi 实现相同的特性。</p> 
     <p><a name="N100B2"><span class="smalltitle">澄清误解</span></a></p> 
     <p>其他一些作者似乎认为将 Acegi 与 JSF 集成需要 JSF 应用程序提供登录页面（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#resources" cmimpressionsent="1">参考资料</a>）。这种观点并不正确。在需要时提供登录页面，这是 Acegi 的职责。确保登录页面在安全会话期间只出现一次，这也是 Acegi 的职责。然后，经过身份验证和授权的用户可以访问一个受保护资源，无需重复执行登录过程。</p> 
     <p>如果使用 JSF 提供登录页面，将会发生两个主要的问题：</p> 
     <ul> 
      <li>当需要时，没有利用 Acegi 的功能提供登录页面。必须编写 Java 代码实现所有逻辑来提供登录页面。<br /> <br /> </li>
      <li>至少需要编写一些 Java 代码将用户凭证（用户名和密码）从 JSF 的登录页面移交到 Acegi。 </li> 
     </ul> 
     <p>Acegi 的目的是避免编写 Java 安全代码。如果使用 JSF 提供登录页面，则没有实现这一用途，并且会引发一系列其他 JSF-Acegi 集成问题，所有这些问题都源于 “Acegi 是用来提供可配置安全性” 这一事实。如果试图使用 JSF 来完成 Acegi 的工作，将会遇到麻烦。</p> 
     <p>本文余下部分将解释并演示独立于 Acegi 的 JSF 应用程序开发，并在稍后配置 Acegi 以保护 JSF 应用程序 ― 无需编写任何 Java 代码。首先看一下 web.xml 文件，可以部署该文件保护 JSF 应用程序。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section2"><span class="atitle">部署 Acegi 保护 JSF 应用程序</span></a></p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 展示了一个 web.xml 文件（通常称为<em>部署描述符</em>），可以使用这个文件部署 Acegi，从而保护运行在 servlet 容器（比如 Apache Tomcat）中的 JSF 应用程序：</p> 
     <br /> 
     <a name="listing1"><strong>清单 1. 用于部署 Acegi 和 servlet 容器中的 JSF 的 web.xml 文件</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;?xml version=&quot;1.0&quot;?&gt;
            &lt;!DOCTYPE web-app PUBLIC
            &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
            &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;
            &lt;web-app&gt;
            &lt;context-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/acegi-config.xml&lt;/param-value&gt;
            &lt;/context-param&gt;
            &lt;context-param&gt;
            &lt;param-name&gt;javax.faces.STATE_SAVING_METHOD&lt;/param-name&gt;
            &lt;param-value&gt;server&lt;/param-value&gt;
            &lt;/context-param&gt;
            &lt;context-param&gt;
            &lt;param-name&gt;javax.faces.CONFIG_FILES&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/faces-config.xml&lt;/param-value&gt;
            &lt;/context-param&gt;
            &lt;listener&gt;
            &lt;listener-class&gt;
            org.springframework.web.context.ContextLoaderListener
            &lt;/listener-class&gt;
            &lt;/listener&gt;
            &lt;listener&gt;
            &lt;listener-class&gt;
            com.sun.faces.config.ConfigureListener
            &lt;/listener-class&gt;
            &lt;/listener&gt;
            &lt;!-- Faces Servlet --&gt;
            &lt;servlet&gt;
            &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
            &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
            &lt;load-on-startup&gt; 1 &lt;/load-on-startup&gt;
            &lt;/servlet&gt;
            &lt;!-- Faces Servlet Mapping --&gt;
            &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.faces&lt;/url-pattern&gt;
            &lt;/servlet-mapping&gt;
            &lt;!-- Acegi filter configuration --&gt;
            &lt;filter&gt;
            &lt;filter-name&gt;Acegi Filter Chain Proxy&lt;/filter-name&gt;
            &lt;filter-class&gt;
            org.acegisecurity.util.FilterToBeanProxy
            &lt;/filter-class&gt;
            &lt;init-param&gt;
            &lt;param-name&gt;targetClass&lt;/param-name&gt;
            &lt;param-value&gt;
            org.acegisecurity.util.FilterChainProxy
            &lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;/filter&gt;
            &lt;!-- Acegi Filter Mapping --&gt;
            &lt;filter-mapping&gt;
            &lt;filter-name&gt;Acegi Filter Chain Proxy&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
            &lt;/filter-mapping&gt;
            &lt;/web-app&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>注意，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 包含以下标记：</p> 
     <ul> 
      <li>3 个 <code>&lt;context-param&gt;</code> 标记 </li>
      <li>2 个 <code>&lt;listener&gt;</code> 标记 </li>
      <li>1 个 <code>&lt;filter&gt;</code> 标记 </li>
      <li>1 个 <code>&lt;servlet&gt;</code> 标记 </li>
      <li>1 个 <code>&lt;servlet-mapping&gt;</code> 标记 </li>
      <li>1 个 <code>&lt;filter-mapping&gt;</code> 标记 </li> 
     </ul> 
     <p>阅读该文件，了解每个标记在 JSF-Acegi 应用程序中的用途。</p> 
     <p><a name="N10128"><span class="smalltitle">向 Acegi 和 JSF 提供上下文参数</span></a></p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的每个 <code>&lt;context-param&gt;</code> 标记定义一个参数，供 Acegi 或 JSF 在启动或执行期间使用。第一个参数 ― <code>contextConfigLocation</code> ― 定义 Acegi 的 XML 配置文件的位置。</p> 
     <p>JSF 需要 <code>javax.faces.STATE_SAVING_METHOD</code> 和 <code>javax.faces.CONFIG_FILES</code> 参数。<code>javax.faces.STATE_SAVING_METHOD</code> 参数指定希望在客户机还是服务器上存储 JSF 页面-视图状态。Sun 的参考实现的默认行为是将 JSF 视图存储在服务器上。</p> 
     <p><code>javax.faces.CONFIG_FILES</code> 参数指定 JSF 需要的配置文件的位置。JSF 配置文件的详细信息不属于本文讨论的范围（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#resources" cmimpressionsent="1">参考资料</a>，获取涉及该主题的资源链接）。</p> 
     <p><a name="N1015B"><span class="smalltitle">为 Acegi 和 JSF 配置侦听器</span></a></p> 
     <p>现在看一下 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 2 个 <code>&lt;listener&gt;</code> 标记。<code>&lt;listener&gt;</code> 标记定义侦听器类，侦听器类侦听并处理 JSP 或 servlet 应用程序启动和执行期间发生的事件。例如：</p> 
     <ul> 
      <li>启动 JSP 或 servlet 应用程序时，servlet 容器创建一个新的 servlet 上下文。每当 JSP 或 servlet 应用程序启动时，就会触发此事件。<br /> <br /> </li>
      <li>servlet 容器创建一个新的 servlet 请求对象。每当容器从客户机收到一个 HTTP 请求时，此事件就会发生。 <br /> <br /> </li>
      <li>建立一个新的 HTTP 会话。当请求客户机建立一个与 servlet 容器的会话时，此事件就会发生。 <br /> <br /> </li>
      <li>一个新属性被添加到 servlet 上下文、servlet 请求和 HTTP 会话对象。<br /> <br /> </li>
      <li>servlet 上下文、servlet 请求或 HTTP 会话对象的一个现有属性被修改或删除。 </li> 
     </ul> 
     <p><code>&lt;listener&gt;</code> 标记就像一种可扩展性机制，允许在 servlet 容器内部运行的应用程序协同某些事件进行处理。servlet 规范定义了侦听器类为处理事件而实现的一些接口。</p> 
     <p>例如，Spring Framework 实现一个 <code>javax.servlet.ServletContextListener</code> servlet 接口。实现此接口的 spring 类是 <code>org.springframework.web.context.ContextLoaderListener</code>。注意，这是 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 的第一个 <code>&lt;listener&gt;</code> 标记中的侦听器类。 </p> 
     <p>类似地，JSF 实现一个 <code>com.sun.faces.config.ConfigureListener</code> 类，该类实现一些事件-侦听接口。可以在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 的第二个 <code>&lt;listener&gt;</code> 标记中找到 <code>ConfigureListener</code> 类。</p> 
     <p>本文稍后将解释不同的事件-侦听器接口，以及 Acegi 和 JSF 事件-侦听器类内部执行的处理（请参阅 “<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#section4" cmimpressionsent="1">启动 JSF-Acegi 应用程序</a>” 和 “<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#section5" cmimpressionsent="1">处理对受 Acegi 保护的 JSF 页面的请求</a>”）。</p> 
     <p><a name="N101CA"><span class="smalltitle">配置和映射 servlet 过滤器</span></a></p> 
     <p>现在看一下 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 <code>&lt;filter&gt;</code> 标记。在请求的 servlet 处理传入的请求之前，servlet 应用程序使用过滤器对其进行预处理。在请求执行之前，Acegi 使用 servlet 过滤器对用户进行身份验证。</p> 
     <p>请注意 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 <code>&lt;filter&gt;</code> 标记，它的 <code>&lt;filter-class&gt;</code> 子标记指定一个 <code>org.acegisecurity.util.FilterToBeanProxy</code> 类。<code>FilterToBeanProxy</code> 类是 Acegi 的一部分。此类实现一个 <code>javax.servlet.Filter</code> 接口，该接口是 servlet 应用程序的一部分。<code>javax.servlet.Filter</code> 接口有一个 <code>doFilter()</code> 方法，servlet 容器在收到请求时调用该方法。</p> 
     <p>还需注意，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 的 <code>&lt;filter&gt;</code> 标记有另一个子标记 <code>&lt;init-param&gt;</code>。<code>&lt;init-param&gt;</code> 标记指定实例化 <code>FilterToBeanProxy</code> 类所需的参数。可以从 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中看出，<code>FilterToBeanProxy</code> 类只需要一个参数，该参数是 <code>FilterChainProxy</code> 类的一个对象。<code>FilterChainProxy</code> 类表示 <a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi1" cmimpressionsent="1">第 1 部分 1</a> 中讨论的整个 Acegi 过滤器链（请参阅 “安全过滤器” 小节）。<code>FilterToBeanProxy</code> 类的 <code>doFilter()</code> 方法使用 <code>FilterChainProxy</code> 类执行 Acegi 的安全过滤器链。</p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 <code>&lt;filter-mapping&gt;</code> 标记指定调用 Acegi 的 <code>FilterToBeanProxy</code> 的请求 URL。我已经将所有的 JSF 页面映射到 Acegi 的 <code>FilterToBeanProxy</code>。这意味着只要用户试图访问 JSF 页面，<code>FilterChainProxy</code> <code>doFilter()</code> 方法就会自动获得控制权。</p> 
     <p><a name="N10251"><span class="smalltitle">配置 JSF servlet</span></a></p> 
     <p>web.xml 文件中的 <code>&lt;servlet&gt;</code> 标记指定希望从特定 URl 调用的 servlet（在本例中是一个 JSF servlet）。<code>&lt;servlet-mapping&gt;</code> 标记定义该 URL。几乎所有的 JSP 或 servlet 应用程序都包含这两个标记，所以无需再作讨论（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#resources" cmimpressionsent="1">参考资料</a>，获取讨论 servlet 编程的资源链接）。</p> 
     <p>现在，您已经看到，web.xml 文件要部署 Acegi 以保护 JSF 应用程序所需的所有标记。您已经了解了侦听器、过滤器和 servlet 如何相互协作。从这里的讨论中可以看出，如果在 servlet 容器中部署 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 web.xml 文件，Acegi 和 JSF 都试图在两种情形下进行一些处理：</p> 
     <ul> 
      <li>当启动应用程序时 </li>
      <li>当应用程序收到对 JSF 页面的请求时 </li> 
     </ul> 
     <p>接下来的两节解释每种情况中发生的一系列事件。 </p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section4"><span class="atitle">启动 JSF-Acegi 应用程序</span></a></p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#fig1" cmimpressionsent="1">图 1</a> 展示了在 JSF-Acegi 应用程序启动时发生的事件顺序：</p> 
     <br /> 
     <a name="fig1"><strong>图 1. JSF-Acegi 应用程序启动时发生的事件顺序</strong></a>
     <br /> 
     <img height="261" alt="JSF-Acegi 应用程序启动时发生的事件顺序" src="http://www.ibm.com/developerworks/cn/java/j-acegi4/Figure1.gif" width="459" /> 
     <br /> 
     <br /> 
     <br /> 
     <p>详细来讲，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#fig1" cmimpressionsent="1">图 1</a> 显示的事件顺序如下所示：</p> 
     <ol> 
      <li>servlet 容器实例化在 web.xml 文件中配置的所有侦听器。<br /> <br /> </li>
      <li>servlet 容器将 Acegi 的 <code>ContextLoaderListener</code> 注册为一个侦听器类，该类实现 <code>javax.servlet.ServletContextListener</code>接口。<code>ServletContextListener</code> 接口包含两个重要方法：<code>contextInitialized()</code> 和 <code>contextDestroyed()</code>： 
       <ul> 
        <li><code>contextInitialized()</code> 方法在初始化 servlet 上下文时获得控制权。 </li>
        <li>类似地，当应用程序退出时，<code>contextDestroyed()</code> 方法会被调用，并消除 servlet 上下文。 </li> 
       </ul> <br /> </li>
      <li>servlet 容器将 JSF 的 <code>ConfigureListener</code> 注册为另一个侦听器。JSF 的 <code>ConfigureListener</code> 实现许多侦听器接口，比如 <code>ServletContextListener</code>、 <code>ServletContextAttributeListener</code>、 <code>ServletRequestListener</code>，以及 <code>ServletRequestAttributeListener</code>。您已经看到了 <code>ServletContextListener</code> 接口的方法。余下的接口是： 
       <ul> 
        <li><code>ServletContextAttributeListener</code>，它包含 3 种方法：<code>attributeAdded()</code> <code>attributeRemoved()</code> 和 <code>attributeReplaced()</code>。这 3 种方法分别在某个属性被添加到 servlet 上下文、被从 servlet 上下文删除、被新属性取代时获得控制权。<code>attributeReplaced()</code> 方法在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#section5" cmimpressionsent="1">处理对受 Acegi 保护的 JSF 页面的请求</a> 小节的第 8 步中获得控制权。<br /> <br /> </li>
        <li><code>ServletRequestListener</code> 中包含的方法在创建或删除新的 servlet 请求对象时获得控制权。servlet 请求方法表示并包装来自用户的请求。<br /> <br /> </li>
        <li><code>ServletRequestAttributeListener</code> 中包含的方法在添加、删除或替换某个请求对象的属性时获得控制权。本文稍后将讨论在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#section5" cmimpressionsent="1">处理对受 Acegi 保护的 JSF 页面的请求</a> 小节的第 3 步中创建一个新的请求对象时，JSF 的 <code>ConfigureListener</code> 执行的处理。 </li> 
       </ul> <br /> </li>
      <li>servlet 容器创建一个 <em>servlet 上下文对象</em>，该对象封装应用程序资源（比如 JSP 页面、Java 类和应用程序初始化参数），并允许整个应用程序访问这些资源。JSF-Acegi 应用程序的所有其他组件（侦听器、过滤器，以及 servlet）在 servlet 上下文对象中以属性的形式存储与应用程序资源相关的信息。<br /> <br /> </li>
      <li>servlet 容器通知 Acegi 的 <code>ContextLoaderListener</code>，servlet 上下文是通过调用 <code>ContextLoaderListener</code> 的 <code>contextInitializated()</code> 方法初始化的。<br /> <br /> </li>
      <li><code>contextInitialized()</code> 方法解析 Acegi 的配置文件，为 JSF-Acegi 应用程序创建 Web 应用程序上下文，以及实例化所有的安全过滤器和在 Acegi 配置文件中配置的 Jave bean。在以后 JSF 应用程序收到来自客户机的请求时，这些过滤器对象将会用于身份验证和授权（参阅 <a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi3/" cmimpressionsent="1">第 3 部分</a> 中关于 Web 应用程序上下文创建的讨论和图 1）。 <br /> <br /> </li>
      <li>servlet 容器通知 JSF 的 <code>ConfigureListener</code>，servlet 上下文是通过调用 <code>contextInitialized()</code> 方法初始化的。<br /> <br /> </li>
      <li><code>contextInitialized()</code> 方法检查在 JSF 配置文件中配置的所有 JSF 托管 bean，确保 Java 类与每个 bean 并存。<br /> <br /> </li>
      <li>servlet 容器检查 web.xml 文件中任何配置的过滤器。例如，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 web.xml 文件包含一个 Acegi 过滤器 <code>FilterToBeanProxy</code>，servlet 容器将其实例化、初始化并注册为一个过滤器。Acegi 现在可以对传入的请求执行身份验证和授权了。 <br /> <br /> </li>
      <li>servlet 容器实例化 faces servlet，后者开始侦听从用户传入的请求。 </li> 
     </ol> 
     <p>下一节解释 JSF-Acegi 应用程序收到来自用户的请求时发生的一系列事件。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section5"><span class="atitle">处理对受 Acegi 保护的 JSF 页面的请求</span></a></p> 
     <p>您已经了解了如何配置 Acegi 保护 JSF 应用程序。也看到了当启动 JSF-Acegi 应用程序时发生的一系列事件。本节描述当用户发送一个对受 Acegi 保护的 JSF 页面的请求时，JSF 和 Acegi 组件如何在 servlet 容器的框架中运行。</p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#fig2" cmimpressionsent="1">图 2</a> 展示了当客户机发送一个对受 Acegi 保护的 JSF 页面的请求时，发生的事件顺序：</p> 
     <br /> 
     <a name="fig2"><strong>图 2. JSF 和 Acegi 协作提供 JSF 页面</strong></a>
     <br /> 
     <img height="261" alt="JSF 和 Acegi 协作提供 JSF 页面" src="http://www.ibm.com/developerworks/cn/java/j-acegi4/Figure2.gif" width="459" /> 
     <br /> 
     <br /> 
     <br /> 
     <p>详细来讲，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#fig2" cmimpressionsent="1">图 2</a> 展示的事件顺序如下所示：</p> 
     <ol> 
      <li>servlet 容器创建一个表示用户请求的 servlet 请求对象。<br /> <br /> </li>
      <li>回想一下 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#section4" cmimpressionsent="1">启动 JSF-Acegi 应用程序</a> 小节中的第 3 步，JSF 的 <code>ConfigureListener</code> 实现 <code>ServletRequestListener</code> 接口。这意味着 <code>ConfigureListener</code> 侦听与创建和删除 servlet 请求对象相关的事件。因此，servlet 容器调用 <code>ConfigureListener</code> 类的 <code>requestInitialized()</code> 方法。<br /> <br /> </li>
      <li><code>requestInitialized()</code> 方法准备执行请求的 JSF 生命周期。准备过程包括检查请求的 faces 上下文是否存在。faces 上下文封装与应用程序资源相关的信息。faces servlet 执行 JSF 生命周期时需要这些信息。如果此请求是新会话的第一个请求，就会缺少 faces 上下文。在这种情况下，<code>requestInitialized()</code> 方法创建一个新的 faces 上下文。<br /> <br /> </li>
      <li>servlet 容器检查用户的请求是否带有任何状态信息。如果 servlet 容器未找到状态信息，它会假设该请求是新会话的第一个请求，并为用户创建一个 HTTP 会话对象。如果 servlet 容器发现该请求包含某种状态信息（比如一个 cookie 或 URL 中的某种状态信息），它就会根据保存的会话信息恢复用户以前的会话。<br /> <br /> </li>
      <li>servlet 容器把请求 URL 与一个 URL 模式进行匹配，这个 URL 模式包含在配置描述符中的 <code>&lt;filter-mapping&gt;</code> 标记的 <code>&lt;url-pattern&gt;</code> 子标记中。如果请求 URL 与这个 URL 模式匹配，servlet 容器调用 Acegi 的 <code>FilterToBeanProxy</code>，<code>FilterToBeanProxy</code> 已在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#fig1" cmimpressionsent="1">图 1</a> 的第 9 步中被注册为一个 servlet 过滤器。<br /> <br /> </li>
      <li>Acegi 的 <code>FilterToBeanProxy</code> 使用 <code>FilterChainProxy</code> 类执行 Acegi 的完整的安全过滤器链。Acegi 的过滤器自动检查第 4 步中创建的 HTTP 会话对象，以查看请求客户机是否已被验证。如果 Acegi 发现用户未被验证，它提供一个登录页面。否则，它就直接执行 <a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/" cmimpressionsent="1">第 2 部分</a> 的 “配置拦截器” 一节中描述的授权过程。 <br /> <br /> </li>
      <li>Acegi 使用经过验证的用户的会话信息更新 servlet 上下文。<br /> <br /> </li>
      <li>servlet 容器通知 JSF 的 <code>ConfigureListener</code> 的 <code>attributeReplaced()</code> 方法，servlet 上下文已被更新。<code>ConfigureListener</code> 检查是否有任何 JSF bean 被更改。如果发现任何更改，它相应地更新 faces 上下文。但是，在本例中，在身份验证过程中 Acegi 没有更改任何 JSF 托管 bean，因此在此调用期间 <code>ConfigureListener</code> 不进行任何处理。<br /> <br /> </li>
      <li>如果授权过程成功，控制权被转移到 faces servlet，它执行 JSF 生命周期并向用户发回一个响应。 </li> 
     </ol> 
     <p>现在，您了解了 JSF 和 Acegi 如何协作提供 JSF 请求，接下来看一下完成后的 JSF 和 Acegi。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section6"><span class="atitle">示例 JSF-Acegi 应用程序</span></a></p> 
     <p>本文的下载部分（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#download" cmimpressionsent="1">下载</a>）包含一个示例 JSF-Acegi 应用程序 JSFAcegiSample，演示了 Acegi 与 JSF 的简单集成。示例应用程序使用 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#listing1" cmimpressionsent="1">清单 1</a> 中的 web.xml。 </p> 
     <p>要部署示例应用程序，执行 <a onmouseover="linkQueryAppend(this)" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/" cmimpressionsent="1">第 1 部分</a> 的 “部署并运行应用程序” 一节中的两个步骤。还需要从 Sun 的 JSF 站点（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi4/index.html?S_TACT=105AGX52&amp;S_CMP=techcsdn#resources" cmimpressionsent="1">参考资料</a>）下载并解压 jsf-1_1_01.zip。将 jsf-1.1.X.zip 中的所有文件复制到 JSFAcegiSample 应用程序的 WEB-INF/lib 文件夹中。</p> 
     <p>从浏览器访问 http://localhost:8080/JSFAcegiSample，可以调用示例应用程序。JSFAcegiSample 应用程序显示一个索引页面和一个登录页面，索引页面中包含受保护资源的链接。所有受保护页面都是使用 JSF 组件开发的，而 Acegi 提供登录页面并执行身份验证和授权。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section7"><span class="atitle">结束语</span></a></p> 
     <p>在本文中，了解了如何配置 Acegi 以保护 JSF 应用程序。还详细了解了 JSF 和 Acegi 组件如何在一个 servlet 容器的框架中协作。最后，尝试运行了一个示例 JSF-Acegi 应用程序。</p> 
     <p>关于实现 JSF 应用程序的 Acegi 安全性，还涉及到更多内容。本系列的下一篇文章将演示如何使用 Acegi 保护对 JSF 的托管 bean 的访问。<br /> <br /> <br /> 来自: http://www.cnblogs.com/amboyna/archive/2008/03/25/1122089.html</p> 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199314.html" title="permalink">2008-05-08 18:50</a> 狼爱上狸 阅读(191) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199314.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=199314">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=199314">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl07_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/08/199312.html">acegi,IBM的Acegi Security System（3） </a></h2> 
     <p>2007 年 10 月 18 日</p> 
     <blockquote>
      本文是 Acegi Security Systerm 介绍的最后一部分（共三部分），Bilal Siddiqui 将向您介绍如何保护对 Java 类实例的访问，从而结束本系列文章。通过本文了解为何需要对 Java64 类的访问进行保护，Spring 如何创建和保护对 Java 类实例的访问以及如何对 Acegi 进行配置以实现 Java 应用程序的类安全性。
     </blockquote>
     <!--start RESERVED FOR FUTURE USE INCLUDE FILES-->
     <!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters -->
     <!--end RESERVED FOR FUTURE USE INCLUDE FILES--> 
     <p>这期共分三部分的系列文章介绍了如何使用 Acegi 安全系统保护 Java 企业应用程序。系列文章的 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html" cmimpressionsent="1">第 1 部分</a> 简单介绍了 Acegi 并解释如何使用其内置的安全过滤器实现一个简单的、基于 URL 的安全系统。<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/" cmimpressionsent="1">第 2 部分</a> 介绍了如何编写访问控制策略并将其保存到一个 LDAP 目录服务器，以及如何配置 Acegi 来与目录服务器进行交互，从而实现访问控制策略。第 3 部分（也是本系列的最后一篇文章）将演示如何在企业应用程序中使用 Acegi 保护对 Java 类实例的访问。 </p> 
     <p>首先我将介绍何时需要对 Java 类访问进行保护，包括文中引用的两个典型企业应用程序场景。之后，我将解释 Spring 的反转控制（IOC）框架如何创建可从 JSP 或 servlet 访问的 Java 类实例。我还将介绍有关 <em>bean 代理</em> 的重要概念，Spring 正是使用它过滤对 Java 类的访问。最后，我将介绍如何对 Acegi 的方法安全性拦截器进行配置以控制对 Java 类的访问。我将对 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2" cmimpressionsent="1">第 2 部分</a> 中的示例程序进行增强，为实现安全的 Java 对象提供支持，从而结束本系列的最后一篇文章。 </p> 
     <p>由于本文的讨论构建在本系列前两部分的内容之上，因此会经常引用到 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html" cmimpressionsent="1">第 1 部分</a> 和 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/index.html" cmimpressionsent="1">第 2 部分</a> 中的讨论和示例。因此，在继续阅读本文之前，在其他浏览器窗口中打开前两期文章将有助于理解本文内容。</p> 
     <p><a name="section1"><span class="atitle">保护 Java 类的用例</span></a></p> 
     <p>您可能还记得，我曾在本系列的开头部分简单介绍了 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section1" cmimpressionsent="1">企业应用程序安全性</a>。在那次讨论中我曾提到过一种场景，其中 URL 安全性并不能完全满足这种场景的安全需求：</p> 
     <blockquote>
      假设有这样一个 PDF 文档，其中包含了某制造业公司生产的特定产品的数据。文档的一部分包含了设计数据，将由公司设计部分进行编辑和更新。文档另一部分包含生产经理将使用到的生产数据。对于此类场景，需要实现更加细粒度的安全性，对文档的不同部分应用不同的访问权限。
     </blockquote> 
     <p>在继续阅读之前，请考虑更多的应用程序场景，除了实现 URL 安全性以外，这些场景还要求您对单独的类访问进行保护。</p> 
     <p><a name="section1.1"><span class="smalltitle">业务自动化</span></a></p> 
     <p>业务自动化应用程序中的工作流由多个流程组成。例如，病理学实验室中执行血液测试的工作流由若干个步骤组成，其中每个步骤可看作一个业务流程：</p> 
     <ol> 
      <li>工作人员从病人处采集血液样本并为其分配一个 ID。 </li>
      <li>实验室技术人员对样本进行必要的测试并准备测试结果。 </li>
      <li>由具备相应资格的病理学专家根据测试结果编写测试报告。 </li> 
     </ol> 
     <p>很明显，每个流程分别由单独的授权用户执行。未授权的用户则无权执行流程。例如，实验室研究人员只负责准备试验结果，而无权编写测试报告。</p> 
     <p>几乎所有的业务自动化应用程序都普遍使用授权的业务流程。通常，每个业务流程被实现为一个 Java 类，并且需要使用合适的访问控制策略对所有类实施保护。</p> 
     <p><a name="section1.2"><span class="smalltitle">企业对企业（Business-to-business）集成</span></a></p> 
     <p>Business-to-business (B2B) 集成指一种常见的场景，其中的两个企业实体需要彼此公开各自的特定功能。例如，宾馆可能向旅游公司公开其房间预订功能，而后者使用该功能为游客预订空闲的房间。作为合作伙伴的旅游公司可能具有一个特定的订房率。在这个场景中，宾馆的订房系统必须先对旅游公司进行身份验证，然后才能允许他们访问所选择的类，以便按照特定的订房率进行房间预订。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section2"><span class="atitle">使用 Spring 创建 Java 对象</span></a></p> 
     <p>现在您已经了解了对 Java 类示例的访问进行保护的重要性。在介绍能够实现更高级安全性的 Acegi 新功能之前，我将引导您回顾 Spring 框架的几个关键特性，您需要了解这些内容才能继续后文的示例。</p> 
     <p>首先对一些 Java 类进行配置并执行实例化。<a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section3" cmimpressionsent="1">第 1 部分</a> 曾介绍过，Java 类在 Spring 的 XML 配置文件中进行配置。在 Spring 配置文件中配置 Java 类的过程与 Acegi 过滤器的配置过程完全相同，因此这里不多做介绍。相反，我们将查看清单 1，它展示了名为 <code>publicCatalog</code> 的 bean 的配置：</p> 
     <br /> 
     <a name="listing1"><strong>清单 1. Acegi XML 配置文件</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">
            &lt;beans&gt;
            &lt;bean id=&quot;publicCatalog&quot;
            class=&quot;com.catalog.PublicCatalog&quot; /&gt;
            &lt;!--Other bean tags --&gt;
            &lt;beans&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>了解 Spring 的 IOC 框架如何从 XML 配置文件读取 Java 类信息以及如何进行实例化，这一点非常重要。您可能还记得，我在系列文章的 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html" cmimpressionsent="1">第 1 部分</a> 中使用一个 web.xml 文件配置 <code>&lt;listener&gt;</code> 标记，它指向名为 <code>ContextLoaderListener</code> 的类。<code>ContextLoaderListener</code> 装载 Spring 的 IOC 框架并创建 Java 对象。您可以参考 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section6.1" cmimpressionsent="1">第 1 部分的清单 8</a> 查看全部内容。图 1 也对此进行了描述：</p> 
     <br /> 
     <a name="figure1"><strong>图 1. 装载 Spring 的 IOC 框架并创建 Java 对象</strong></a>
     <br /> 
     <img height="236" alt="装载 Spring 的 IOC 框架并创建 Java 对象的步骤" src="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/Figure1.jpg" width="452" /> 
     <br /> 
     <p>现在我们将详细讨论这些步骤：</p> 
     <ol> 
      <li>当初始化 Acegi 应用程序时，servlet 容器（本例中为 Apache Tomcat）创建了一个 <em>servlet 上下文</em>，其中保存了有关应用程序资源的信息，例如 JSP 页面和类。<br /> <br /> </li>
      <li>servlet 容器通知 <code>ContextLoaderListener</code> 类应用程序正在启动。<br /> <br /> </li>
      <li><code>ContextLoaderListener</code> 类创建一个 Web 应用程序上下文以保存应用程序中特定于 Spring 的资源信息。借助 Spring 的 IOC 框架，您可以装载自己的自定义应用程序上下文。要创建应用程序上下文，将使用名为 <code>ContextLoader</code> 的上下文装载器类装载应用程序上下文。<br /> <br /> </li>
      <li>如果应用程序不需要定义自己的应用程序上下文，则可以使用名为 <code>XMLWebApplicationContext</code> 的类，它是 Spring 框架的一部分并提供可处理 Spring XML 配置文件的功能。Acegi 应用程序使用的是 Spring 的 XML 配置文件，因此本文仅讨论由 <code>XMLWebApplicationContext</code> 类表示的应用程序上下文。在本例中，上下文装载器对 <code>XMLWebApplicationContext</code> 类进行实例化，后者表示您的 Acegi 应用程序的应用程序上下文。上下文装载器还在 Web 应用程序上下文中设置 servlet 上下文（于步骤 1 中创建）的引用。<br /> <br /> </li>
      <li><code>XMLWebApplicationContext</code> 类对 XML 配置文件进行解析，获得关于 Java 类的信息并将信息装载到其他内部对象中。<br /> <br /> </li>
      <li><code>XMLWebApplicationContext</code> 类对 XML 配置文件中指定的所有 Java 类进行实例化。<code>XMLWebApplicationContext</code> 类检查 XML 配置文件中经过配置的 Java bean 是否依赖其他的 Java 对象。如果是的话，<code>XMLWebApplicationContext</code> 类将首先对其他 bean 所依赖的 bean 进行实例化。通过这种方式，<code>XMLWebApplicationContext</code> 类创建了 XML 配置文件中定义的所有 bean 的实例。（注意，步骤 6 假定 XML 配置文件中所有 bean 都不要进行保护，稍后一节将介绍步骤 5 和步骤 6 之间执行的额外步骤，从而保护对此处创建的 Java bean 的访问）。<br /> <br /> </li>
      <li><code>XMLWebApplicationContext</code> 类将所有 bean 保存在一个数组中。 </li> 
     </ol> 
     <p>您现在已了解到如何从 XML 配置文件中装载 bean 定义并创建 Java 类的实例。接下来，我将向您介绍 Spring bean 代理并解释它对于保护 Java 类实例的重要性。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section3"><span class="atitle">使用 bean 代理</span></a></p> 
     <p>上一节讨论了 Spring 的 IOC 框架对 Java 对象进行实例化。要保护对 Java 对象的访问，Spring 的 IOC 框架使用了 <em>bean 代理</em> 的概念。本节首先介绍如何配置 bean 代理，然后演示 Spring 的 IOC 框架如何创建代理对象。</p> 
     <p><a name="section3.1"><span class="smalltitle">为 Java 对象配置代理</span></a></p> 
     <p>如果希望创建 bean 代理，Spring IOC 框架要求您对代理创建器 bean 的实例进行配置。Spring 的 IOC 框架使用代理创建器创建代理对象。清单 2 为代理创建器 bean 的配置文件，用于保护名为 <code>privateCatalog</code> 的 Java 对象：</p> 
     <br /> 
     <a name="listing2"><strong>清单 2. 代理 bean 配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">
            &lt;bean id=&quot;proxyCreator&quot;
            class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;
            &lt;property name=&quot;beanNames&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;privateCatalog&lt;/value&gt;
            &lt;!--Names of other beans to be proxied --&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;privateCatalogSecurityInterceptor&lt;/value&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>如清单 2 所示，<code>&lt;bean&gt;</code> 标记具有一个 <code>class</code> 属性，其值为 <code>org.springframework.aop.framework.autoproxy. BeanNameAutoProxyCreator</code>。<code>BeanNameAutoProxyCreator</code> 类是 Spring IOC 框架的一部分，可以自动创建 bean 代理。Spring 框架提供了 <code>BeanPostProcessor</code> 接口，它提供了一种可扩展机制，允许应用程序编写自己的逻辑来创建 bean 代理。Spring 的 <code>BeanNameAutoProxyCreator</code> 类实现了 <code>BeanPostProcessor</code> 接口并提供所有必需的代理创建逻辑来保护 Java 类。因此，本文中您无需实现 <code>BeanPostProcessor</code> 接口。</p> 
     <p>在创建 bean 代理时，<code>BeanNameAutoProxyCreator</code> 类为所有由 <code>beanNames</code> 属性定义的 bean 创建代理（参见 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing2" cmimpressionsent="1">清单 2</a> 中 <code>&lt;bean&gt;</code> 标记的第一个 <code>&lt;property&gt;</code> 子元素）。<code>beanNames</code> 属性在 <code>&lt;list&gt;</code> 标记中包含一个 bean 名称列表。在 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing2" cmimpressionsent="1">清单 2</a> 中，我只对希望为之创建代理的 <code>privateCatalog</code> bean进行了配置。</p> 
     <p>现在查看 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing2" cmimpressionsent="1">清单 2</a> 中 <code>&lt;bean&gt;</code> 标记的第二个 <code>&lt;property&gt;</code> 子元素。它指定了名为 <code>interceptorNames</code> 的代理，它将一个或多个拦截器的名称封装起来。我将在后文详细讨论拦截器概念。现在，只需了解拦截器可以拦截用户并在用户访问 bean 之前实现访问控制策略。</p> 
     <p>现在，您已了解了如何对希望进行保护的 bean 配置代理。接下来，您将了解 Spring 的 IOC 框架如何在内部为应用程序的 bean 创建代理对象。</p> 
     <p><a name="section3.2"><span class="smalltitle">Spring IOC 发挥效用</span></a></p> 
     <p>在 “<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#section2" cmimpressionsent="1">使用 Spring 创建 Java 对象</a>” 的步骤 5 和步骤 6 中，您了解了 <code>XMLWebApplicationContext</code> 类如何从 XML 配置文件中读取 bean 定义并随后创建 bean 实例。在创建 bean 实例之前，<code>XMLWebApplicationContext</code> 类将检查 XML 配置文件是否包含任何代理创建器 bean（即实现 <code>BeanPostProcessor</code> 接口的 bean）配置。如果存在该 bean，它将要求代理创建器为您希望进行保护的 bean 创建 bean 代理。</p> 
     <a name="proxies"> <p>现在考虑代理创建器如何在内部创建代理对象：</p> </a>
     <ol>
      <a name="proxies"> <li>代理创建器（即 <code>BeanNameAutoProxyCreator</code> 类）装载 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing2" cmimpressionsent="1">清单 2</a> 中配置的 <code>beanNames</code> 属性文件中指定的所有 bean 名称。<br /> <br /> </li></a>
      <li>代理创建器使用 bean 名称装载各自的 Java 类，这些类使用了每个 bean 定义的 <code>class</code> 属性。<br /> <br /> </li>
      <li>代理创建器创建 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing2" cmimpressionsent="1">清单 2</a> 所示的 <code>interceptorNames</code> 属性中指定的拦截器的实例。<br /> <br /> </li>
      <li>最后，代理创建器创建一个 <code>Cglib2AopProxy</code> 类的实例，将所有 bean 名称（步骤 2）和拦截器（步骤 3）传递到 <code>Cglib2AopProxy</code> 类。<code>Cglib2AopProxy </code>类是 Spring 框架的一部分并用于生成动态代理对象。在本例中，<code>Cglib2AopProxy</code> 类将创建安全 bean 访问控制所需的代理对象。 </li> 
     </ol> 
     <p><code>Cglib2AopProxy</code> 类实现了两个名为 <code>AOPProxy</code> 和 <code>MethodInterceptor</code> 的接口。<code>AOPProxy</code> 接口由 Spring 框架提供，表示您希望进行代理的实际 bean，因此它与您的 bean 公开相同的方法。<code>MethodInterceptor</code> 接口也源于 AOP 框架，它包含的方法可以在用户试图访问您已执行代理的 bean 时接受控制权。这意味着 <code>MethodInterceptor</code> 接口处理来自用户的请求以访问执行过代理的 bean。由于 <code>Cglib2AopProxy</code> 类同时实现了 <code>AOPProxy</code> 和 <code>MethodInterceptor</code> 接口，因此它提供了完整的功能，既可以提供经过代理的 bean，也可以处理用户请求以访问代理 bean（参见 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#resources" cmimpressionsent="1">参考资料小节</a> 中有关 AOP 的讨论文章的链接）。</p> 
     <p>执行完前面的步骤后，您现在具有了所需的代理对象。因此 <code>XMLWebApplicationContext</code> 类将安全 bean 的代理（而不是实际的 bean）保存在 “<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#section2" cmimpressionsent="1">使用 Spring 创建 Java 对象</a>” 的步骤 7 中的同一个数组中。 </p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section4"><span class="atitle">访问执行过代理的 Java 对象</span></a></p> 
     <p>在前面的几节中，您了解了 Spring 如何创建公有 bean 和私有 bean。出于本文的目的，您可将公有 bean 视为使用代理保护的不安全的私有 bean。现在我们来看一下客户机应用程序为访问公有 bean 和私有 bean 而必须遵循的一系列步骤。</p> 
     <p>清单 3 展示了 <code>publicCatalog</code> 和 <code>privateCatalog</code> 两个 bean 的 XML 配置。<code>publicCatalog</code> bean 意味着公共访问，因此不需要使用 bean 代理。<code>privateCatalog</code> bean 意味着只能由指定用户访问，因此必须加以保护。我在清单 3 中包含了 <code>privateCatalog</code> bean 的 bean 代理配置：</p> 
     <br /> 
     <a name="listing3"><strong>清单 3. publicCatalog 和 privateCatalog bean 的 XML 配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">
            &lt;beans&gt;
            &lt;bean id=&quot;publicCatalog&quot; class=&quot;sample.PublicCatalog&quot;/&gt;
            &lt;bean id=&quot;privateCatalog&quot; class=&quot;sample.PrivateCatalog&quot;/&gt;
            &lt;!-- proxy configuration for privateCatalog bean --&gt;
            &lt;bean id=&quot;proxyCreator&quot;
            class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;
            &lt;property name=&quot;beanNames&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;privateCatalog&lt;/value&gt;
            &lt;!--Names of other beans to be proxied --&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;privateCatalogSecurityInterceptor&lt;/value&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            &lt;beans&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>应用程序可以使用清单 4 中的代码访问清单 3 中配置的 <code>publicCatalog</code> 和 <code>privateCatalog</code> Java bean。注意，清单 4 中显示的 Java 代码可位于 JSP 页面或位于服务器端 Java 应用程序的 bean 中。</p> 
     <br /> 
     <a name="listing4"><strong>清单 4. 访问安全和不安全 Java bean 的客户机应用程序代码</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">
            //Step 1: Fetching an instance of the application context
            XMLWebApplicationContext applicationCtx =
            WebApplicationContextUtils.getWebApplicationContext(
            this.getServletConfig().getServletContext());
            //Step 2: Fetching an insecure bean from the application context
            PublicCatalog publicCatalog =
            (PublicCatalog) applicationCtx.getBean(&quot;publicCatalog&quot;);
            //Step 3: Calling a method of the insecure bean
            String publicData = publicCatalog.getData();
            //Step 4: Fetching a secure bean from the application context
            PrivateCatalog privateCatalog =
            (PrivateCatalog) applicationCtx.getBean(&quot;privateCatalog&quot;);
            //Step 5: Calling a method of the secure bean
            String privateData = privateCatalog.getData();
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>下面将进一步讨论清单 4 中的步骤：</p> 
     <ul> 
      <li><strong>步骤 1：取回一个应用程序上下文实例</strong> <br /> 当应用程序希望访问 XML 配置文件中配置的 Java bean 时，它必须取回您在 “<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#section2" cmimpressionsent="1">使用 Spring 创建 Java 对象</a>” 的步骤 4 中见到的 <code>XMLWebApplicationContext</code> 对象。<code>XMLWebApplicationContext</code> 对象包含对 XML 配置文件配置的所有 Java beans 的引用。<br /> <br /> </li>
      <li><strong>步骤 2：从应用程序上下文中取回不安全的 bean</strong> <br /> 您现在具有一个对 <code>XMLWebApplicationContext</code> 对象的引用。<code>XMLWebApplicationContext</code> 类公开了一个 <code>getBean()</code> 方法，它包含 bean 的名称并在数组中查找 “<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#section2" cmimpressionsent="1">使用 Spring 创建 Java 对象</a>” 步骤 7 中准备的 bean。在本例中，该 bean 为 <code>publicCatalog</code>（未执行过代理），因此 <code>XMLWebApplicationContext</code> 将返回实际的 bean。<br /> <br /> </li>
      <li><strong>步骤 3：调用不安全 bean 的方法</strong> <br /> 现在您可以调用步骤 2 中获得的 <code>publicCatalog</code> bean 的任何方法。例如，清单 4 显示的 <code>getData()</code> 方法调用的执行没有应用任何访问控制并向应用程序返回类别数据。<br /> <br /> </li>
      <li><strong>步骤 4：从应用程序上下文取回安全 bean</strong> <br /> 安全 bean 与不安全 bean 的取回方式类似，惟一区别是：当您通过调用 <code>getBean()</code> 方法尝试取回安全 bean 时，您将获得安全对象的代理而不是实际的对象。该代理就是我在 “<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#proxies" cmimpressionsent="1">Spring IOC 发挥效用</a>” 步骤 4 中解释的由 Spring 框架创建的同一个对象。<br /> <br /> </li>
      <li><strong>步骤 5：调用安全 bean 的方法</strong> <br /> 当调用安全 bean 的方法时，您在 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#proxies" cmimpressionsent="1">步骤 4</a> 中获得的代理对象将一个方法调用请求分配给拦截器。拦截器将检查试图访问方法的用户是否具有相应的访问权，从而处理方法调用请求。 </li> 
     </ul> 
     <p>您现在应该对 Spring 框架如何创建 Java 对象以及客户机应用程序如何与之交互有了清晰的了解。了解了这些内容后，就更加容易理解并利用 Acegi 的方法安全性拦截器，下一节将具体介绍该主题。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section5"><span class="atitle">配置 Acegi 的方法安全性拦截器</span></a></p> 
     <p>只要应用程序试图访问由 Acegi 安全系统保护的 bean 方法，请求将被自动传递到 Acegi 的方法安全性拦截器。方法安全性拦截器的作用就是控制对安全 Java bean 的方法的访问。拦截器使用 Acegi 的身份验证和授权框架确认用户是否具有权利调用安全 Java bean 的方法，然后相应地作出响应。</p> 
     <p>清单 5 展示 Acegi 的方法安全性拦截器的示例配置：</p> 
     <br /> 
     <a name="listing5"><strong>清单 5. Acegi 的方法安全性拦截器的示例配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">
            &lt;bean id=&quot;privateCatalogSecurityInterceptor&quot;
            class=&quot;org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot;&gt;
            &lt;ref bean=&quot;authenticationManager&quot;/&gt;
            &lt;/property&gt;
            &lt;property name=&quot;accessDecisionManager&quot;&gt;
            &lt;ref bean=&quot;accessDecisionManager&quot;/&gt;
            &lt;/property&gt;
            &lt;property name=&quot;objectDefinitionSource&quot;&gt;
            &lt;value&gt;
            sample.PrivateCatalog.getData=ROLE_HEAD_OF_ENGINEERING
            &lt;!-- Roles required by other beans --&gt;
            &lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>清单 5 所示的拦截器配置包含三个需要进行配置的属性，可以保护对 Java bean 的访问：<code>authenticationManager</code>、<code>accessDecisionManager</code> 和 <code>objectDefinitionSource</code>。</p> 
     <p>回忆一下，您在本系列第 1 部分的 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section4.2" cmimpressionsent="1">配置身份验证处理过滤器</a> 中曾对 <code>authenticationManager</code> 属性进行了配置。<code>authenticationManager</code> 属性的作用是对用户进行身份验证。</p> 
     <p>您在本系列的第二篇文章中了解了 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/index.html#section6.1" cmimpressionsent="1">accessDecisionManager</a> 属性。这个访问决策管理器负责制定授权决策。在允许对一个安全 bean 进行访问之前，方法安全拦截器使用 <code>authenticationManager</code> 和 <code>accessDecisionManager</code> 属性对用户进行身份验证和授权。</p> 
     <p>现在查看 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing5" cmimpressionsent="1">清单 5</a> 中配置的 <code>objectDefinitionSource</code> 属性。它类似于第 1 部分中出现的 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section4.5" cmimpressionsent="1">objectDefinitionSource</a> 属性。以前的 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section4.5" cmimpressionsent="1">objectDefinitionSource</a> 包含类似于 <code>/protected/*</code> 和 <code>/**</code> 这样的 URL，清单 5 中的 <code>objectDefinitionSource</code> 属性指定类和方法名；例如，<code>sample.PrivateCatalog</code> 是之前执行过代理的类的名称，而 <code>getData</code> 是您希望对其控制用户访问的方法的名字。</p> 
     <p>当用户访问 <code>PrivateCatalog</code> bean 的 <code>getData()</code> 方法时，控制权将自动传递给拦截器。拦截器使用 Acegi 框架检查用户的业务角色是否为 <code>ROLE_HEAD_OF_ENGINEERING</code>（特定于本文的示例）。如果是的话，拦截器将允许对 <code>getData()</code> 方法进行访问。如果拦截器发现用户角色不是 <code>ROLE_HEAD_OF_ENGINEERING</code>，则拒绝访问。</p> 
     <p>下一节将查看一个示例 Acegi 应用程序，它将实现您目前所了解的所有概念。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section6"><span class="atitle">示例 Acegi 应用程序</span></a></p> 
     <p>本文的 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#download" cmimpressionsent="1">下载源代码</a> 包含了一个名为 AcegiMethodSecurity 的示例应用程序，可按照以下方法进行配置和部署：</p> 
     <ol> 
      <li>使用用户信息填充 LDAP 服务器。<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#download" cmimpressionsent="1">下载的示例应用程序</a> 包含一个 LDIF 文件，其中含有预备装载到 LDAP 服务器的用户信息。关于如何将 LDIF 文件导入到 LDAP 服务器，请参考第 2 部分的 “<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/index.html#section2.2" cmimpressionsent="1">填充服务器</a>” 一节。注意，该应用程序涉及与第 2 部分相同的用户（<code>alice</code>、<code>bob</code> 和 <code>specialUser</code>）。<br /> <br /> </li>
      <li>将本文下载源代码中的 acegiMethodSecurity.war 文件复制到 Tomcat 安装目录中的 webapps 目录。<br /> <br /> </li>
      <li>将 Acegi 的 jar 文件复制到示例应用程序的 WEB-INF/lib 文件夹。（有关内容请参考第 1 部分的 “<a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section6.2" cmimpressionsent="1">部署和运行应用程序</a>” 一节。 ）<br /> <br /> </li>
      <li>下载 cglib-full-2.0.2.jar 文件并将其复制到示例应用程序的 WEB-INF/lib 文件夹。 </li> 
     </ol> 
     <p>启动 Tomcat 并尝试运行示例应用程序。</p> 
     <p><a name="section6.1"><span class="smalltitle">运行示例应用程序</span></a></p> 
     <p>通过从浏览器访问 http://localhost:8080/acegiMethodSecurity URL 可调用示例应用程序。AcegiMethodSecurity 显示的索引页面包含两个链接（<strong>Catalog</strong> 和 <strong>Login</strong>），如图 2 所示：</p> 
     <br /> 
     <a name="figure2"><strong>图 2. 示例应用程序的主页面</strong></a>
     <br /> 
     <img height="248" alt="示例应用程序的主页面" src="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/Figure2.jpg" width="402" /> 
     <br /> 
     <p>当单击应用程序的 <strong>Catalog</strong> 链接时，它将要求您进行登录。如果以 <code>alice</code> 或 <code>specialUser</code> 的身份进行登录，示例应用程序将提供<em>完整的</em> 类别，包括公有数据和私有数据。这是因为在 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing5" cmimpressionsent="1">清单 5</a> 中，您对方法安全性拦截器进行了配置，允许用户使用 <code>ROLE_HEAD_OF_ENGINEERING</code> 访问私有类别，而 <code>alice</code> 和 <code>specialUser</code> 都具有该访问权。另一方面，如果您以 <code>bob</code> 的身份登录，示例应用程序将仅显示公有数据。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="7"><span class="atitle">为通过身份验证的用户分配额外角色</span></a></p> 
     <p>本节将演示经过增强的示例应用程序。增强后的示例应用程序将展示 Acegi 如何使您能够在运行时向通过身份验证的用户临时分配额外角色。 </p> 
     <p>当安全 bean（例如 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing3" cmimpressionsent="1">清单 3</a> 的 <code>privateCatalog</code> bean）要访问一个原创资源时，您可能需要使用额外的角色。例如，您可能考虑到您的安全 bean 需要通过 Java 的 Remote Method Invocation (RMI) 框架或一个 Web 服务访问某个远程应用程序。访问安全 bean 的用户不会占用远程应用程序要求访问用户所具备的业务角色。</p> 
     <p>在本例中，Acegi 首先检查用户是否经过授权来访问安全 bean。之后，Acegi 允许用户访问安全 bean。当安全 bean 试图访问远程服务时，它需要使用额外的业务角色。如果访问安全 bean 的用户不具备额外角色，安全 bean 就不能成功访问远程服务。</p> 
     <p><a name="section7.1"><span class="smalltitle">run-as-replacement 机制</span></a></p> 
     <p>Acegi 框架提供了一种名为 <em>run-as-replacement</em> 的简单机制，允许您仅在方法调用期间为通过身份验证的用户配置一个或多个额外角色。您可以使用 run-as-replacement 机制为访问远程应用程序的安全 bean 配置额外角色。这意味着只要安全 bean 需要访问远程应用程序，Acegi 将为用户装载额外角色，从而允许安全 bean 访问远程应用程序。</p> 
     <p>清单 6 对 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing5" cmimpressionsent="1">清单 5</a> 中的方法安全性拦截器的配置进行了增强。增强后的配置使用了 run-as-replacement 机制。</p> 
     <br /> 
     <a name="listing6"><strong>清单 6. Acegi 方法安全性拦截器的增强配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">
            &lt;bean id=&quot;privateCatalogSecurityInterceptor&quot;
            class=&quot;org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot;&gt;
            &lt;ref bean=&quot;authenticationManager&quot;/&gt;
            &lt;/property&gt;
            &lt;property name=&quot;accessDecisionManager&quot;&gt;
            &lt;ref bean=&quot;accessDecisionManager&quot;/&gt;
            &lt;/property&gt;
            <span class="boldcode">&lt;property name=&quot;runAsManager&quot;&gt;</span>
            <br />
            <span class="boldcode">    &lt;bean id=&quot;runAsManager&quot;
            class=&quot;org.acegisecurity.runas.RunAsManagerImpl&quot;&gt;</span>
            <br />
            <span class="boldcode">         &lt;property name=&quot;key&quot;&gt;</span>
            <span class="boldcode">            &lt;value&gt;myKeyPass&lt;/value&gt;</span>
            <span class="boldcode">         &lt;/property&gt;</span>
            <span class="boldcode">    &lt;/bean&gt;</span>
            <span class="boldcode">  &lt;/property&gt;</span>
            &lt;property name=&quot;objectDefinitionSource&quot;&gt;
            &lt;value&gt;
            sample.PrivateCatalog.getData=ROLE_HEAD_OF_ENGINEERING,<span class="boldcode">RUN_AS_MANAGER</span>
            &lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>清单 6 使用粗体显示了两处增强（与 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing5" cmimpressionsent="1">清单 5</a> 相比）。第一处增强为 <code>runAsManager</code> 属性。<code>runAsManager</code> 属性的作用是向通过身份验证的用户动态添加角色。出于这个目的，<code>runAsManager</code> 属性包含了 <code>RunAsManagerImpl</code> bean 的定义。<code>RunAsManagerImpl</code> bean 只有在满足下面的条件时才可变为活跃状态：在 <code>objectDefinitionSource</code> 方法的角色定义中找到以 <code>RUN_AS_</code> 为前缀的角色。例如，<code>PrivateCatalog.getData()</code> 方法的角色定义（<a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#listing6" cmimpressionsent="1">清单 6</a> 中以粗体显示的第二处增强）具有一个 <code>RUN_AS_MANAGER</code> 角色。</p> 
     <p><code>RunAsManagerImpl</code> bean 包含一个名为 <code>key</code> 的属性，它封装的加密键用于确保只将额外的角色作为 run-as-replacement 程序的一部分生成。</p> 
     <p>当用户调用 <code>getData()</code> 方法时，<code>RunAsManagerImpl</code> bean 变为活跃状态并创建名为 <code>RUN_AS_MANAGER</code> 的额外角色，从而启用 <code>getData()</code> 方法访问远程应用程序。</p> 
     <p><a name="section7.2"><span class="smalltitle">增强的方法安全性</span></a></p> 
     <p>本文的 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#download" cmimpressionsent="1">下载源代码</a> 包含一个名为 <code>EnhancedAcegiMethodSecurity</code> 的示例应用程序，它可以演示 run-as-replacement 机制和程序。该应用程序将显示一个具有 Catalog 链接的索引页面。如果单击 <strong>Catalog</strong> 链接，将要求进行登录。</p> 
     <p>登录后，<code>EnhancedAcegiMethodSecurity</code> 应用程序将为您提供登录用户及其角色的完整信息。例如，如果以 <code>alice</code> 或 <code>specialUser</code> 身份登录，将向您显示用户的所有业务角色，包括额外创建的临时的 <code>RUN_AS_MANAGER</code> 角色。</p> 
     <p><a name="section8"><span class="atitle">结束语</span></a></p> 
     <p>在这份共分三部分的系列文章中，我介绍了如何使用 Acegi 安全系统增强基于 URL 的安全性和基于方法的安全性。您了解了如何设计访问控制策略并将它们托管在目录服务器中，如何对 Acegi 进行配置以与目录服务器进行通信，以及如何根据托管在服务器的访问控制策略制定身份验证和授权决策。</p> 
     <p>本系列的最后一篇文章主要介绍使用基于方法的安全性保护 Java 类实例。文章还解释了 Acegi 和 Spring 如何在内部创建和代理 Java 对象以及 bean 代理如何实现访问控制。文章包含了两个示例应用程序，您可以使用它们进一步研究本系列中学到的概念，更多有关使用 Acegi 保护 Java 应用程序的内容，请参见 <a href="http://www-128.ibm.com/developerworks/cn/java/j-acegi3/?#resources" cmimpressionsent="1">参考资料</a> 小节。</p> 
     <br /> 
     <br /> 来自:http://www-128.ibm.com/developerworks/cn/java/j-acegi3/? 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199312.html" title="permalink">2008-05-08 18:47</a> 狼爱上狸 阅读(309) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199312.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=199312">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=199312">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl08_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/08/199311.html">acegi,IBM的Acegi Security System（2） </a></h2> 
     <p>2007 年 6 月 21 日</p> 
     <blockquote>
      了解了 Acegi 安全系统（Acegi Security System）的 
      <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html" cmimpressionsent="1">基础知识</a> 后，我们将介绍该系统的更加高级的应用。在本文中，Bilal Siddiqui 向您展示了如何结合使用 Acegi 和一个 LDAP 目录服务器，实现灵活的具有高性能的 Java64 应用程序的安全性。还将了解如何编写访问控制策略并将其存储在 ApacheDS 中，然后配置 Acegi 使其与目录服务器交互，从而实现身份验证和授权的目的。
     </blockquote>
     <!--start RESERVED FOR FUTURE USE INCLUDE FILES-->
     <!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters -->
     <!--end RESERVED FOR FUTURE USE INCLUDE FILES--> 
     <p>这期共分三部分的系列文章介绍了如何使用 Acegi 安全系统保护 Java 企业应用程序。在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html" cmimpressionsent="1">本系列第一篇文章</a> 中，我介绍了 Acegi 并解释了如何使用安全过滤器实现一个简单的基于 URL 的安全系统。在第二篇文章中，我将讨论 Acegi 的更加高级的应用，首先我将编写一个访问控制策略并将其存储在 ApacheDS 中，ApacheDS 是一个开源的 LDAP 目录服务器。我还将展示配置 Acegi 的方法，使它能够与目录服务器交互并实现您的访问控制策略。本文的结尾提供了一个示例应用程序，它使用 ApacheDS 和 Acegi 实现了一个安全的访问控制策略。</p> 
     <p>实现访问控制策略通常包含两个步骤：</p> 
     <ol> 
      <li>将有关用户和用户角色的数据存储在目录服务器中。 </li>
      <li>编写安全代码，它将定义有权访问并使用数据的人员。 </li> 
     </ol> 
     <p>Acegi 将减轻代码编写的工作，因此在这篇文章中，我将展示如何将用户和用户角色信息存储到 ApacheDS 中，然后实现这些信息的访问控制策略。在该系列的最后一篇文章中，我将展示如何配置 Acegi，实现对 Java 类的安全访问。 </p> 
     <p>您可以在本文的任何位置 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#download" cmimpressionsent="1">下载样例应用程序</a>。参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#resources" cmimpressionsent="1">参考资料</a> 下载 Acegi、Tomcat 和 ApacheDS，您需要使用它们运行样例代码和示例应用程序。</p> 
     <p><a name="section1.0"><span class="atitle">LDAP 基础知识</span></a></p> 
     <p>轻量级目录访问协议（Lightweight Directory Access Protocol，LDAP）可能是最流行的一种定义数据格式的协议，它针对常见的目录操作，例如对存储在目录服务器中的信息执行的读取、编辑、搜索和删除操作。本节将简要解释为什么目录服务器是属性文件存储安全信息的首选，并展示如何在 LDAP 目录中组织和托管用户信息。 </p> 
     <p><a name="section1.1"><span class="smalltitle">为什么要使用目录服务器？</span></a></p> 
     <p>本系列第一部分向您介绍了一种简单的方法，可以将用户信息以属性文件的形式保存起来（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#listing6" cmimpressionsent="1">第 1 部分，清单 6</a>）。属性文件以文本格式保存用户名、密码和用户角色。对于大多数真实应用程序而言，使用属性文件存储安全信息远远不够。各种各样的理由表明，目录服务器通常都是更好的选择。其中一个原因是，真实的企业应用程序可以被大量用户访问 ―― 通常是几千名用户，如果应用程序将其部分功能公开给用户和供应商时更是如此。频繁搜索文本文件中随意存储的信息，这样做的效率并不高，但是目录服务器对这类搜索进行了优化。 </p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#listing6" cmimpressionsent="1">第 1 部分的清单 6</a> 中的属性文件演示了另一个原因，该文件组合了用户和角色。在真实的访问控制应用程序中，您通常都需要分别定义和维护用户和角色信息，这样做可以简化用户库的维护。目录服务器为更改或更新用户信息提供了极大的灵活性，例如，反映职位升迁或新聘用人员。参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#resources" cmimpressionsent="1">参考资料</a> 以了解更多关于目录服务器的使用及其优点的信息。</p> 
     <p><a name="section1.2"><span class="smalltitle">LDAP 目录设置</span></a></p> 
     <p>如果希望将用户信息存储在一个 LDAP 目录中，您需要理解一些有关目录设置的内容。本文并没有提供对 LDAP 的完整介绍（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#resources" cmimpressionsent="1">参考资料</a>），而是介绍了一些在尝试结合使用 Acegi 和 LDAP 目录之前需要了解的基本概念。 </p> 
     <p>LDAP 目录以节点树的形式存储信息，如图 1 所示：</p> 
     <br /> 
     <a name="fig1"><strong>图 1. LDAP 目录的树状结构</strong></a>
     <br /> 
     <img height="303" alt="图 1. LDAP 目录的树状结构" src="http://www.ibm.com/developerworks/cn/java/j-acegi2/figure1.jpg" width="248" /> 
     <br /> 
     <p>在图 1 中，根节点的名称为 <code>org</code>。根节点可以封装与不同企业有关的数据。例如，本系列第 1 部分开发的制造业企业被显示为 <code>org</code> 节点的直接子节点。该制造业企业具有两个名为 <code>departments</code> 和 <code>partners</code> 的子节点。</p> 
     <p><code>partners</code> 子节点封装了不同类型的合作伙伴。图 1 所示的三个分别为 <code>customers</code>、<code>employees</code> 和 <code>suppliers</code>。注意，这三种类型的合作伙伴其行为与企业系统用户一样。每一种类型的用户所扮演的业务角色不同，因此访问系统的权利也不同。 </p> 
     <p>类似地，<code>departments</code> 节点包含该制造业企业的不同部门的数据 ―― 例如 <code>engineering</code> 和 <code>marketing</code> 字节点。每个部门节点还包含一组或多组用户。在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 中，<code>engineers</code> 组是 <code>engineering</code> 部门的子节点。</p> 
     <p>假设每个部门的子节点表示一组用户。因此，部门节点的子节点具有不同的用户成员。例如，设计部门的所有工程师都是 <code>engineering</code> 部门内 <code>engineers</code> 组的成员。</p> 
     <p>最后，注意 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 中 <code>departments</code> 节点的最后一个子节点。<code>specialUser</code> 是一名用户，而非一组用户。在目录设置中，像 <code>alice</code> 和 <code>bob</code> 之类的用户一般都包含在 <code>partners</code> 节点中。我将这个特殊用户包含在 <code>departments</code> 节点中，以此证明 Acegi 允许用户位于 LADP 目录中任何地点的灵活性。稍后在本文中，您将了解如何配置 Acegi 以应用 <code>specialUser</code>。</p> 
     <p><a name="section1.3"><span class="smalltitle">使用专有名称</span></a></p> 
     <p>LDAP 使用<em>专有名称</em>（DN）的概念来识别 LDAP 树上特定的节点。每个节点具有惟一的 DN，它包含该节点完整的层次结构信息。例如，图 2 展示了图 1 中的一些节点的 DN：</p> 
     <br /> 
     <a name="fig2"><strong>图 2. LDAP 目录节点的专有名称</strong></a>
     <br /> 
     <img height="242" alt="图 2. LDAP 目录节点的专有名称" src="http://www.ibm.com/developerworks/cn/java/j-acegi2/figure2.jpg" width="493" /> 
     <br /> 
     <p>首先，注意图 2 中根节点的 DN。它的 DN 为 <code>dc=org</code>，这是与 <code>org</code> 根节点相关的属性值对。每个节点都有若干个与之相关的属性。<code>dc</code> 属性代表 “domain component” 并由 LDAP RFC 2256 定义（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#resources" cmimpressionsent="1">参考资料</a> 中有关官方 RFC 文档的链接），LDAP 目录中的根节点通常表示为一个域组件。</p> 
     <p>每个 LDAP 属性是由 RFC 定义的。LDAP 允许使用多个属性创建一个 DN，但是本文的示例只使用了以下 4 个属性：</p> 
     <ul> 
      <li><code>dc</code>（域组件） </li>
      <li><code>o</code>（组织） </li>
      <li><code>ou</code>（组织单元） </li>
      <li><code>uid</code>（用户 ID） </li> 
     </ul> 
     <p>示例使用 <code>dc</code> 表示域，用 <code>o</code> 表示组织名称，<code>ou</code> 表示组织的不同单元，而 <code>uid</code> 表示用户。</p> 
     <p>由于 <code>org</code> 是根节点，其 DN 只需指定自身的名称（<code>dc=org</code>）。比较一下，<code>manufacturingEnterprise</code> 节点的 DN 是 <code>o=manufacturingEnterprise,dc=org</code>。当向下移动节点树时，每个父节点的 DN 被包含在其子节点的 DN 中。 </p> 
     <p><a name="section1.4"><span class="smalltitle">将属性分组</span></a></p> 
     <p>LDAP 将相关的属性类型分到对象类中。例如，名为 <code>organizationalPerson</code> 的对象类所包含的属性定义了在组织内工作的人员（例如，职称、常用名、邮寄地址等等）。 </p> 
     <p>对象类使用继承特性，这意味着 LDAP 定义了基类来保存常用属性。然后子类再对基类进行扩展，使用其定义的属性。LDAP 目录中的单个节点可以使用若干个对象类：本文的示例使用了以下几个对象类： </p> 
     <ul> 
      <li><strong>top</strong> 对象类是 LDAP 中所有对象类的基类。<br /> <br /> </li>
      <li>当其他对象类都不适合某个对象时，将使用 <strong>domain</strong> 对象类。它定义了一组属性，任何一个属性都可以用来指定一个对象。其 <code>dc</code> 属性是强制性的。<br /> <br /> </li>
      <li><strong>organization</strong> 对象类表示组织节点，例如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig2" cmimpressionsent="1">图 2</a> 中的 <code>manufacturingEnterprise</code>。<br /> <br /> </li>
      <li><strong>organizationalUnit</strong> 对象类表示组织内的单元，例如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 中的 <code>departments</code> 节点及其子节点。 <br /> <br /> </li>
      <li><strong>groupOfNames</strong> 对象类表示一组名称，例如某部门职员的名称。它具有一个 <code>member</code> 属性，该属性包含一个用户列表。<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 中所有的组节点（例如 <code>engineers</code> 节点）使用 <code>member</code> 属性指定该组的成员。而且，示例使用 <code>groupOfNames</code> 对象类的 <code>ou</code>（组织单元）属性指定组用户的业务角色。<br /> <br /> </li>
      <li><strong>organizationalPerson</strong> 对象类表示组织内某个职员（例如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 中的 <code>alice</code> 节点）。 </li> 
     </ul> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section2.0"><span class="atitle">使用 LDAP 服务器</span></a></p> 
     <p>在真实的应用程序中，通常将有关系统用户的大量信息托管在一个 LDAP 目录中。例如，将存储每个用户的用户名、密码、职称、联系方式和工资信息。为简单起见，下面的例子将只向您展示如何保存用户名和密码。 </p> 
     <p>如前所述，示例使用 ApacheDS（一种开源的 LDAP 目录服务器）演示了 Acegi 是如何使用 LDAP 目录的。示例还使用了一个开源的 LDAP 客户机（名为 JXplorer）执行简单的目录操作，例如将信息托管在 ApacheDS 上。参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#resources" cmimpressionsent="1">参考资料</a> 以下载 ApacheDS、JXplorer 并了解更多有关两者协作的信息。 </p> 
     <p><a name="section2.1"><span class="smalltitle">在 ApacheDS 创建一个根节点</span></a></p> 
     <p>要创建 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 所示的节点树，必须首先在 ApacheDS 中创建一个根节点 <code>org</code>。ApacheDS 为此提供了一个 XML 配置文件。XML 配置文件定义了一组可进行配置的 bean，从而根据应用程序的需求定制目录服务器的行为。本文只解释创建根节点所需的配置。</p> 
     <p>可以在 ApacheDS 安装中的 <code>conf</code> 文件夹找到名为 <code>server.xml</code> 的 XML 配置文件。打开文件后，会发现很多 bean 配置类似于 Acegi 的过滤器配置。查找名为 <code>examplePartitionsConfiguration</code> 的 bean。该 bean 控制 ApacheDS 上的分区。当创建新的根节点时，实际上将在 LDAP 目录上创建一个新的分区。</p> 
     <p>编辑 <code>examplePartitionConfiguration</code> bean 以创建 <code>org</code> 根节点，如清单 1 所示：</p> 
     <br /> 
     <a name="listing1"><strong>清单 1. 编辑模式的 examplePartitionConfiguration bean 配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;examplePartitionConfiguration&quot; class=
            &quot;org.apache.directory.server.core.partition.impl.btree.MutableBTreePartitionConfiguration&quot;
            &gt;
            &lt;property name=&quot;suffix&quot;&gt;&lt;value&gt;dc=org&lt;/value&gt;&lt;/property&gt;
            &lt;property name=&quot;contextEntry&quot;&gt;
            &lt;value&gt;
            objectClass: top
            objectClass: domain
            dc: org
            &lt;/value&gt;
            &lt;/property&gt;
            &lt;!-- Other properties of the examplePartitionConfiguration bean, which you don't
            need to edit. --&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>清单 1 编辑了 <code>examplePartitionConfiguration</code> bean 的两个属性：</p> 
     <ul> 
      <li>一个属性名为 <code>suffix</code>，它定义根条目的 DN。<br /> <br /> </li>
      <li>另一个属性名为 <code>contextEntry</code>，定义 <code>org</code> 节点将使用的对象类。注意，<code>org</code> 根节点使用两个对象类：<code>top</code> 和 <code>domain</code>。 </li> 
     </ul> 
     <p>本文的 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#download" cmimpressionsent="1">源代码下载</a> 部分包含了编辑模式的 server.xml 文件。如果希望继续学习本示例，请将 server.xml 文件从源代码中复制到您的 ApacheDS 安装目录中的正确位置，即 <code>conf</code> 文件夹。</p> 
     <p>图 3 所示的屏幕截图展示了在 ApacheDS 中创建根节点后，JXplorer 是如何显示该根节点的：</p> 
     <br /> 
     <a name="fig3"><strong>图 3. JXplorer 显示根节点</strong></a>
     <br /> 
     <img height="372" alt="图 3. JXplorer 显示根节点" src="http://www.ibm.com/developerworks/cn/java/j-acegi2/figure3.jpg" width="509" /> 
     <br /> 
     <p><a name="section2.2"><span class="smalltitle">填充服务器</span></a></p> 
     <p>设置 LDAP 服务器的下一步是使用用户和组信息填充服务器。您可以使用 JXplorer 在 ApacheDS 中逐个创建节点，但是使用 LDAP Data Interchange Format (LDIF) 填充服务器会更加方便。LDIF 是可被大多数 LDAP 实现识别的常见格式。developerWorks 文章很好地介绍了 LDIF 文件的内容，因此本文将不再做详细说明。（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#resources" cmimpressionsent="1">参考资料</a> 中有关 LDIF 的详细资料。）</p> 
     <p>您可以在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#download" cmimpressionsent="1">源代码下载</a> 部分查看 LDIF 文件，它表示 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 所示的用户和部门。您可以使用 JXplorer 将 LDIF 文件导入到 ApacheDS。要导入 LDIF 文件，在 JXplorer 中使用 <code>LDIF</code> 菜单，如图 4 所示：</p> 
     <br /> 
     <a name="fig4"><strong>图 4. 将 LDIF 文件导入到 ApacheDS</strong></a>
     <br /> 
     <img height="286" alt="图 4. 将 LDIF 文件导入到 ApacheDS" src="http://www.ibm.com/developerworks/cn/java/j-acegi2/figure4.jpg" width="528" /> 
     <br /> 
     <p>将 LDIF 文件导入到 ApacheDS 之后，JXplorer 将显示用户节点和部门节点树，如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 所示。现在您可以开始配置 Acegi，使其能够与您的 LDAP 服务器通信。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section3.0"><span class="atitle">为 LDAP 实现配置 Acegi</span></a></p> 
     <p>回想一下第 1 部分，其中 Acegi 使用身份验证处理过滤器（Authentication Processing Filter，APF）进行身份验证。APF 执行所有后端身份验证处理任务，例如从客户机请求中提取用户名和密码，从后端用户库读取用户参数，以及使用这些信息对用户进行身份验证。</p> 
     <p>您在第 1 部分中为属性文件实现配置了 APF，现在您已将用户库存储在 LDAP 目录中，因此必须使用不同的方式配置过滤器来和 LDAP 目录进行通信。首先看一下清单 2，它展示了在第 1 部分中的 “<a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#section4.2" cmimpressionsent="1">Authentication Processing Filter</a>” 一节中如何为属性文件实现配置 APF 过滤器：</p> 
     <br /> 
     <a name="listing2"><strong>清单 2. 为属性文件配置 APF</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;authenticationProcessingFilter&quot;
            class=&quot;org.acegisecurity.ui.webapp.AuthenticationProcessingFilter&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot; /&gt;
            &lt;property name=&quot;authenticationFailureUrl&quot;
            value=&quot;/login.jsp?login_error=1&quot; /&gt;
            &lt;property name=&quot;defaultTargetUrl&quot;
            value=&quot;/index.jsp&quot; /&gt;
            &lt;property name=&quot;filterProcessesUrl&quot;
            value=&quot;/j_acegi_security_check&quot; /&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>查看一下清单 2，您曾经为 APF 提供了 4 个参数。您只需在 LDAP 服务器中为存储重新配置第一个参数（<code>authenticationManager</code>）即可。其他三个参数保持不变。</p> 
     <p><a name="section3.1"><span class="smalltitle">配置身份验证管理器</span></a></p> 
     <p>清单 3 展示了如何配置 Acegi 的身份验证管理器，以实现与 LDAP 服务器的通信：</p> 
     <br /> 
     <a name="listing3"><strong>清单 3. 为 LDAP 配置 Acegi 的身份验证管理器</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;authenticationManager&quot;
            class=&quot;org.acegisecurity.providers.ProviderManager&quot;&gt;
            &lt;property name=&quot;providers&quot;&gt;
            &lt;list&gt;
            &lt;ref local=&quot;ldapAuthenticationProvider&quot; /&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>在清单 3 中，<code>org.acegisecurity.providers.ProviderManager</code> 是一个管理器类，它管理 Acegi 的身份验证过程。为此，身份验证管理器需要一个或多个身份验证提供者。您可以使用管理器 bean 的提供者属性来配置一个或多个提供者。清单 3 只包含了一个提供者，即 LDAP 身份验证提供者。 </p> 
     <p>LDAP 身份验证提供者处理所有与后端 LDAP 目录的通信。您必须对其进行配置，下一节内容将讨论该主题。 </p> 
     <p><a name="section3.2"><span class="smalltitle">配置 LDAP 身份验证提供者</span></a></p> 
     <p>清单 4 展示了 LDAP 身份验证提供者的配置： </p> 
     <br /> 
     <a name="listing4"><strong>清单 4. 配置 LDAP 身份验证提供者</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;ldapAuthenticationProvider&quot;
            class=&quot;org.acegisecurity.providers.ldap.LdapAuthenticationProvider&quot;&gt;
            &lt;constructor-arg&gt;&lt;ref local=&quot;authenticator&quot;/&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;&lt;ref local=&quot;populator&quot;/&gt;&lt;/constructor-arg&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>注意 LDAP 身份验证提供者类的名称为 <code>org.acegisecurity.providers.ldap.LdapAuthenticationProvider </code>。其构造函数包含两个参数，使用两个 <code>&lt;constructor-arg&gt;</code> 标记的形式，如清单 4 所示。</p> 
     <p><code>LdapAuthenticationProvider</code> 构造函数的第一个参数是 <code>authenticator</code>，该参数通过检查用户的用户名和密码对 LDAP 目录的用户进行身份验证。完成身份验证后，第二个参数 <code>populator</code> 将从 LDAP 目录中检索有关该用户的访问权限（或业务角色）信息。 </p> 
     <p>以下小节将向您展示如何配置验证器和填充器 bean。 </p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section4.0"><span class="atitle">配置验证器</span></a></p> 
     <p><code>authenticator</code> bean 将检查具有给定用户名和密码的用户是否存在于 LDAP 目录中。Acegi 提供了名为 <code>org.acegisecurity.providers.ldap.authenticator.BindAuthenticator</code> 的验证器类，它将执行验证用户名和密码所需的功能。</p> 
     <p>配置 <code>authenticator</code> bean，如清单 5 所示：</p> 
     <br /> 
     <a name="listing5"><strong>清单 5. 配置验证器 bean</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;authenticator&quot;
            class=&quot;org.acegisecurity.providers.ldap.authenticator.BindAuthenticator&quot;&gt;
            &lt;constructor-arg&gt;&lt;ref local=&quot;initialDirContextFactory&quot;/&gt;&lt;/constructor-arg&gt;
            &lt;property name=&quot;userDnPatterns&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;uid={0},ou=employees,ou=partners&lt;/value&gt;
            &lt;value&gt;uid={0},ou=customers,ou=partners&lt;/value&gt;
            &lt;value&gt;uid={0},ou=suppliers,ou=partners&lt;/value&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;property name=&quot;userSearch&quot;&gt;&lt;ref local=&quot;userSearch&quot;/&gt;&lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>在清单 5 中，<code>BindAuthenticator</code> 构造函数具有一个参数，使用 <code>&lt;constructor-arg&gt;</code> 标记的形式。清单 5 中参数的名称为 <code>initialDirContextFactory</code>。该参数实际上是另一个 bean，稍后您将学习如何配置该 bean。</p> 
     <p>目前为止，只知道 <code>initialDirContextFactory</code> bean 的作用就是为稍后的搜索操作指定初始上下文。初始上下文是一个 DN，它指定了 LDAP 目录内某个节点。指定初始上下文后，将在该节点的子节点中执行所有的搜索操作（例如查找特定用户）。</p> 
     <p>例如，回到 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig2" cmimpressionsent="1">图 2</a> 中查看 <code>partners</code> 节点，它的 DN 是 <code>ou=partners,o=manufacturingEnterprise,dc=org</code>。如果将 <code>partners</code> 节点指定为初始上下文，Acegi 将只在 <code>partners</code> 节点的子节点中查找用户。 </p> 
     <p><a name="section4.1"><span class="smalltitle">指定 DN 模式</span></a></p> 
     <p>除配置 <code>BindAuthenticator</code> 构造函数外，还必须配置 <code>authenticator</code> bean 的两个属性（<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中的两个 <code>&lt;property&gt;</code> 标记）。</p> 
     <p>第一个 <code>&lt;property&gt;</code> 标记定义了一个 <code>userDnPatterns</code> 属性，它封装了一个或多个 DN 模式列表。<em>DN 模式</em> 指定了一组具有类似特性的 LDAP 节点（例如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig2" cmimpressionsent="1">图 2</a> 所示的 <code>employees</code> 节点的所有子节点）。</p> 
     <p>Acegi 的身份验证器从 <code>authenticator</code> bean 的 <code>userDnPatterns</code> 属性中配置的每个 DN 模式构造了一个 DN。例如，查看 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中配置的第一个模式，即 <code>uid={0},ou=employees,ou=partners</code>。在进行身份验证的时候，<code>authenticator</code> bean 使用用户提供的用户名（比如 <code>alice</code>）替换了 <code>{0}</code>。使用用户名取代了 <code>{0}</code> 之后，DN 模式将变为相对 DN（RDN）<code>uid=alice,ou=employees,ou=partners</code>，它需要一个初始上下文才能成为 DN。</p> 
     <p>例如，查看 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig2" cmimpressionsent="1">图 2</a> 中的 <code>alice's</code> 条目。该条目是 <code>employees</code> 节点的第一个子节点。它的 DN 是 <code>uid=alice,ou=employees,ou=partners,o=manufacturingEnterprise, dc=org</code>。如果使用 <code>o=manufacturingEnterprise,dc=org</code> 作为初始上下文并将其添加到 RDN <code>uid=alice,ou=employees,ou=partners</code> 之后，将获得 alice 的 DN。</p> 
     <p>使用这种方法通过 DN 模式构建了用户的 DN 后，<code>authenticator</code> 将把 DN 和用户密码发送到 LDAP 目录。目录将检查该 DN 是否具有正确的密码。如果有的话，用户就可以通过身份验证。这个过程在 LDAP 术语中被称为 <em>bind 身份验证</em>。LDAP 还提供了其他类型的身份验证机制，但是本文的示例只使用了 bind 身份验证。</p> 
     <p>如果目录中并没有第一个 DN 模式创建的 DN，<code>authenticator</code> bean 尝试使用列表中配置的第二个 DN 模式。依此类推，<code>authenticator</code> bean 将尝试所有的 DN 模式来为进行身份验证的用户构造正确的用户 DN。</p> 
     <p><a name="section4.2"><span class="smalltitle">搜索过滤器</span></a></p> 
     <p>回想一下较早的章节 “<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#section1.2" cmimpressionsent="1">LDAP 目录设置</a>”，我在将用户信息存储到 LDAP 目录时添加了一点灵活性。方法是在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig1" cmimpressionsent="1">图 1</a> 所示的 <code>departments</code> 节点内创建一个特定用户（<code>specialUser</code>）。</p> 
     <p>如果试图使用 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中配置的任何一种 DN 模式创建特定用户的 DN，您会发现没有一种 DN 模式可用。因此，当用户尝试登录时，Acegi 的 <code>authenticator</code> bean 将不能够构造正确的 DN，从而无法对该用户进行身份验证。</p> 
     <p>通过允许您指定搜索过滤器，Acegi 能够处理类似的特殊情况。身份验证器 bean 使用搜索过滤器查找不能够通过 DN 模式构造 DN 进行身份验证的用户。 </p> 
     <p><a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中的第二个 <code>&lt;property&gt;</code> 标记具有一个 <code>&lt;ref&gt;</code> 子标记，它引用名为 <code>userSearch</code> 的 bean。<code>userSearch</code> bean 指定搜索查询。清单 6 展示了如何配置 <code>userSearch</code> bean 来处理特定用户：</p> 
     <br /> 
     <a name="listing6"><strong>清单 6. 配置搜索查询以搜索特定用户</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;userSearch&quot;
            class=&quot;org.acegisecurity.ldap.search.FilterBasedLdapUserSearch&quot;&gt;
            &lt;constructor-arg&gt;
            &lt;value&gt;ou=departments&lt;/value&gt;
            &lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;
            &lt;value&gt;(uid={0})&lt;/value&gt;
            &lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;
            &lt;ref local=&quot;initialDirContextFactory&quot; /&gt;
            &lt;/constructor-arg&gt;
            &lt;property name=&quot;searchSubtree&quot;&gt;
            &lt;value&gt;true&lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p><strong>搜索查询的参数</strong> <br /> <br /> 清单 6 展示了 <code>userSearch</code> bean 是 <code>org.acegisecurity.ldap.search.FilterBasedLdapUserSearch</code> 类的一个实例，该类的构造函数具有三个参数。第一个参数指定 <code>authenticator</code> 在哪个节点中搜索用户。第一个参数的值为 <code>ou=departments</code>，该值是一个 RDN，指定了 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#fig2" cmimpressionsent="1">图 2</a> 所示的 <code>departments</code> 节点。</p> 
     <p>第二个参数 <code>(uid={0})</code> 指定了一个搜索过滤器。由于使用 <code>uid</code> 属性指定用户，因此可以通过查找 <code>uid</code> 属性具有特定值的节点来查找用户。正如您所料，花括号里面的 0 向 Acegi 表示使用进行身份验证的用户的用户名（本例中为 <code>specialUser</code>）替换 <code>{0}</code>。 </p> 
     <p>第三个参数是对讨论 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中的 <code>BindAuthenticator</code> 构造函数时引入的相同初始上下文的引用。回想一下，当指定了初始上下文后，稍后将在该初始上下文节点的子节点内进行所有的搜索操作。注意，应将指定为 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中第一个参数（<code>ou=departments</code>）的值的 RDN 前加到初始上下文。</p> 
     <p>除了这三个构造器参数，清单 6 所示的 <code>userSearch</code> bean 还具有一个名为 <code>searchSubtree</code> 的属性。如果将其值指定为 <code>true</code>，搜索操作将包括节点的子树（即所有子节点、孙节点、孙节点的子节点等），该节点被指定为构造函数的第一个参数的值。 </p> 
     <p><code>authenticator</code> bean 的配置完成后，下一步将查看 <code>populator</code> bean 的配置，如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing4" cmimpressionsent="1">清单 4</a> 所示。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section5.0"><span class="atitle">配置 populator</span></a></p> 
     <p><code>populator</code> bean 将读取已经通过 <code>authenticator</code> bean 身份验证的用户的业务角色。清单 7 展示 <code>populator</code> bean 的 XML 配置：</p> 
     <br /> 
     <a name="listing7"><strong>清单 7. populator bean 的 XML 配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;populator&quot;
            class=&quot;org.acegisecurity.providers.ldap.populator.DefaultLdapAuthoritiesPopulator&quot;&gt;
            &lt;constructor-arg&gt;
            &lt;ref local=&quot;initialDirContextFactory&quot;/&gt;
            &lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;
            &lt;value&gt;ou=departments&lt;/value&gt;
            &lt;/constructor-arg&gt;
            &lt;property name=&quot;groupRoleAttribute&quot;&gt;
            &lt;value&gt;ou&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;searchSubtree&quot;&gt;
            &lt;value&gt;true&lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>在清单 7 中，<code>populator</code> bean 的构造函数包括 2 个参数，以及一个 <code>groupRoleAttribute</code> 属性。构造函数的第一个参数指定了 <code>populator</code> bean 用来读取经过验证用户的业务角色的初始上下文。并不强制要求 <code>authenticator</code> 和 <code>populator</code> bean 使用相同的初始上下文。您可以为这两者分别配置一个初始上下文。</p> 
     <p>第二个构造函数参数指定了 populator 前加到初始上下文的 RDN。因此，RDN 组成了包含组用户的节点的 DN，例如 <code>departments</code> 节点。</p> 
     <p><code>populator</code> bean 的 <code>groupRoleAttribute</code> 属性指定了持有组成员业务角色数据的属性。回想 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#section1.2" cmimpressionsent="1">设置 LDAP 目录</a> 一节中，您将每组用户的业务角色信息存储在名为 <code>ou</code> 的属性中。然后将 <code>ou</code> 设置为 <code>groupRoleAttribute</code> 属性的值，如 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing7" cmimpressionsent="1">清单 7</a> 所示。 </p> 
     <p>如您所料，<code>populator</code> bean 将搜索整个 LDAP 目录来查找经过验证的用户所属的组节点。然后读取组节点的 <code>ou</code> 属性的值，获取用户经过授权的业务角色。</p> 
     <p>这样就完成了 <code>populator</code> bean 的配置。目前为止，我们在三个位置使用了初始上下文：<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a>、<a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing6" cmimpressionsent="1">清单 6</a> 和 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing7" cmimpressionsent="1">清单 7</a>。接下来将了解如何配置初始上下文。</p> 
     <p><a name="section5.1"><span class="smalltitle">配置初始上下文</span></a></p> 
     <p>清单 8 展示了在 Acegi 中配置初始上下文的过程：</p> 
     <br /> 
     <a name="listing8"><strong>清单 8. 初始上下文的 XML 配置</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;initialDirContextFactory&quot;
            class=&quot;org.acegisecurity.ldap.DefaultInitialDirContextFactory&quot;&gt;
            &lt;constructor-arg value=&quot;ldap://localhost:389/o=manufacturingEnterprise,dc=org&quot;/&gt;
            &lt;property name=&quot;managerDn&quot;&gt;
            &lt;value&gt;cn=manager,o=manufacturingEnterprise,dc=org&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;managerPassword&quot;&gt;
            &lt;value&gt;secret&lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>清单 8 中 Acegi 的初始上下文类的名称为 <code>org.acegisecurity.ldap.DefaultInitialDirContextFactory</code>，这是 Acegi 包含的工厂类。Acegi 在内部使用该类构造其他处理目录操作（例如在整个目录中搜索）的类的对象。当配置初始上下文工厂时，必须指定以下内容： </p> 
     <ul> 
      <li>将您的 LDAP 目录和根目录节点的网络地址指定为构造函数的参数。在初始上下文配置的节点将作为根节点。就是说所有后续操作（例如 <code>search</code>）都将在根节点定义的子树中执行。<br /> <br /> </li>
      <li>将 DN 和密码分别定义为 <code>managerDn</code> 和 <code>managerPassword</code> 属性。在执行任何搜索操作之前，Acegi 必须使用目录服务器对 DN 和密码进行身份验证。 </li> 
     </ul> 
     <p>您已经了解了如何将用户库托管在 LDAP 目录中，以及如何配置 Acegi 来使用来自 LDAP 目录的信息对用户进行身份验证。下一节将进一步介绍 Acegi 的身份验证处理过滤器，了解新配置的 bean 是如何管理身份验证过程的。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section6.0"><span class="atitle">身份验证和授权</span></a></p> 
     <p>APF 配置完成后，将能够与 LDAP 目录进行通信来对用户进行身份验证。如果您阅读过第 1 部分，那么对与目录通信过程中 APF 执行的一些步骤不会感到陌生，我在第 1 部分中向您展示了过滤器如何使用不同的服务进行用户身份验证。图 5 所示的序列表与您在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#fig3" cmimpressionsent="1">第 1 部分图 3</a> 看到的非常类似：</p> 
     <br /> 
     <a name="fig5"><strong>图 5. APF 对一名 LDAP 用户进行身份验证</strong></a>
     <br /> 
     <img height="464" alt="图 5. APF 对一名 LDAP 用户进行身份验证" src="http://www.ibm.com/developerworks/cn/java/j-acegi2/figure5.jpg" width="351" /> 
     <br /> 
     <p>无论 APF 使用属性文件进行内部的身份验证还是与 LDAP 服务器进行通信，步骤 1 到步骤 9 与第 1 部分是相同的。这里简单描述了前 9 个步骤，您可以从步骤 10 开始继续学习特定于 LDAP 的事件：</p> 
     <ol> 
      <li>过滤器链前面的过滤器将请求、响应和过滤器链对象传递给 APF。<br /> <br /> </li>
      <li>APF 使用取自请求对象的用户名、密码和其他信息创建一个身份验证标记。<br /> <br /> </li>
      <li>APF 将身份验证标记传递给身份验证管理器。<br /> <br /> </li>
      <li>身份验证管理器可能包含一个或多个身份验证提供者。每个提供者恰好支持一种身份验证类型。管理器将检查哪一种提供者支持从 APF 接收到的身份验证标记。 <br /> <br /> </li>
      <li>身份验证管理器将身份验证标记传递给适合该类型身份验证的提供者。 <br /> <br /> </li>
      <li>身份验证提供者从身份验证标记中提取用户名并将其传递到名为 user cache service 的服务。Acegi 缓存了已经进行过身份验证的用户。该用户下次登录时，Acegi 可以从缓存中加载他或她的详细信息（比如用户名、密码和权限），而不是从后端数据存储中读取数据。这种方法使得性能得到了改善。<br /> <br /> </li>
      <li>user cache service 检查用户的详细信息是否存在于缓存中。<br /> <br /> </li>
      <li>user cache service 将用户的详细信息返回给身份验证提供者。如果缓存不包含用户详细信息，则返回 null。<br /> <br /> </li>
      <li>身份验证提供者检查缓存服务返回的是用户的详细信息还是 null。<br /> <br /> </li>
      <li><strong>从这里开始，身份验证处理将特定于 LDAP。</strong> 如果缓存返回 null，LDAP 身份验证提供者将把用户名（在步骤 6 中提取的）和密码传递给 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 中配置的 <code>authenticator</code> bean。<br /> <br /> </li>
      <li><code>authenticator</code> 将使用在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing5" cmimpressionsent="1">清单 5</a> 的 <code>userDnPatterns</code> 属性中配置的 DN 模式创建用户 DN。通过从一个 DN 模式中创建一个 DN，然后将该 DN 和用户密码（从用户请求中获得）发送到 LDAP 目录，它将逐一尝试所有可用的 DN 模式。LDAP 目录将检查该 DN 是否存在以及密码是否正确。如果其中任何一个 DN 模式可行的话，用户被绑定到 LDAP 目录中，<code>authenticator</code> 将继续执行步骤 15。 <br /> <br /> </li>
      <li>如果任何一种 DN 模式都不能工作的话（这意味着在 DN 模式指定的任何位置都不存在使用给定密码的用户），<code>authenticator</code> 根据 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing6" cmimpressionsent="1">清单 6</a> 配置的搜索查询在 LDAP 目录中搜索用户。如果 LDAP 目录没有找到用户，那么身份验证以失败告终。<br /> <br /> </li>
      <li>如果 LDAP 目录查找到了用户，它将用户的 DN 返回到 <code>authenticator</code>。<br /> <br /> </li>
      <li><code>authenticator</code> 将用户 DN 和密码发送到 LDAP 目录来检查用户密码是否正确。如果 LDAP 目录发现用户密码是正确的，该用户将被绑定到 LDAP 目录。<br /> <br /> </li>
      <li><code>authenticator</code> 将用户信息发送回 LDAP 身份验证提供者。<br /> <br /> </li>
      <li>LDAP 身份验证提供者将控制权传递给 <code>populator</code> bean。<br /> <br /> </li>
      <li><code>populator</code> 搜索用户所属的组。<br /> <br /> </li>
      <li>LDAP 目录将用户角色信息返回给 <code>populator</code>。<br /> <br /> </li>
      <li><code>populator</code> 将用户角色信息返回给 LDAP 身份验证提供者。<br /> <br /> </li>
      <li>LDAP 身份验证提供者将用户的详细信息（以及用户业务角色信息）返回给 APF。用户现在成功进行了身份验证。 </li> 
     </ol> 
     <p>不论使用何种身份验证方法，最后三个步骤是相同的（步骤21、21 和 23）。</p> 
     <p><a name="section6.1"><span class="smalltitle">配置拦截器</span></a></p> 
     <p>您已经了解了 APF 对用户进行身份验证的步骤。接下来是查看成功进行身份验证的用户是否被授权访问所请求的资源。这项任务由 Acegi 的拦截过滤器（Interceptor Filter，IF）完成。本节将向您展示如何配置 IF 来实现访问控制策略。 </p> 
     <p>回想一下在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/index.html#listing7" cmimpressionsent="1">第 1 部分的清单 7</a> 中配置 IF 的步骤。拦截过滤器在资源和角色之间建立映射，就是说只有具备必要角色的用户才能访问给定资源。为了演示制造业企业中不同部门的业务角色，清单 9 向现有的 IF 配置添加了另外的角色：</p> 
     <br /> 
     <a name="listing9"><strong>清单 9. 配置拦截过滤器</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;filterInvocationInterceptor&quot;
            class=&quot;org.acegisecurity.intercept.web.FilterSecurityInterceptor&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot; /&gt;
            &lt;property name=&quot;accessDecisionManager&quot; ref=&quot;accessDecisionManager&quot; /&gt;
            &lt;property name=&quot;objectDefinitionSource&quot;&gt;
            &lt;value&gt;
            CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
            PATTERN_TYPE_APACHE_ANT
            /protected/engineering/**=ROLE_HEAD_OF_ENGINEERING
            /protected/marketing/**=ROLE_HEAD_OF_MARKETING
            /**=IS_AUTHENTICATED_ANONYMOUSLY
            &lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>在清单 9 中，IF 包含三个参数。其中第一个和第三个参数与第 1 部分中最初配置的参数相同。这里添加了第二个参数（名为 <code>accessDecisionManager</code> 的 bean）。</p> 
     <p><code>accessDecisionManager</code> bean 负责指定授权决策。它使用清单 9 中第三个参数提供的访问控制定义来指定授权（或访问控制）决策。第三个参数是 <code>objectDefinitionSource</code>。</p> 
     <p><a name="section6.2"><span class="smalltitle">配置访问决策管理器</span></a></p> 
     <p><code>accessDecisionManager</code> 决定是否允许一个用户访问某个资源。Acegi 提供了一些访问决策管理器，它们指定访问控制决策的方式有所不同。本文只解释了其中一种访问决策管理器的工作方式，其配置如清单 10 所示： </p> 
     <br /> 
     <a name="listing10"><strong>清单 10. 配置访问决策管理器</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;accessDecisionManager&quot; class=&quot;org.acegisecurity.vote.AffirmativeBased&quot;&gt;
            &lt;property name=&quot;decisionVoters&quot;&gt;
            &lt;list&gt;
            &lt;bean class=&quot;org.acegisecurity.vote.RoleVoter&quot;/&gt;
            &lt;bean class=&quot;org.acegisecurity.vote.AuthenticatedVoter&quot; /&gt;
            &lt;/list&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>在清单 10 中，<code>accessDecisionManager</code> bean 是 <code>org.acegisecurity.vote.AffirmativeBased</code> 类的实例。<code>accessDecisionManager</code> bean 只包含一个参数，即<em>投票者（voter）</em>列表。</p> 
     <p>在 Acegi 中，投票者确定是否允许某个用户访问特定的资源。当使用 <code>accessDecisionManager</code> 查询时，投票者具有三个选项：允许访问（access-granted）、拒绝访问（access-denied），如果不确定的话则放弃投票（abstain from voting）。</p> 
     <p>不同类型的访问决策管理器解释投票者决策的方法也有所不同。清单 10 所示的 <code>AffirmativeBased</code> 访问决策管理器实现了简单的决策逻辑：如果任何投票者强制执行肯定投票，将允许用户访问所请求的资源。</p> 
     <p><a name="section6.3"><span class="smalltitle">投票者逻辑</span></a></p> 
     <p>Acegi 提供了若干个投票者实现类型。<code>accessDecisionManager</code> 将经过验证的用户的信息（包括用户的业务角色信息）和 <code>objectDefinitionSource</code> 对象传递给投票者。本文的示例使用了两种类型的投票者，<code>RoleVoter</code> 和 <code>AuthenticatedVoter</code>，如清单 10 所示。现在看一下每种投票者的逻辑：</p> 
     <ul> 
      <li><strong>RoleVoter</strong> 只有在 <code>objectDefinitionSource</code> 对象的行中找到以 <code>ROLE_ </code>前缀开头的角色时才进行投票。如果 <code>RoleVoter</code> 没有找到这样的行，将放弃投票；如果在用户业务角色中找到一个匹配的角色，它将投票给允许访问；如果没有找到匹配的角色，则投票给拒绝访问。在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing9" cmimpressionsent="1">清单 9</a> 中，有两个角色具有 <code>ROLE_</code> 前缀：<code>ROLE_HEAD_OF_ENGINEERING</code> 和 <code>ROLE_HEAD_OF_MARKETING</code>。<br /> <br /> </li>
      <li><strong>AuthenticatedVoter</strong> 只有在 <code>objectDefinitionSource</code> 对象中找到具有某个预定义角色的行时才进行投票。在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#listing9" cmimpressionsent="1">清单 9</a> 中，有这样一行：<code>IS_AUTHENTICATED_ANONYMOUSLY</code>。匿名身份验证意味着用户不能够进行身份验证。找到该行后，<code>AuthenticatedVoter</code> 将检查一个匿名身份验证的用户是否可以访问某些不受保护的资源（即这些资源没有包含在具备 <code>ROLE_</code> 前缀的行中）。如果 <code>AuthenticatedVoter</code> 发现所请求的资源是不受保护的并且 <code>objectDefinitionSource</code> 对象允许匿名身份验证的用户访问不受保护的资源，它将投票给允许访问；否则就投票给拒绝访问。 </li> 
     </ul> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section7.0"><span class="atitle">示例应用程序</span></a></p> 
     <p>本文提供了一个示例应用程序，它将演示您目前掌握的 LDAP 和 Acegi 概念。LDAP-Acegi 应用程序将显示一个索引页面，该页面将设计和销售文档呈现给合适的经过身份验证的用户。正如您将看到的一样，LDAP-Acegi 应用程序允许用户 <code>alice</code> 查看设计文档，并允许用户 <code>bob</code> 查看销售文档。它还允许特定用户同时查看设计和销售文档。所有这些内容都是在本文开头配置 LDAP 目录服务器时设置的。立即 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#download" cmimpressionsent="1">下载示例应用程序</a> 来开始使用它。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi2/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section8.0"><span class="atitle">结束语</span></a></p> 
     <p>在本文中，您了解了如何将用户和业务角色信息托管在 LDAP 目录中。您还详细了解了配置 Acegi 的方法，从而与 LDAP 目录交互实现访问控制策略。在本系列最后一期文章中，我将展示如何配置 Acegi 来保护对 Java 类的访问。</p> 
     <br /> 
     <br /> 来自:http://www.cnblogs.com/amboyna/archive/2008/03/25/1122084.html 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199311.html" title="permalink">2008-05-08 18:43</a> 狼爱上狸 阅读(244) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199311.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=199311">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=199311">收藏</a> </p> 
    </div> 
    <div class="post"> 
     <h2><a id="homepage1_HomePageDays_ctl00_DayList_ctl09_TitleUrl" href="http://www.blogjava.net/waterjava/archive/2008/05/08/199309.html">acegi,IBM的Acegi Security System（1） </a></h2> 
     <p>2007 年 5 月 08 日</p> 
     <blockquote>
      这份共分三部分的系列文章介绍了 Acegi 安全系统（Acegi Security System），它是用于 Java64 企业应用程序的强大的开源安全框架。在第一篇文章中，Bilal Siddiqui 顾问将向您介绍 Acegi 的架构和组件，并展示如何使用它来保护一个简单的 Java 企业应用程序。
     </blockquote>
     <!--start RESERVED FOR FUTURE USE INCLUDE FILES-->
     <!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters -->
     <!--end RESERVED FOR FUTURE USE INCLUDE FILES--> 
     <p>Acegi Security System 是一种功能强大并易于使用的替代性方案，使您不必再为 Java 企业应用程序编写大量的安全代码。虽然它专门针对使用 Spring 框架编写的应用程序，但是任何类型的 Java 应用程序都没有理由不去使用 Acegi。这份共分三部分的系列文章详细介绍了 Acegi，并展示了如何使用它保护简单的企业应用程序以及更复杂的应用程序。</p> 
     <p>本系列首先介绍企业应用程序中常见的安全问题，并说明 Acegi 如何解决这些问题。您将了解 Acegi 的架构模型及其安全过滤器，后者包含了在保护应用程序中将用到的大多数功能。您还将了解到各个过滤器如何单独进行工作，如何将它们组合起来，以及过滤器如何在一个企业安全实现中将各种功能从头到尾地链接起来。本文最后通过一个样例应用程序演示了基于 URL 安全系统的 Acegi 实现。本系列后续两篇文章将探究 Acegi 的一些更高级的应用，包括如何设计和托管访问控制策略，然后如何去配置 Acegi 以使用这些策略。</p> 
     <p>您必须 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#section6.2" cmimpressionsent="1">下载 Acegi</a>，这样才能编译本文的示例代码并运行本文的样例应用程序。还必须有作为工作站的一部分运行的 Tomcat 服务器。</p> 
     <p><a name="section1"><span class="atitle">企业应用程序安全性</span></a></p> 
     <p>由于企业内容管理（ECM）应用程序管理存储在不同类型数据源（如文件系统、关系数据库和目录服务）中的企业内容的编写和处理，ECM 安全性要求对这些数据源的访问进行控制。比如，一个 ECM 应用程序可能会控制被授权读取、编辑或删除数据的对象，而这些数据和制造业企业的设计、市场营销、生产以及质量控制有关。</p> 
     <p>在一个 ECM 安全场景中，比较常见的就是通过对企业资源定位符（或网络地址）应用安全性，从而实现访问控制。这种简单的安全模型被称为<em>统一资源定位符</em> 或 URL 安全性。正如我在本文后面（以及本系列后续文章）所演示的一样，Acegi 为实现 URL 安全性提供了全面的特性。</p> 
     <p>然而，在很多企业场景中，URL 安全性还远远不够。比如，假设一个 PDF 文档包含某个制造业公司生产的特殊产品的数据。文档的一部分包含了将由该公司的设计部门编辑和更新的设计数据。另一部分包含了生产经理将使用的生产数据。对于诸如此类的场景，需要实现更加细粒度的安全性，对文档的不同部分应用不同的访问权限。</p> 
     <p>本文介绍了 Acegi 为实现 URL 安全性而提供的各种功能。本系列的下一篇文章将演示此框架的基于方法的安全性，它提供了对企业数据访问的更细粒度的控制。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section2"><span class="atitle">Acegi Security System</span></a></p> 
     <p>Acegi Security System 使用安全过滤器来提供企业应用程序的身份验证和授权服务。该框架提供了不同类型的过滤器，可以根据应用程序的需求进行配置。您将在本文后面了解到 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#section4" cmimpressionsent="1">安全过滤器的不同类型</a>；现在，只需注意可以为如下任务配置 Acegi 安全过滤器：</p> 
     <ol> 
      <li>在访问一个安全资源之前提示用户登录。<br /> <br /> </li>
      <li>通过检查安全标记（如密码），对用户进行身份验证。<br /> <br /> </li>
      <li>检查经过身份验证的用户是否具有访问某个安全资源的特权。<br /> <br /> </li>
      <li>将成功进行身份验证和授权的用户重定向到所请求的安全资源。<br /> <br /> </li>
      <li>对不具备访问安全资源特权的用户显示 Access Denied 页面。<br /> <br /> </li>
      <li>在服务器上记录成功进行身份验证的用户，并在用户的客户机上设置安全 cookie。使用该 cookie 执行下一次身份验证，而无需要求用户登录。<br /> <br /> </li>
      <li>将身份验证信息存储在服务器端的会话对象中，从而安全地进行对资源的后续请求。<br /> <br /> </li>
      <li>在服务器端对象中构建并保存安全信息的缓存，从而优化性能。<br /> <br /> </li>
      <li>当用户退出时，删除为用户安全会话而保存的服务器端对象。<br /> <br /> </li>
      <li>与大量后端数据存储服务（如目录服务或关系数据库）进行通信，这些服务用于存储用户的安全信息和 ECM 的访问控制策略。 </li> 
     </ol> 
     <p>正如这个列表显示的那样，Acegi 的安全过滤器允许您执行保护企业应用程序所需的几乎任何事情。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section3"><span class="atitle">架构和组件</span></a></p> 
     <p>对 Acegi 了解越多，使用起来就越简单。这一节介绍 Acegi 的组件；接下来您将了解该框架如何使用反转控制（IOC）和 XML 配置文件来组合组件并表示它们的依赖关系。 </p> 
     <p><a name="section3.1"><span class="smalltitle">四大组件</span></a></p> 
     <p>Acegi Security System 由四种主要类型的组件组成：过滤器、管理器、提供者和处理程序。</p> 
     <dl> 
      <dt>
       <strong>过滤器</strong> 
      </dt>
      <dd>
       这种最高级的组件提供了常见的安全服务，如身份验证、会话处理以及注销。我将在 
       <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#section4" cmimpressionsent="1">本文后面的部分</a> 深入讨论过滤器。 
      </dd>
      <dt>
       <strong>管理器</strong> 
      </dt>
      <dd>
       过滤器仅是安全相关功能的高级抽象：实际上要使用管理器和提供者实现身份验证处理和注销服务。管理器管理由不同提供者提供的较低级的安全服务。 
      </dd>
      <dt>
       <strong>提供者</strong> 
      </dt>
      <dd>
       有大量的提供者可用于和不同类型的数据存储服务通信，例如目录服务、关系数据库或简单的内存中的对象。这意味着您可以将用户库和访问控制协议存储在任何一种这样的数据存储服务中，并且 Acegi 的管理器将在运行时选择合适的提供者。 
      </dd>
      <dt>
       <strong>处理程序</strong> 
      </dt>
      <dd>
       有时任务可能会被分解为多个步骤，其中每个步骤由一个特定的处理程序执行。比方说，Acegi 的 
       <em>注销过滤器</em> 使用两个处理程序来退出一个 HTTP 客户机。其中一个处理程序使用户的 HTTP 会话无效，而另一个处理程序则删除用户的 cookie。当根据应用程序需求配置 Acegi 时，多个处理程序能够提供很好的灵活性。您可以使用自己选择的处理程序来执行保护应用程序所需的步骤。 
      </dd>
     </dl> 
     <p><a name="section3.2"><span class="smalltitle">反转控制</span></a></p> 
     <p>Acegi 的组件通过彼此之间的依赖来对企业应用程序进行保护。比如，一个身份验证处理过滤器需要一个身份验证管理器选择一个合适的身份验证提供者。这就是说您必须能够表示和管理 Acegi 组件的依赖关系。 </p> 
     <p>IOC 实现通常用于管理 Java 组件之间的依赖关系。IOC 提供了两个重要的特性：</p> 
     <ol> 
      <li>它提供了一种语法，表示应用程序所需的组件以及这些组件如何相互依赖。<br /> <br /> </li>
      <li>它保证了所需的组件在运行时是可用的。 </li> 
     </ol> 
     <p><a name="section3.3"><span class="smalltitle">XML 配置文件</span></a></p> 
     <p>Acegi 使用 Spring 框架（请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#resources" cmimpressionsent="1">参考资料</a>）附带的流行开源 IOC 实现来管理其组件。Spring 需要您编写一个 XML 配置文件来表示组件的依赖关系，如清单 1 所示：</p> 
     <br /> 
     <a name="listing1"><strong>清单 1. Spring 配置文件的结构</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;beans&gt;
            &lt;bean id=&quot;filterChainProxy&quot; class=&quot;org.acegisecurity.util.FilterChainProxy&quot;&gt;
            &lt;property name=&quot;filterInvocationDefinitionSource&quot;&gt;
            &lt;value&gt; value here &lt;/value&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            &lt;bean id=&quot;authenticationProcessingFilter&quot;
            class=&quot;org.acegisecurity.ui.webapp.AuthenticationProcessingFitler&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot; ref=&quot;authManager&quot;/&gt;
            &lt;!-- Other properties --&gt;
            &lt;/bean&gt;
            &lt;bean id=&quot;authManager&quot;
            class=&quot;org.acegisecurity.providers.ProviderManager&quot;&gt;
            &lt;property name=&quot;providers&quot;&gt;
            &lt;!--  List of providers here --&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            &lt;!-- Other bean tags --&gt;
            &lt;/beans&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>如您所见，Acegi 使用的 Spring XML 配置文件包含一个 <code>&lt;beans&gt;</code> 标记，它封装了一些其他的 <code>&lt;bean&gt;</code> 标记。所有的 Acegi 组件（即过滤器、管理器、提供者等）实际上都是 JavaBean。XML 配置文件中的每个 <code>&lt;bean&gt;</code> 标记都代表一个 Acegi 组件。</p> 
     <p><strong>进一步解释 XML 配置文件</strong> <br /> <br /> 首先将注意到的是每个 <code>&lt;bean&gt;</code> 标记都包含一个 <em>class</em> 属性，这个属性标识组件所使用的类。<code>&lt;bean&gt;</code> 标记还具有一个 <em>id</em> 属性，它标识作为 Acegi 组件工作的实例（Java 对象）。</p> 
     <p>比方说，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#listing1" cmimpressionsent="1">清单 1</a> 的第一个 <code>&lt;bean&gt;</code> 标记标识了名为 <code>filterChainProxy</code> 的组件实例，它是名为 <code>org.acegisecurity.util.FilterChainProxy</code> 的类的实例。</p> 
     <p>使用 <code>&lt;bean&gt;</code> 标记的子标记来表示 bean 的依赖关系。比如，注意第一个 <code>&lt;bean&gt;</code> 标记的 <code>&lt;property&gt;</code> 子标记。<code>&lt;property&gt;</code> 子标记定义了 <code>&lt;bean&gt;</code> 标记依赖的其他 bean 或值。</p> 
     <p>所以在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#listing1" cmimpressionsent="1">清单 1</a> 中，第一个 <code>&lt;bean&gt;</code> 标记的 <code>&lt;property&gt;</code> 子标记具有一个 name 属性和一个 <code>&lt;value&gt;</code> 子标记，分别定义了这个 bean 依赖的属性的名称和值。</p> 
     <p>同样，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#listing1" cmimpressionsent="1">清单 1</a> 中的第二个和第三个 <code>&lt;bean&gt;</code> 标记定义了一个过滤器 bean 依赖于一个管理器 bean。第二个 <code>&lt;bean&gt;</code> 标记表示过滤器 bean，而第三个 <code>&lt;bean&gt;</code> 标记表示管理器 bean。</p> 
     <p>过滤器的 <code>&lt;bean&gt;</code> 标记包含一个 <code>&lt;property&gt;</code> 子标记，该子标记具有两个属性：<code>name</code> 和 <code>ref</code>。<code>name</code> 属性定义了过滤器 bean 的属性，而 <code>ref</code> 属性引用了管理器 bean 的实例（名称）。</p> 
     <p>下一节将展示如何在 XML 配置文件中配置 Acegi 过滤器。在本文后面的内容中，您将在一个样例 Acegi 应用程序中使用过滤器。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section4"><span class="atitle">安全过滤器</span></a></p> 
     <p>正如我前面提到的一样，Acegi 使用安全过滤器为企业应用程序提供身份验证和授权服务。您可以根据应用程序的需要使用和配置不同类型的过滤器。这一节将介绍五种最重要的 Acegi 安全过滤器。</p> 
     <p><a name="section4.1"><span class="smalltitle">Session Integration Filter</span></a></p> 
     <p>Acegi 的 <em>Session Integration Filter</em>（SIF）通常是您将要配置的第一个过滤器。SIF 创建了一个<em>安全上下文对象</em>，这是一个与安全相关的信息的占位符。其他 Acegi 过滤器将安全信息保存在安全上下文中，也会使用安全上下文中可用的安全信息。</p> 
     <p>SIF 创建安全上下文并调用过滤器链中的其他过滤器。然后其他过滤器检索安全上下文并对其进行更改。比如，Authentication Processing Filter（我将稍后进行介绍）将用户信息（如用户名、密码和电子邮件地址）存储在安全上下文中。 </p> 
     <p>当所有的处理程序完成处理后，SIF 检查安全上下文是否更新。如果任何一个过滤器对安全上下文做出了更改，SIF 将把更改保存到服务器端的会话对象中。如果安全上下文中没有发现任何更改，那么 SIF 将删除它。</p> 
     <p>在 XML 配置文件中对 SIF 进行了配置，如清单 2 所示：</p> 
     <br /> 
     <a name="listing2"><strong>清单 2. 配置 SIF</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;httpSessionContextIntegrationFilter&quot;
            class=&quot;org.acegisecurity.context.HttpSessionContextIntegrationFilter&quot;/&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p><a name="section4.2"><span class="smalltitle">Authentication Processing Filter</span></a></p> 
     <p>Acegi 使用 <em>Authentication Processing Filter</em>（APF）进行身份验证。APF 使用一个身份验证（或登录）表单，用户在其中输入用户名和密码，并触发身份验证。</p> 
     <p>APF 执行所有的后端身份验证处理任务，比如从客户机请求中提取用户名和密码，从后端用户库中读取用户参数，以及使用这些信息对用户进行身份验证。 </p> 
     <p>在配置 APF 时，您必须提供如下参数：</p> 
     <ul> 
      <li><strong>Authentication manager</strong> 指定了用来管理身份验证提供者的身份验证管理器。<br /> <br /> </li>
      <li><strong>Filter processes URL</strong> 指定了客户在登录窗口中按下 <strong>Sign In</strong> 按钮时要访问的 URL。收到这个 URL 的请求后，Acegi 立即调用 APF。<br /> <br /> </li>
      <li><strong>Default target URL</strong> 指定了成功进行身份验证和授权后呈现给用户的页面。<br /> <br /> </li>
      <li><strong>Authentication failure URL</strong> 指定了身份验证失败情况下用户看到的页面。 </li> 
     </ul> 
     <p>APF 从用户的请求对象中得到用户名、密码和其他信息。它将这些信息传送给身份验证管理器。身份验证管理器使用适当的提供者从后端用户库中读取详细的用户信息（如用户名、密码、电子邮件地址和用户访问权利或特权），对用户进行身份验证，并将信息存储在一个 <code>Authentication</code> 对象中。</p> 
     <p>最后，APF 将 <code>Authentication</code> 对象保存在 SIF 之前创建的安全上下文中。存储在安全上下文中的 <code>Authentication</code> 对象将用于做出授权决策。</p> 
     <p>APF 的配置如清单 3 所示：</p> 
     <br /> 
     <a name="listing3"><strong>清单 3. 配置 APF</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;authenticationProcessingFilter&quot;
            class=&quot;org.acegisecurity.ui.webapp.AuthenticationProcessingFilter&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot;
            ref=&quot;authenticationManager&quot; /&gt;
            &lt;property name=&quot;filterProcessesUrl&quot;
            value=&quot;/j_acegi_security_check&quot; /&gt;
            &lt;property name=&quot;defaultTargetUrl&quot;
            value=&quot;/protected/protected1.jsp&quot; /&gt;
            &lt;property name=&quot;authenticationFailureUrl&quot;
            value=&quot;/login.jsp?login_error=1&quot; /&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>可以从这段代码中看到，APF 依赖于上面讨论的这四个参数。每个参数都是作为清单 3 所示的 <code>&lt;property&gt;</code> 标记配置的。</p> 
     <p><a name="section4.3"><span class="smalltitle">Logout Processing Filter</span></a></p> 
     <p>Acegi 使用一个 <em>Logout Processing Filer</em>（LPF）管理注销处理。当客户机发来注销请求时，将使用 LPF 进行处理。它标识了来自由客户机所调用 URL 的注销请求。</p> 
     <p>LPF 的配置如清单 4 所示：</p> 
     <br /> 
     <a name="listing4"><strong>清单 4. 配置 LPF</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;logoutFilter&quot; class=&quot;org.acegisecurity.ui.logout.LogoutFilter&quot;&gt;
            &lt;constructor-arg value=&quot;/logoutSuccess.jsp&quot;/&gt;
            &lt;constructor-arg&gt;
            &lt;list&gt;
            &lt;bean class=&quot;org.acegisecurity.ui.logout.SecurityContextLogoutHandler&quot;/&gt;
            &lt;/list&gt;
            &lt;/constructor-arg&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>可以看到 LPF 在其构造方法中包含两个参数：注销成功 URL（<code>/logoutSuccess.jsp</code>）和处理程序列表。注销成功 URL 用来在注销过程完成后重定向客户机。处理程序执行实际的注销过程；我在这里只配置了一个处理程序，因为只需一个处理程序就可以使 HTTP 会话变为无效。我将在本系列下一篇文章中讨论更多的处理程序。</p> 
     <p><a name="section4.4"><span class="smalltitle">Exception Translation Filter</span></a></p> 
     <p><em>Exception Translation Filter</em>（ETF）处理身份验证和授权过程中的异常情况，比如授权失败。在这些异常情况中，ETF 将决定如何进行操作。</p> 
     <p>比如，如果一个没有进行身份验证的用户试图访问受保护的资源，ETF 将显示一个登录页面要求用户进行身份验证。类似地，在授权失败的情况下，可以配置 ETF 来呈现一个 Access Denied 页面。</p> 
     <p>ETF 的配置如清单 5 所示：</p> 
     <br /> 
     <a name="listing5"><strong>清单 5. 配置 ETF</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;exceptionTranslationFilter&quot;
            class=&quot;org.acegisecurity.ui.ExceptionTranslationFilter&quot;&gt;
            &lt;property name=&quot;authenticationEntryPoint&quot;&gt;
            &lt;bean
            class=&quot;org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPoint&quot;&gt;
            &lt;property name=&quot;loginFormUrl&quot; value=&quot;/login.jsp&quot; /&gt;
            &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name=&quot;accessDeniedHandler&quot;&gt;
            &lt;bean class=&quot;org.acegisecurity.ui.AccessDeniedHandlerImpl&quot;&gt;
            &lt;property name=&quot;errorPage&quot; value=&quot;/accessDenied.jsp&quot; /&gt;
            &lt;/bean&gt;
            &lt;/property&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>正如清单 5 所示，ETF 包含两个参数，名为 <code>authenticationEntryPoint</code> 和 <code>accessDeniedHandler</code>。<code>authenticationEntryPoint</code> 属性指定登录页面，而 <code>accessDeniedHandler</code> 指定 Access Denied 页面。</p> 
     <p><a name="section4.5"><span class="smalltitle">拦截过滤器</span></a></p> 
     <p>Acegi 的<em>拦截过滤器</em> 用于做出授权决策。您需要在 APF 成功执行身份验证后对拦截过滤器进行配置，以使其发挥作用。拦截器使用应用程序的访问控制策略来做出授权决定。</p> 
     <p>本系列的下一篇文章将展示如何设计访问控制策略，如何将它们托管在目录服务中，以及如何配置 Acegi 以读取您的访问控制策略。但是，目前我将继续向您展示如何使用 Acegi 配置一个简单的访问控制策略。在本文后面的部分，您将看到使用简单的访问控制策略构建一个样例应用程序。</p> 
     <p>配置简单的访问控制策略可分为两个步骤：</p> 
     <ol> 
      <li>编写访问控制策略。<br /> <br /> </li>
      <li>根据策略配置 Acegi 的拦截过滤器。 </li> 
     </ol> 
     <p><strong>步骤 1. 编写简单的访问控制策略</strong> <br /> <br /> 首先看一下 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#listing6" cmimpressionsent="1">清单 6</a>，它展示了如何定义一个用户及其用户角色：</p> 
     <br /> 
     <a name="listing6"><strong>清单 6. 为用户定义简单的访问控制策略</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        alice=123,ROLE_HEAD_OF_ENGINEERING
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>清单 6 所示的访问控制策略定义了用户名 <code>alice</code>，它的密码是 <code>123</code>，角色是 <code>ROLE_HEAD_OF_ENGINEERING</code>。（下一节将说明如何在文件中定义任意数量的用户及其用户角色，然后配置拦截过滤器以使用这些文件。）</p> 
     <p><strong>步骤 2. 配置 Acegi 的拦截过滤器</strong> <br /> <br /> 拦截过滤器使用三个组件来做出授权决策，我在清单 7 中对其进行了配置：</p> 
     <br /> 
     <a name="listing7"><strong>清单 7. 配置拦截过滤器 </strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;bean id=&quot;filterInvocationInterceptor&quot;
            class=&quot;org.acegisecurity.intercept.web.FilterSecurityInterceptor&quot;&gt;
            &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot; /&gt;
            &lt;property name=&quot;accessDecisionManager&quot; ref=&quot;accessDecisionManager&quot; /&gt;
            &lt;property name=&quot;objectDefinitionSource&quot;&gt;
            &lt;value&gt;
            CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
            PATTERN_TYPE_APACHE_ANT
            /protected/**=ROLE_HEAD_OF_ENGINEERING
            /**=IS_AUTHENTICATED_ANONYMOUSLY
            &lt;/value&gt;
            &lt;/property&gt;
            &lt;!--  More properties of the interceptor filter --&gt;
            &lt;/bean&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>如清单 7 所示，配置所需的三个组件是 <code>authenticationManager</code>、<code>accessDecisionManager</code>、<code>objectDefinitionSource</code>：</p> 
     <ul> 
      <li><code>authenticationManager</code> 组件与我在介绍 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#section4.2" cmimpressionsent="1">Authentication Processing Filter</a> 时讨论过的身份验证管理器相同。拦截过滤器可以在授权的过程中使用 <code>authenticationManager</code> 重新对客户机进行身份验证。<br /> <br /> </li>
      <li><code>accessDecisionManager</code> 组件管理授权过程，这部分内容将在本系列的下篇文章中详细讨论。<br /> <br /> </li>
      <li><code>objectDefinitionSource</code> 组件包含对应于将要发生的授权的访问控制定义。例如，<a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#listing7" cmimpressionsent="1">清单 7</a> 中的 <code>objectDefinitionSource</code> 属性值包含两个 URL（<code>/protected/*</code> 和 <code>/*</code>）。其值定义了这些 URL 的角色。<code>/protected/*</code> URL 的角色是 <code>ROLE_HEAD_OF_ENGINEERING</code>。您可以根据应用程序的需要定义任何角色。<br /> <br /> 回想一下 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#listing6" cmimpressionsent="1">清单 6</a>，您为用户名 <code>alice</code> 定义了 <code>ROLE_HEAD_OF_ENGINEERING</code>。这就是说 <code>alice</code> 将能够访问 <code>/protected/*</code> URL。 </li> 
     </ul> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section5"><span class="atitle">过滤器工作原理</span></a></p> 
     <p>正如您已经了解到的一样，Acegi 的组件彼此依赖，从而对您的应用程序进行保护。在本文后面的部分，您将看到如何对 Acegi 进行配置，从而按照特定的顺序应用安全过滤器，因此需要创建<em>过滤器链</em>。出于这个目的，Acegi 保存了一个过滤器链对象，它封装了为保护应用程序而配置了的所有过滤器。图 1 展示了 Acegi 过滤器链的生命周期，该周期从客户机向您的应用程序发送 HTTP 请求开始。（图 1 显示了服务于浏览器客户机的容器。）</p> 
     <br /> 
     <a name="fig1"><strong>图 1. 托管 Acegi 过滤器链以安全地为浏览器客户机服务的容器</strong></a>
     <br /> 
     <img height="187" alt="Acegi 过滤器的生命周期" src="http://www.ibm.com/developerworks/cn/java/j-acegi1/figure1.gif" width="315" /> 
     <br /> 
     <p>下面的步骤描述了过滤器链的生命周期：</p> 
     <ol> 
      <li>浏览器客户机向您的应用程序发送 HTTP 请求。<br /> <br /> </li>
      <li>容器接收到 HTTP 请求并创建一个请求对象，该对象将封装 HTTP 请求中包含的信息。容器还创建一个各种过滤器都可处理的响应对象，从而为发出请求的客户机准备好 HTTP 响应。容器然后调用 Acegi 的过滤器链代理，这是一个代理过滤器。该代理知道应用的过滤器的实际顺序。当容器调用代理时，它将向代理发送请求、响应以及过滤器链对象。<br /> <br /> </li>
      <li>代理过滤器调用过滤器链中第一个过滤器，向其发送请求、响应和过滤器链对象。<br /> <br /> </li>
      <li>链中的过滤器逐个执行其处理。一个过滤器可以通过调用过滤器链中下一个过滤器随时终止自身处理。有的过滤器甚至根本不执行任何处理（比如，如果 APF 发现一个到来的请求没有要求身份验证，它可能会立即终止其处理）。 <br /> <br /> </li>
      <li>当身份验证过滤器完成其处理时，这些过滤器将把请求和响应对象发送到应用程序中配置的拦截过滤器。<br /> <br /> </li>
      <li>拦截器决定是否对发出请求的客户机进行授权，使它访问所请求的资源。<br /> <br /> </li>
      <li>拦截器将控制权传输给应用程序（比如，成功进行了身份验证和授权的客户机请求的 JSP 页面）。<br /> <br /> </li>
      <li>应用程序改写响应对象的内容。<br /> <br /> </li>
      <li>响应对象已经准备好了，容器将响应对象转换为 HTTP 响应，并将响应发送到发出请求的客户机。<br /> <br /> </li> 
     </ol> 
     <p>为帮助您进一步理解 Acegi 过滤器，我将详细探讨其中两个过滤器的操作：Session Integration Filter 和 Authentication Processing Filter。</p> 
     <p><a name="section5.1"><span class="smalltitle">SIF 如何创建一个安全上下文</span></a></p> 
     <p>图 2 展示了 SIF 创建安全上下文所涉及到的步骤：</p> 
     <br /> 
     <a name="fig2"><strong>图 2. SIF 创建安全上下文</strong></a>
     <br /> 
     <img height="262" alt="SIF 如何创建安全上下文" src="http://www.ibm.com/developerworks/cn/java/j-acegi1/figure2.gif" width="317" /> 
     <br /> 
     <p>现在详细地考虑下面这些步骤：</p> 
     <ol> 
      <li>Acegi 的过滤器链代理调用 SIF 并向其发送请求、响应和过滤器链对象。注意：通常将 SIF 配置为过滤器链中第一个过滤器。<br /> <br /> </li>
      <li>SIF 检查它是否已经对这个 Web 请求进行过处理。如果是的话，它将不再进一步进行处理，并将控制权传输给过滤器链中的下一个过滤器（参见下面的第 4 个步骤）。如果 SIF 发现这是第一次对这个 Web 请求调用 SIF，它将设置一个标记，将在下一次使用该标记，以表示曾经调用过 SIF。<br /> <br /> </li>
      <li>SIF 将检查是否存在一个会话对象，以及它是否包含安全上下文。它从会话对象中检索安全上下文，并将其放置在名为 <em>security context holder</em> 的临时占位符中。如果不存在会话对象，SIF 将创建一个新的安全上下文，并将它放到 security context holder 中。注意：security context holder 位于应用程序的范围内，所以可以被其他的安全过滤器访问。<br /> <br /> </li>
      <li>SIF 调用过滤器链中的下一个过滤器。<br /> <br /> </li>
      <li>其他过滤器可以编辑安全上下文。<br /> <br /> </li>
      <li>SIF 在过滤器链完成处理后接收控制权。<br /> <br /> </li>
      <li>SIF 检查其他的过滤器是否在其处理过程中更改了安全上下文（比如，APF 可能将用户详细信息存储在安全上下文中）。如果是的话，它将更新会话对象中的安全上下文。就是说在过滤器链处理过程中，对安全上下文的任何更改现在都保存在会话对象中。 </li> 
     </ol> 
     <p><a name="section5.2"><span class="smalltitle">APF 如何对用户进行身份验证</span></a></p> 
     <p>图 3 展示了 APF 对用户进行身份验证所涉及到的步骤：</p> 
     <br /> 
     <a name="fig3"><strong>图 3. APF 对用户进行身份验证</strong></a>
     <br /> 
     <img height="340" alt="APF 如何对用户进行身份验证" src="http://www.ibm.com/developerworks/cn/java/j-acegi1/figure3.gif" width="392" /> 
     <br /> 
     <p>现在仔细考虑以下这些步骤：</p> 
     <ol> 
      <li>过滤器链中前面的过滤器向 APF 发送请求、响应和过滤链对象。<br /> <br /> </li>
      <li>APF 使用从请求对象中获得的用户名、密码以及其他信息创建身份验证标记。<br /> <br /> </li>
      <li>APF 将身份验证标记传递给身份验证管理器。<br /> <br /> </li>
      <li>身份验证管理器可能包含一个或更多身份验证提供者。每个提供者恰好支持一种类型的身份验证。管理器检查哪一种提供者支持它从 APF 收到的身份验证标记。<br /> <br /> </li>
      <li>身份验证管理器将身份验证标记发送到适合进行身份验证的提供者。<br /> <br /> </li>
      <li>身份验证提供者支持从身份验证标记中提取用户名，并将它发送给名为 <em>user cache service</em> 的服务。Acegi 缓存了已经进行过身份验证的用户。该用户下次登录时，Acegi 可以从缓存中加载他或她的详细信息（比如用户名、密码和权限），而不是从后端数据存储中读取数据。这种方法使得性能得到了改善。<br /> <br /> </li>
      <li>user cache service 检查用户的详细信息是否存在于缓存中。<br /> <br /> </li>
      <li>user cache service 将用户的详细信息返回给身份验证提供者。如果缓存不包含用户详细信息，则返回 null。<br /> <br /> </li>
      <li>身份验证提供者检查缓存服务返回的是用户的详细信息还是 null。<br /> <br /> </li>
      <li>如果缓存返回 null，身份验证提供者将用户名（在步骤 6 中提取）发送给另一个名为 <em>user details service</em> 的服务。 <br /> <br /> </li>
      <li>user details service 与包含用户详细信息的后端数据存储通信（如目录服务）。 <br /> <br /> </li>
      <li>user details service 返回用户的详细信息，或者，如果找不到用户详细信息则抛出身份验证异常。<br /> <br /> </li>
      <li>如果 user cache service 或者 user details service 返回有效的用户详细信息，身份验证提供者将使用 user cache service 或 user details service 返回的密码来匹配用户提供的安全标记（如密码）。如果找到一个匹配，身份验证提供者将用户的详细信息返回给身份验证管理器。否则的话，则抛出一个身份验证异常。<br /> <br /> </li>
      <li>身份验证管理器将用户的详细信息返回给 APF。这样用户就成功地进行了身份验证。<br /> <br /> </li>
      <li>APF 将用户详细信息保存在 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#fig2" cmimpressionsent="1">图 2</a> 所示由步骤 3 创建的安全上下文中。<br /> <br /> </li>
      <li>APF 将控制权传输给过滤器链中的下一个过滤器。 </li> 
     </ol> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section6"><span class="atitle">一个简单的 Acegi 应用程序</span></a></p> 
     <p>在本文中，您已经了解了很多关于 Acegi 的知识，所以现在看一下利用您目前学到的知识能做些什么，从而结束本文。对于这个简单的演示，我设计了一个样例应用程序（参见 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#download" cmimpressionsent="1">下载</a>），并对 Acegi 进行了配置以保护它的一些资源。 </p> 
     <p>样例应用程序包含 5 个 JSP 页面：index.jsp、protected1.jsp、protected2.jsp、login.jsp 和 accessDenied.jsp。</p> 
     <p>index.jsp 是应用程序的欢迎页面。它向用户显示了三个超链接，如图 4 所示：</p> 
     <br /> 
     <a name="fig4"><strong>图 4. 样例应用程序的欢迎页面：</strong></a>
     <br /> 
     <img height="280" alt="一个简单的 Acegi 应用程序" src="http://www.ibm.com/developerworks/cn/java/j-acegi1/figure4.jpg" width="468" /> 
     <br /> 
     <p>图 4 所示的链接中，其中两个链接指向了被保护的资源（protected1.jsp 和 protected2.jsp），第三个链接指向登录页面（login.jsp）。只有在 Acegi 发现用户没有被授权访问受保护的资源时，才会显示 accessDenied.jsp 页面。</p> 
     <p>如果用户试图访问任何受保护的页面，样例应用程序将显示登录页面。当用户使用登录页面进入后，应用程序将自动重定向到被请求的受保护资源。</p> 
     <p>用户可以通过单击欢迎页面中的第三个链接直接请求登录页面。这种情况下，应用程序显示用户可以进入系统的登录页面。进入系统以后，应用程序将用户重定向到 protected1.jsp，它是用户进入系统而没有请求特定的受保护资源时显示的默认资源。</p> 
     <p><a name="section6.1"><span class="smalltitle">配置样例应用程序</span></a></p> 
     <p>为本文下载的源代码包含一个名为 acegi-config.xml 的 XML 配置文件，它包含 Acegi 过滤器的配置。根据 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#section4" cmimpressionsent="1">安全过滤器的讨论</a> 中的示例，您应该很熟悉这些配置。</p> 
     <p>我还为样例应用程序编写了一个 <code>web.xml</code> 文件，如清单 8 所示：</p> 
     <br /> 
     <a name="listing8"><strong>清单 8. 样例应用程序的 web.xml 文件</strong></a>
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td class="code-outline"> <pre class="displaycode">                        &lt;web-app&gt;
            &lt;context-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/acegi-config.xml&lt;/param-value&gt;
            &lt;/context-param&gt;
            &lt;filter&gt;
            &lt;filter-name&gt;Acegi Filter Chain Proxy&lt;/filter-name&gt;
            &lt;filter-class&gt;
            org.acegisecurity.util.FilterToBeanProxy
            &lt;/filter-class&gt;
            &lt;init-param&gt;
            &lt;param-name&gt;targetClass&lt;/param-name&gt;
            &lt;param-value&gt;
            org.acegisecurity.util.FilterChainProxy
            &lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;/filter&gt;
            &lt;filter-mapping&gt;
            &lt;filter-name&gt;Acegi Filter Chain Proxy&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
            &lt;/filter-mapping&gt;
            &lt;listener&gt;
            &lt;listener-class&gt;
            org.springframework.web.context.ContextLoaderListener
            &lt;/listener-class&gt;
            &lt;/listener&gt;
            &lt;/web-app&gt;
            </pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <p>web.xml 文件配置如下：</p> 
     <ul> 
      <li><code>acegi-config.xml</code> 文件的 URL 位于 <code>&lt;context-param&gt;</code> 标记中。<br /> <br /> </li>
      <li>Acegi 过滤器链代理类的名称位于 <code>&lt;filter&gt;</code> 标记中。<br /> <br /> </li>
      <li>URL 到 Acegi 过滤器链代理的映射在 <code>&lt;filter-mapping&gt;</code> 标记中。注意：您可以简单地将应用程序的所有 URL（<code>/*</code>）映射到 Acegi 过滤器链代理。Acegi 将对映射到 Acegi 过滤器链代理上的所有 URL 应用安全性。<br /> <br /> </li>
      <li>应用程序上下文加载程序位于 <code>&lt;listener&gt;</code> 标记中，它将加载 Spring 的 IOC 框架。 </li> 
     </ul> 
     <p><a name="section6.2"><span class="smalltitle">部署并运行应用程序</span></a></p> 
     <p>部署并运行样例应用程序非常的简单。只需要完成两件事情：</p> 
     <ol> 
      <li>将 acegisample.war 文件从本教程下载的源代码中复制到安装 Tomcat 的 <code>webapps</code> 目录中。<br /> <br /> </li>
      <li>从 Acegi Security System 主页 <a href="http://www.acegisecurity.org/downloads.html" cmimpressionsent="1">下载并解压缩 acegi-security-1.0.3.zip</a>。您将找到一个名为 acegi-security-sample-tutorial.war 的样例应用程序。解压缩 war 文件并提取其 WEB-INF/lib 文件夹中所有的 jar 文件。将所有的 JAR 文件从 WEB-INF/lib 文件夹中复制到 theacegisample.war 应用程序的 WEB-INF/lib 文件夹。 </li> 
     </ol> 
     <p>现在，您已经为运行样例应用程序做好准备了。启动 Tomcat 并将浏览器指向 <code>http://localhost:8080/acegisample/</code>。</p> 
     <p>您将看到 <a href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#fig4" cmimpressionsent="1">图 4</a> 所示的欢迎页面，但是此时显示的页面是真实的。请继续运行程序，并查看在尝试访问欢迎页面显示的不同链接时会发生什么状况。</p> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="section7"><span class="atitle">结束语</span></a></p> 
     <p>在<em>使用 Acegi 保护 Java 应用程序</em> 系列的第一篇文章中，您了解了 Acegi 安全系统的特性、架构和组件，学习了大量有关 Acegi 安全过滤器的知识，这些过滤器被集成到 Acegi 的安全框架中。您还学习了如何使用 XML 配置文件配置组件依赖关系，并查看了 Acegi 的安全过滤器在样例程序中工作的情形，该应用程序可以实现基于 URL 的安全性。 </p> 
     <p>本文所述的安全技术非常的简单，所以 Acegi 使用这些技术实现安全性。本系列的下一文章将开始介绍 Acegi 的一些较为高级的应用，首先是编写访问控制协议并将其存储到目录服务中。您还将了解到如何配置 Acegi，使它与目录服务交互，从而实现您的访问控制策略。</p> 
     <br /> 
     <br /> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/v14/rules/blue_rule.gif" width="100%" /><br /> <img height="6" alt="" src="http://www.ibm.com/i/c.gif" width="8" border="0" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="no-print" cellspacing="0" cellpadding="0" align="right"> 
      <tbody> 
       <tr align="right"> 
        <td><img height="4" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /><br /> 
         <table cellspacing="0" cellpadding="0" border="0"> 
          <tbody> 
           <tr> 
            <td valign="middle"><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/u_bold.gif" width="16" border="0" /><br /> </td> 
            <td valign="top" align="right"><a class="fbox" href="http://www.ibm.com/developerworks/cn/java/j-acegi1/#main" cmimpressionsent="1"><strong>回页首</strong></a></td> 
           </tr> 
          </tbody> 
         </table> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><span class="atitle"><a name="download">下载</a></span></p> 
     <table class="data-table-1" cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <th scope="col">描述</th> 
        <th scope="col">名字</th> 
        <th scope="col">大小</th> 
        <th scope="col">下载方法</th> 
       </tr> 
       <tr> 
        <th class="tb-row" scope="row">本文源代码</th> 
        <td nowrap="">j-acegi1.zip</td> 
        <td nowrap="">10KB</td> 
        <td nowrap=""><a class="fbox" href="http://download.boulder.ibm.com/ibmdl/pub/software/dw/java/j-acegi1.zip" cmimpressionsent="1"><strong>HTTP</strong></a></td> 
       </tr> 
      </tbody> 
     </table> 
     <table cellspacing="0" cellpadding="0" border="0"> 
      <tbody> 
       <tr valign="top"> 
        <td colspan="5"><img height="12" alt="" src="http://www.ibm.com/i/c.gif" width="12" border="0" /></td> 
       </tr> 
       <tr> 
        <td><img height="16" alt="" src="http://www.ibm.com/i/v14/icons/fw.gif" width="16" /></td> 
        <td><a class="fbox" href="http://www.ibm.com/developerworks/cn/whichmethod.html" cmimpressionsent="1">关于下载方法的信息</a></td> 
        <td><img height="1" alt="" src="http://www.ibm.com/i/c.gif" width="50" /></td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 
     <p><a name="resources"><span class="atitle">参考资料 </span></a></p> 
     <strong>学习</strong>
     <br /> 
     <ul> 
      <li>您可以参阅本文在 developerWorks 全球站点上的 <a href="http://www.ibm.com/developerworks/java/library/j-acegi1/?S_TACT=105AGX52&amp;S_CMP=cn-a-j" target="_blank" cmimpressionsent="1">英文原文</a> 。<br /> <br /> </li>
      <li><a href="http://www.acegisecurity.org/" cmimpressionsent="1">Acegi Security System 主页</a>： 查找参考文档的第一站，并可以下载 Acegi。<br /> <br /> </li>
      <li>“<a href="http://www.ibm.com/developerworks/cn/java/jw-0428-security/" cmimpressionsent="1">Java 安全性的演变和理念 第一部分：安全性的基本要点</a>”（Raghavan Srinivas，developerWorks，2000 年 5 月）：对 Java 安全概念和技术进行了概述。<br /> <br /> </li>
      <li>“<a href="http://www.ibm.com/developerworks/cn/views/java/tutorials.jsp?cv_doc_id=85017" cmimpressionsent="1">Java 安全性，第一部分： 密码学基础</a>”（Brad Rubin，developerWorks，2002 年 7 月）：全面地介绍了 Java 平台上应用程序的安全性。还可参阅 “<a href="http://www.ibm.com/developerworks/cn/views/java/tutorials.jsp?cv_doc_id=84887" cmimpressionsent="1">Java 安全性， 第二部分： 认证与授权</a>”。<br /> <br /> </li>
      <li>“<a href="http://www.ibm.com/developerworks/web/library/wa-appsec/?S_TACT=105AGX52&amp;S_CMP=cn-a-j" cmimpressionsent="1">Web app security using Struts, servlet filters, and custom taglibs</a>”（Swaminathan Radhakrishnan，developerWorks，2004 年 9 月）：展示 Java 安全解决方案开发中的常用技巧。<br /> <br /> </li>
      <li>“<a href="http://www.ibm.com/developerworks/cn/views/java/tutorials.jsp?cv_doc_id=156552" cmimpressionsent="1">Spring 2 和 JPA 简介</a>”（Sing Li，developerWorks，2006 年 8 月）：这篇教程将介绍第二代 Spring 框架。<br /> <br /> </li>
      <li><a href="http://static.springframework.org/spring/docs/2.0.x/reference/index.%20html" cmimpressionsent="1">Spring 参考文档</a>：来自资源的 Spring 文档。<br /> <br /> </li>
      <li>“<a href="http://java.sun.com/products/servlet/Filters.html" cmimpressionsent="1">The Essentials of Filters</a>”（Sun Developer Network）：了解更多过滤器及其用途。<br /> <br /> </li>
      <li><a href="http://java.sun.com/security" cmimpressionsent="1">Java SE Security</a>：一个 Java 安全信息资料库。<br /> <br /> </li>
      <li><a href="http://www.ibm.com/developerworks/cn/java/j-ibmsecurity.html" cmimpressionsent="1">IBM 安全提供者：概述</a>（Yanni Zhang，Audrey Timkovich 和 John Peck；developerWorks，2004 年 10 月）：了解用于 Java 平台（1.4.2 Java SDK）的 IBM 开发人员工具包增强了的安全特性，以及它与 Sun Microsystems 版本的区别。<br /> <br /> </li>
      <li><a href="http://www.ibm.com/developerworks/cn/java/" cmimpressionsent="1">developerWorks Java 技术专区</a>：提供了大量有关 Java 编程各个方面的文章。<br /> <br /> </li> 
     </ul> 
     <br /> 
     <strong>获得产品和技术</strong>
     <br /> 
     <ul> 
      <li><a href="http://www.acegisecurity.org/downloads.html" cmimpressionsent="1">下载 Acegi Security System</a>：保护您的 Java 企业应用程序。 </li> 
     </ul> 
     <br /> 
     <strong>讨论</strong>
     <br /> 
     <ul> 
      <li><a href="http://www.ibm.com/developerworks/forums/dw_forum.jsp?S_TACT=105AGX52&amp;cat=5&amp;S_CMP=cn-a-j&amp;forum=375" cmimpressionsent="1">参与论坛讨论</a>。<br /> <br /> </li>
      <li>通过参与 <a href="http://www.ibm.com/developerworks/blogs/?S_TACT=105AGX52&amp;S_CMP=cn-a-j" cmimpressionsent="1">developerWorks blog</a> 加入 <a href="http://www.ibm.com/developerworks/community?S_TACT=105AGX52&amp;S_CMP=cn-a-j" cmimpressionsent="1">developerWorks 社区</a>。 <br /> <br /> </li> 
     </ul> 
     <br /> 
     <br /> 
     <p><a name="author"><span class="atitle">关于作者</span></a></p> 
     <table cellspacing="0" cellpadding="0" width="100%" border="0"> 
      <tbody> 
       <tr> 
        <td colspan="3"><img height="5" alt="" src="http://www.ibm.com/i/c.gif" width="100%" /></td> 
       </tr> 
       <tr valign="top" align="left"> 
        <td> <p>&nbsp;</p> </td> 
        <td><img height="5" alt="" src="http://www.ibm.com/i/c.gif" width="4" /></td> 
        <td width="100%"> <p>Bilal Siddiqui 是一名电子工程师、XML 顾问，他还是 WaxSys（主要从事电子商务简化）的创建者之一。自从 1995 年毕业于拉合尔工程技术大学（University of Engineering and Technology，Lahore）电子工程专业以后，他就开始为工业控制系统设计各种软件解决方案。稍后，他致力于 XML 方面并使用他在 C++ 编程中取得的经验来构建基于 Web 和 WAP 的 XML 处理工具、服务器端解析方案和服务应用程序。Bilal 是一名技术推广者，并且是一名多产的技术作家。</p> </td> 
       </tr> 
      </tbody> 
     </table> 
     <br /> 
     <br /> 来自:http://www.cnblogs.com/amboyna/archive/2008/03/25/1122079.html 
     <p class="postfoot"> posted @ <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199309.html" title="permalink">2008-05-08 18:41</a> 狼爱上狸 阅读(261) | <a href="http://www.blogjava.net/waterjava/archive/2008/05/08/199309.html#FeedBack" title="comments, pingbacks, trackbacks">评论 (0)</a> |&nbsp;<a href="http://www.blogjava.net/waterjava/admin/EditPosts.aspx?postid=199309">编辑</a>&nbsp;<a href="http://www.blogjava.net/waterjava/AddToFavorite.aspx?id=199309">收藏</a> </p> 
    </div> 
    <div id="homepage1_HomePageDays_ctl00_DayList_BottomPager" style="text-align:right;margin-right:10px;margin-top:10px;">
     <style>.pager { text-align:right;	}</style>
     <a href="http://www.blogjava.net/waterjava/default.html?page=8&amp;OnlyTitle=1">仅列出标题</a>
     <div class="pager">
       共24页:&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=1">First</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=7">上一页</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=4">4</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=5">5</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=6">6</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=7">7</a>&nbsp;8&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=9">9</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=10">10</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=11">11</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=12">12</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=9">下一页</a>&nbsp;
      <a href="http://www.blogjava.net/waterjava/default.html?page=24">Last</a>&nbsp; 
     </div>
    </div> 
   </div> 
   <p id="footer"> Powered by: <br /> <a id="Footer1_Hyperlink3" name="Hyperlink1" href="http://www.blogjava.net/"><font face="Verdana">BlogJava</font></a> <br /> Copyright &copy; 狼爱上狸 </p> 
  </form> 
  <script type="text/javascript" src="/script/ShowHidden.js"></script> 
  <script type="text/javascript">
	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-476124-3']);
	  _gaq.push(['_trackPageview']);

	  (function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();
	</script>   
 </body>
</html>